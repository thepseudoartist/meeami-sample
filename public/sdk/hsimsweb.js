// Support for growable heap + pthreads, where the buffer may change, so JS views
// must be updated.
function GROWABLE_HEAP_STORE_I8(ptr, value) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  HEAP8[ptr] = value;
}
function GROWABLE_HEAP_STORE_I16(ptr, value) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  HEAP16[ptr >> 1] = value;
}
function GROWABLE_HEAP_STORE_I32(ptr, value) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  HEAP32[ptr >> 2] = value;
}
function GROWABLE_HEAP_STORE_F32(ptr, value) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  HEAPF32[ptr >> 2] = value;
}
function GROWABLE_HEAP_STORE_F64(ptr, value) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  HEAPF64[ptr >> 3] = value;
}

function GROWABLE_HEAP_LOAD_I8(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAP8[ptr];
}
function GROWABLE_HEAP_LOAD_U8(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAPU8[ptr];
}
function GROWABLE_HEAP_LOAD_I16(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAP16[ptr >> 1];
}
function GROWABLE_HEAP_LOAD_U16(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAPU16[ptr >> 1];
}
function GROWABLE_HEAP_LOAD_I32(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAP32[ptr >> 2];
}
function GROWABLE_HEAP_LOAD_U32(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAPU32[ptr >> 2];
}
function GROWABLE_HEAP_LOAD_F32(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAPF32[ptr >> 2];
}
function GROWABLE_HEAP_LOAD_F64(ptr) {
  if (wasmMemory.buffer != buffer) {
    buffer = wasmMemory.buffer;
    updateGlobalBufferViews();
  }
  return HEAPF64[ptr >> 3];
}
function GROWABLE_HEAP_VIEW_I8(start, end) {
  return new Int8Array(wasmMemory.buffer, start, end - start);
}
function GROWABLE_HEAP_VIEW_U8(start, end) {
  return new Uint8Array(wasmMemory.buffer, start, end - start);
}
function GROWABLE_HEAP_VIEW_I16(start, end) {
  return new Int16Array(wasmMemory.buffer, start >> 1, end - start >> 1);
}
function GROWABLE_HEAP_VIEW_U16(start, end) {
  return new Uint16Array(wasmMemory.buffer, start >> 1, end - start >> 1);
}
function GROWABLE_HEAP_VIEW_I32(start, end) {
  return new Int32Array(wasmMemory.buffer, start >> 2, end - start >> 2);
}
function GROWABLE_HEAP_VIEW_U32(start, end) {
  return new Uint32Array(wasmMemory.buffer, start >> 2, end - start >> 2);
}
function GROWABLE_HEAP_VIEW_F32(start, end) {
  return new Float32Array(wasmMemory.buffer, start >> 2, end - start >> 2);
}
function GROWABLE_HEAP_VIEW_F64(start, end) {
  return new Float64Array(wasmMemory.buffer, start >> 3, end - start >> 3);
}


var Module = typeof Module !== "undefined" ? Module : {};
if (!Module.expectedDataFileDownloads) {
 Module.expectedDataFileDownloads = 0;
 Module.finishedDataFileDownloads = 0;
}
Module.expectedDataFileDownloads++;
((function() {
 var loadPackage = (function(metadata) {
  var PACKAGE_PATH;
  if (typeof window === "object") {
   PACKAGE_PATH = window["encodeURIComponent"](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/");
  } else if (typeof location !== "undefined") {
   PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/");
  } else {
   throw "using preloaded data can only be done on a web page or in a web worker";
  }
  var PACKAGE_NAME = "hsimsweb.data";
  var REMOTE_PACKAGE_BASE = "hsimsweb.data";
  if (typeof Module["locateFilePackage"] === "function" && !Module["locateFile"]) {
   Module["locateFile"] = Module["locateFilePackage"];
   err("warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)");
  }
  var REMOTE_PACKAGE_NAME = Module["locateFile"] ? Module["locateFile"](REMOTE_PACKAGE_BASE, "") : REMOTE_PACKAGE_BASE;
  var REMOTE_PACKAGE_SIZE = metadata.remote_package_size;
  var PACKAGE_UUID = metadata.package_uuid;
  function fetchRemotePackage(packageName, packageSize, callback, errback) {
   var xhr = new XMLHttpRequest;
   xhr.open("GET", packageName, true);
   xhr.responseType = "arraybuffer";
   xhr.onprogress = (function(event) {
    var url = packageName;
    var size = packageSize;
    if (event.total) size = event.total;
    if (event.loaded) {
     if (!xhr.addedTotal) {
      xhr.addedTotal = true;
      if (!Module.dataFileDownloads) Module.dataFileDownloads = {};
      Module.dataFileDownloads[url] = {
       loaded: event.loaded,
       total: size
      };
     } else {
      Module.dataFileDownloads[url].loaded = event.loaded;
     }
     var total = 0;
     var loaded = 0;
     var num = 0;
     for (var download in Module.dataFileDownloads) {
      var data = Module.dataFileDownloads[download];
      total += data.total;
      loaded += data.loaded;
      num++;
     }
     total = Math.ceil(total * Module.expectedDataFileDownloads / num);
     if (Module["setStatus"]) Module["setStatus"]("Downloading data... (" + loaded + "/" + total + ")");
    } else if (!Module.dataFileDownloads) {
     if (Module["setStatus"]) Module["setStatus"]("Downloading data...");
    }
   });
   xhr.onerror = (function(event) {
    throw new Error("NetworkError for: " + packageName);
   });
   xhr.onload = (function(event) {
    if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || xhr.status == 0 && xhr.response) {
     var packageData = xhr.response;
     callback(packageData);
    } else {
     throw new Error(xhr.statusText + " : " + xhr.responseURL);
    }
   });
   xhr.send(null);
  }
  function handleError(error) {
   console.error("package error:", error);
  }
  var fetchedCallback = null;
  var fetched = Module["getPreloadedPackage"] ? Module["getPreloadedPackage"](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;
  if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, (function(data) {
   if (fetchedCallback) {
    fetchedCallback(data);
    fetchedCallback = null;
   } else {
    fetched = data;
   }
  }), handleError);
  function runWithFS() {
   function assert(check, msg) {
    if (!check) throw msg + (new Error).stack;
   }
   Module["FS_createPath"]("/", "config", true, true);
   Module["FS_createPath"]("/config", "CVS", true, true);
   Module["FS_createPath"]("/config", "factorydomain", true, true);
   Module["FS_createPath"]("/config/factorydomain", "config", true, true);
   Module["FS_createPath"]("/config/factorydomain/config", "CVS", true, true);
   Module["FS_createPath"]("/config/factorydomain", "CVS", true, true);
   Module["FS_createPath"]("/config/factorydomain", "Profiles", true, true);
   Module["FS_createPath"]("/config/factorydomain/Profiles", "CVS", true, true);
   Module["FS_createPath"]("/config/factorydomain/Profiles", "factoryuser", true, true);
   Module["FS_createPath"]("/config/factorydomain/Profiles/factoryuser", "CVS", true, true);
   function DataRequest(start, end, audio) {
    this.start = start;
    this.end = end;
    this.audio = audio;
   }
   DataRequest.prototype = {
    requests: {},
    open: (function(mode, name) {
     this.name = name;
     this.requests[name] = this;
     Module["addRunDependency"]("fp " + this.name);
    }),
    send: (function() {}),
    onload: (function() {
     var byteArray = this.byteArray.subarray(this.start, this.end);
     this.finish(byteArray);
    }),
    finish: (function(byteArray) {
     var that = this;
     Module["FS_createDataFile"](this.name, null, byteArray, true, true, true);
     Module["removeRunDependency"]("fp " + that.name);
     this.requests[this.name] = null;
    })
   };
   var files = metadata.files;
   for (var i = 0; i < files.length; ++i) {
    (new DataRequest(files[i].start, files[i].end, files[i].audio)).open("GET", files[i].filename);
   }
   function processPackageData(arrayBuffer) {
    Module.finishedDataFileDownloads++;
    assert(arrayBuffer, "Loading data file failed.");
    assert(arrayBuffer instanceof ArrayBuffer, "bad input to processPackageData");
    var byteArray = new Uint8Array(arrayBuffer);
    var curr;
    DataRequest.prototype.byteArray = byteArray;
    var files = metadata.files;
    for (var i = 0; i < files.length; ++i) {
     DataRequest.prototype.requests[files[i].filename].onload();
    }
    Module["removeRunDependency"]("datafile_hsimsweb.data");
   }
   Module["addRunDependency"]("datafile_hsimsweb.data");
   if (!Module.preloadResults) Module.preloadResults = {};
   Module.preloadResults[PACKAGE_NAME] = {
    fromCache: false
   };
   if (fetched) {
    processPackageData(fetched);
    fetched = null;
   } else {
    fetchedCallback = processPackageData;
   }
  }
  if (Module["calledRun"]) {
   runWithFS();
  } else {
   if (!Module["preRun"]) Module["preRun"] = [];
   Module["preRun"].push(runWithFS);
  }
 });
 loadPackage({
  "files": [ {
   "start": 0,
   "audio": 0,
   "end": 20,
   "filename": "/config/CVS/Entries"
  }, {
   "start": 20,
   "audio": 0,
   "end": 61,
   "filename": "/config/CVS/Repository"
  }, {
   "start": 61,
   "audio": 0,
   "end": 98,
   "filename": "/config/CVS/Root"
  }, {
   "start": 98,
   "audio": 0,
   "end": 120,
   "filename": "/config/CVS/Tag"
  }, {
   "start": 120,
   "audio": 0,
   "end": 3569,
   "filename": "/config/factorydomain/hs_ncm_cfg.xml"
  }, {
   "start": 3569,
   "audio": 0,
   "end": 5044,
   "filename": "/config/factorydomain/hs_msm_cfg.xml"
  }, {
   "start": 5044,
   "audio": 0,
   "end": 7082,
   "filename": "/config/factorydomain/config/hs_voip_india_tones_cfg.txt"
  }, {
   "start": 7082,
   "audio": 0,
   "end": 62740,
   "filename": "/config/factorydomain/config/hs_voip_cfg.txt"
  }, {
   "start": 62740,
   "audio": 0,
   "end": 63026,
   "filename": "/config/factorydomain/config/hs_voip_dns_info_cfg.txt"
  }, {
   "start": 63026,
   "audio": 0,
   "end": 67243,
   "filename": "/config/factorydomain/config/hs_imps_cfg.xml"
  }, {
   "start": 67243,
   "audio": 0,
   "end": 67558,
   "filename": "/config/factorydomain/config/CVS/Entries"
  }, {
   "start": 67558,
   "audio": 0,
   "end": 67620,
   "filename": "/config/factorydomain/config/CVS/Repository"
  }, {
   "start": 67620,
   "audio": 0,
   "end": 67657,
   "filename": "/config/factorydomain/config/CVS/Root"
  }, {
   "start": 67657,
   "audio": 0,
   "end": 67679,
   "filename": "/config/factorydomain/config/CVS/Tag"
  }, {
   "start": 67679,
   "audio": 0,
   "end": 67851,
   "filename": "/config/factorydomain/CVS/Entries"
  }, {
   "start": 67851,
   "audio": 0,
   "end": 67906,
   "filename": "/config/factorydomain/CVS/Repository"
  }, {
   "start": 67906,
   "audio": 0,
   "end": 67943,
   "filename": "/config/factorydomain/CVS/Root"
  }, {
   "start": 67943,
   "audio": 0,
   "end": 67965,
   "filename": "/config/factorydomain/CVS/Tag"
  }, {
   "start": 67965,
   "audio": 0,
   "end": 67983,
   "filename": "/config/factorydomain/Profiles/CVS/Entries"
  }, {
   "start": 67983,
   "audio": 0,
   "end": 68047,
   "filename": "/config/factorydomain/Profiles/CVS/Repository"
  }, {
   "start": 68047,
   "audio": 0,
   "end": 68084,
   "filename": "/config/factorydomain/Profiles/CVS/Root"
  }, {
   "start": 68084,
   "audio": 0,
   "end": 68106,
   "filename": "/config/factorydomain/Profiles/CVS/Tag"
  }, {
   "start": 68106,
   "audio": 0,
   "end": 69779,
   "filename": "/config/factorydomain/Profiles/factoryuser/hs_voip_profile_cfg.txt"
  }, {
   "start": 69779,
   "audio": 0,
   "end": 69808,
   "filename": "/config/factorydomain/Profiles/factoryuser/hs_voip_rej_list_cfg.txt"
  }, {
   "start": 69808,
   "audio": 0,
   "end": 69973,
   "filename": "/config/factorydomain/Profiles/factoryuser/CVS/Entries"
  }, {
   "start": 69973,
   "audio": 0,
   "end": 70049,
   "filename": "/config/factorydomain/Profiles/factoryuser/CVS/Repository"
  }, {
   "start": 70049,
   "audio": 0,
   "end": 70086,
   "filename": "/config/factorydomain/Profiles/factoryuser/CVS/Root"
  }, {
   "start": 70086,
   "audio": 0,
   "end": 70108,
   "filename": "/config/factorydomain/Profiles/factoryuser/CVS/Tag"
  } ],
  "remote_package_size": 70108,
  "package_uuid": "e3436bbf-1d97-4c54-a520-095086b4efd6"
 });
}))();
var moduleOverrides = {};
var key;
for (key in Module) {
 if (Module.hasOwnProperty(key)) {
  moduleOverrides[key] = Module[key];
 }
}
var arguments_ = [];
var thisProgram = "./this.program";
var quit_ = (function(status, toThrow) {
 throw toThrow;
});
var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_HAS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === "object";
ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
ENVIRONMENT_HAS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
if (Module["ENVIRONMENT"]) {
 throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)");
}
var ENVIRONMENT_IS_PTHREAD = Module.ENVIRONMENT_IS_PTHREAD || false;
if (!ENVIRONMENT_IS_PTHREAD) {
 var PthreadWorkerInit = {};
}
var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : undefined;
var scriptDirectory = "";
function locateFile(path) {
 if (Module["locateFile"]) {
  return Module["locateFile"](path, scriptDirectory);
 }
 return scriptDirectory + path;
}
var read_, readAsync, readBinary, setWindowTitle;
if (ENVIRONMENT_IS_NODE) {
 scriptDirectory = __dirname + "/";
 var nodeFS;
 var nodePath;
 read_ = function shell_read(filename, binary) {
  var ret;
  if (!nodeFS) nodeFS = require("fs");
  if (!nodePath) nodePath = require("path");
  filename = nodePath["normalize"](filename);
  ret = nodeFS["readFileSync"](filename);
  return binary ? ret : ret.toString();
 };
 readBinary = function readBinary(filename) {
  var ret = read_(filename, true);
  if (!ret.buffer) {
   ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
 };
 if (process["argv"].length > 1) {
  thisProgram = process["argv"][1].replace(/\\/g, "/");
 }
 arguments_ = process["argv"].slice(2);
 if (typeof module !== "undefined") {
  module["exports"] = Module;
 }
 process["on"]("uncaughtException", (function(ex) {
  if (!(ex instanceof ExitStatus)) {
   throw ex;
  }
 }));
 process["on"]("unhandledRejection", abort);
 quit_ = (function(status) {
  process["exit"](status);
 });
 Module["inspect"] = (function() {
  return "[Emscripten Module object]";
 });
} else if (ENVIRONMENT_IS_SHELL) {
 if (typeof read != "undefined") {
  read_ = function shell_read(f) {
   return read(f);
  };
 }
 readBinary = function readBinary(f) {
  var data;
  if (typeof readbuffer === "function") {
   return new Uint8Array(readbuffer(f));
  }
  data = read(f, "binary");
  assert(typeof data === "object");
  return data;
 };
 if (typeof scriptArgs != "undefined") {
  arguments_ = scriptArgs;
 } else if (typeof arguments != "undefined") {
  arguments_ = arguments;
 }
 if (typeof quit === "function") {
  quit_ = (function(status) {
   quit(status);
  });
 }
 if (typeof print !== "undefined") {
  if (typeof console === "undefined") console = {};
  console.log = print;
  console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
 }
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = self.location.href;
 } else if (document.currentScript) {
  scriptDirectory = document.currentScript.src;
 }
 if (scriptDirectory.indexOf("blob:") !== 0) {
  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
 } else {
  scriptDirectory = "";
 }
 read_ = function shell_read(url) {
  var xhr = new XMLHttpRequest;
  xhr.open("GET", url, false);
  xhr.send(null);
  return xhr.responseText;
 };
 if (ENVIRONMENT_IS_WORKER) {
  readBinary = function readBinary(url) {
   var xhr = new XMLHttpRequest;
   xhr.open("GET", url, false);
   xhr.responseType = "arraybuffer";
   xhr.send(null);
   return new Uint8Array(xhr.response);
  };
 }
 readAsync = function readAsync(url, onload, onerror) {
  var xhr = new XMLHttpRequest;
  xhr.open("GET", url, true);
  xhr.responseType = "arraybuffer";
  xhr.onload = function xhr_onload() {
   if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
    onload(xhr.response);
    return;
   }
   onerror();
  };
  xhr.onerror = onerror;
  xhr.send(null);
 };
 setWindowTitle = (function(title) {
  document.title = title;
 });
} else {
 throw new Error("environment detection error");
}
var out = Module["print"] || console.log.bind(console);
var err = Module["printErr"] || console.warn.bind(console);
for (key in moduleOverrides) {
 if (moduleOverrides.hasOwnProperty(key)) {
  Module[key] = moduleOverrides[key];
 }
}
moduleOverrides = null;
if (Module["arguments"]) arguments_ = Module["arguments"];
if (!Object.getOwnPropertyDescriptor(Module, "arguments")) Object.defineProperty(Module, "arguments", {
 get: (function() {
  abort("Module.arguments has been replaced with plain arguments_");
 })
});
if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
if (!Object.getOwnPropertyDescriptor(Module, "thisProgram")) Object.defineProperty(Module, "thisProgram", {
 get: (function() {
  abort("Module.thisProgram has been replaced with plain thisProgram");
 })
});
if (Module["quit"]) quit_ = Module["quit"];
if (!Object.getOwnPropertyDescriptor(Module, "quit")) Object.defineProperty(Module, "quit", {
 get: (function() {
  abort("Module.quit has been replaced with plain quit_");
 })
});
assert(typeof Module["memoryInitializerPrefixURL"] === "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
assert(typeof Module["pthreadMainPrefixURL"] === "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
assert(typeof Module["cdInitializerPrefixURL"] === "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
assert(typeof Module["filePackagePrefixURL"] === "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
assert(typeof Module["read"] === "undefined", "Module.read option was removed (modify read_ in JS)");
assert(typeof Module["readAsync"] === "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
assert(typeof Module["readBinary"] === "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
assert(typeof Module["setWindowTitle"] === "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
if (!Object.getOwnPropertyDescriptor(Module, "read")) Object.defineProperty(Module, "read", {
 get: (function() {
  abort("Module.read has been replaced with plain read_");
 })
});
if (!Object.getOwnPropertyDescriptor(Module, "readAsync")) Object.defineProperty(Module, "readAsync", {
 get: (function() {
  abort("Module.readAsync has been replaced with plain readAsync");
 })
});
if (!Object.getOwnPropertyDescriptor(Module, "readBinary")) Object.defineProperty(Module, "readBinary", {
 get: (function() {
  abort("Module.readBinary has been replaced with plain readBinary");
 })
});
assert(ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER, "Pthreads do not work in non-browser environments yet (need Web Workers, or an alternative to them)");
var STACK_ALIGN = 16;
stackSave = stackRestore = stackAlloc = (function() {
 abort("cannot use the stack before compiled code is ready to run, and has provided stack access");
});
function staticAlloc(size) {
 abort("staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)");
}
function dynamicAlloc(size) {
 assert(DYNAMICTOP_PTR);
 assert(!ENVIRONMENT_IS_PTHREAD);
 var ret = GROWABLE_HEAP_LOAD_I32(DYNAMICTOP_PTR | 0);
 var end = ret + size + 15 & -16;
 if (end > _emscripten_get_heap_size()) {
  abort("failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly");
 }
 GROWABLE_HEAP_STORE_I32(DYNAMICTOP_PTR | 0, end);
 return ret;
}
function alignMemory(size, factor) {
 if (!factor) factor = STACK_ALIGN;
 return Math.ceil(size / factor) * factor;
}
function getNativeTypeSize(type) {
 switch (type) {
 case "i1":
 case "i8":
  return 1;
 case "i16":
  return 2;
 case "i32":
  return 4;
 case "i64":
  return 8;
 case "float":
  return 4;
 case "double":
  return 8;
 default:
  {
   if (type[type.length - 1] === "*") {
    return 4;
   } else if (type[0] === "i") {
    var bits = parseInt(type.substr(1));
    assert(bits % 8 === 0, "getNativeTypeSize invalid bits " + bits + ", type " + type);
    return bits / 8;
   } else {
    return 0;
   }
  }
 }
}
function warnOnce(text) {
 if (!warnOnce.shown) warnOnce.shown = {};
 if (!warnOnce.shown[text]) {
  warnOnce.shown[text] = 1;
  err(text);
 }
}
var asm2wasmImports = {
 "f64-rem": (function(x, y) {
  return x % y;
 }),
 "debugger": (function() {
  debugger;
 })
};
var jsCallStartIndex = 1;
var functionPointers = new Array(0);
function convertJsFunctionToWasm(func, sig) {
 var typeSection = [ 1, 0, 1, 96 ];
 var sigRet = sig.slice(0, 1);
 var sigParam = sig.slice(1);
 var typeCodes = {
  "i": 127,
  "j": 126,
  "f": 125,
  "d": 124
 };
 typeSection.push(sigParam.length);
 for (var i = 0; i < sigParam.length; ++i) {
  typeSection.push(typeCodes[sigParam[i]]);
 }
 if (sigRet == "v") {
  typeSection.push(0);
 } else {
  typeSection = typeSection.concat([ 1, typeCodes[sigRet] ]);
 }
 typeSection[1] = typeSection.length - 2;
 var bytes = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0 ].concat(typeSection, [ 2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0 ]));
 var module = new WebAssembly.Module(bytes);
 var instance = new WebAssembly.Instance(module, {
  e: {
   f: func
  }
 });
 var wrappedFunc = instance.exports.f;
 return wrappedFunc;
}
function addFunctionWasm(func, sig) {
 var table = wasmTable;
 var ret = table.length;
 try {
  table.grow(1);
 } catch (err) {
  if (!err instanceof RangeError) {
   throw err;
  }
  throw "Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.";
 }
 try {
  table.set(ret, func);
 } catch (err) {
  if (!err instanceof TypeError) {
   throw err;
  }
  assert(typeof sig !== "undefined", "Missing signature argument to addFunction");
  var wrapped = convertJsFunctionToWasm(func, sig);
  table.set(ret, wrapped);
 }
 return ret;
}
function removeFunctionWasm(index) {}
function addFunction(func, sig) {
 if (typeof sig === "undefined") {
  err("warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but can be required for the LLVM wasm backend, so it is recommended for full portability.");
 }
 var base = 0;
 for (var i = base; i < base + 0; i++) {
  if (!functionPointers[i]) {
   functionPointers[i] = func;
   return jsCallStartIndex + i;
  }
 }
 throw "Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.";
}
function removeFunction(index) {
 functionPointers[index - jsCallStartIndex] = null;
}
var funcWrappers = {};
function getFuncWrapper(func, sig) {
 if (!func) return;
 assert(sig);
 if (!funcWrappers[sig]) {
  funcWrappers[sig] = {};
 }
 var sigCache = funcWrappers[sig];
 if (!sigCache[func]) {
  if (sig.length === 1) {
   sigCache[func] = function dynCall_wrapper() {
    return dynCall(sig, func);
   };
  } else if (sig.length === 2) {
   sigCache[func] = function dynCall_wrapper(arg) {
    return dynCall(sig, func, [ arg ]);
   };
  } else {
   sigCache[func] = function dynCall_wrapper() {
    return dynCall(sig, func, Array.prototype.slice.call(arguments));
   };
  }
 }
 return sigCache[func];
}
function makeBigInt(low, high, unsigned) {
 return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296 : +(low >>> 0) + +(high | 0) * 4294967296;
}
function dynCall(sig, ptr, args) {
 if (args && args.length) {
  assert(args.length == sig.length - 1);
  assert("dynCall_" + sig in Module, "bad function pointer type - no table for sig '" + sig + "'");
  return Module["dynCall_" + sig].apply(null, [ ptr ].concat(args));
 } else {
  assert(sig.length == 1);
  assert("dynCall_" + sig in Module, "bad function pointer type - no table for sig '" + sig + "'");
  return Module["dynCall_" + sig].call(null, ptr);
 }
}
var tempRet0 = 0;
var setTempRet0 = (function(value) {
 tempRet0 = value;
});
var getTempRet0 = (function() {
 return tempRet0;
});
function getCompilerSetting(name) {
 throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work";
}
var Runtime = {
 getTempRet0: (function() {
  abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
 }),
 staticAlloc: (function() {
  abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
 }),
 stackAlloc: (function() {
  abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."');
 })
};
var GLOBAL_BASE = 1024;
var wasmBinary;
if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
if (!Object.getOwnPropertyDescriptor(Module, "wasmBinary")) Object.defineProperty(Module, "wasmBinary", {
 get: (function() {
  abort("Module.wasmBinary has been replaced with plain wasmBinary");
 })
});
if (typeof WebAssembly !== "object") {
 abort("No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.");
}
function setValue(ptr, value, type, noSafe) {
 type = type || "i8";
 if (type.charAt(type.length - 1) === "*") type = "i32";
 switch (type) {
 case "i1":
  GROWABLE_HEAP_STORE_I8(ptr >> 0 | 0, value);
  break;
 case "i8":
  GROWABLE_HEAP_STORE_I8(ptr >> 0 | 0, value);
  break;
 case "i16":
  GROWABLE_HEAP_STORE_I16(ptr | 0, value);
  break;
 case "i32":
  GROWABLE_HEAP_STORE_I32(ptr | 0, value);
  break;
 case "i64":
  tempI64 = [ value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], GROWABLE_HEAP_STORE_I32(ptr | 0, tempI64[0]), GROWABLE_HEAP_STORE_I32(ptr + 4 | 0, tempI64[1]);
  break;
 case "float":
  GROWABLE_HEAP_STORE_F32(ptr | 0, value);
  break;
 case "double":
  GROWABLE_HEAP_STORE_F64(ptr | 0, value);
  break;
 default:
  abort("invalid type for setValue: " + type);
 }
}
function getValue(ptr, type, noSafe) {
 type = type || "i8";
 if (type.charAt(type.length - 1) === "*") type = "i32";
 switch (type) {
 case "i1":
  return GROWABLE_HEAP_LOAD_I8(ptr >> 0 | 0);
 case "i8":
  return GROWABLE_HEAP_LOAD_I8(ptr >> 0 | 0);
 case "i16":
  return GROWABLE_HEAP_LOAD_I16(ptr | 0);
 case "i32":
  return GROWABLE_HEAP_LOAD_I32(ptr | 0);
 case "i64":
  return GROWABLE_HEAP_LOAD_I32(ptr | 0);
 case "float":
  return GROWABLE_HEAP_LOAD_F32(ptr | 0);
 case "double":
  return GROWABLE_HEAP_LOAD_F64(ptr | 0);
 default:
  abort("invalid type for getValue: " + type);
 }
 return null;
}
var wasmMemory;
var wasmTable;
var wasmModule;
var ABORT = false;
var EXITSTATUS = 0;
function assert(condition, text) {
 if (!condition) {
  abort("Assertion failed: " + text);
 }
}
function getCFunc(ident) {
 var func = Module["_" + ident];
 assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
 return func;
}
function ccall(ident, returnType, argTypes, args, opts) {
 var toC = {
  "string": (function(str) {
   var ret = 0;
   if (str !== null && str !== undefined && str !== 0) {
    var len = (str.length << 2) + 1;
    ret = stackAlloc(len);
    stringToUTF8(str, ret, len);
   }
   return ret;
  }),
  "array": (function(arr) {
   var ret = stackAlloc(arr.length);
   writeArrayToMemory(arr, ret);
   return ret;
  })
 };
 function convertReturnValue(ret) {
  if (returnType === "string") return UTF8ToString(ret);
  if (returnType === "boolean") return Boolean(ret);
  return ret;
 }
 var func = getCFunc(ident);
 var cArgs = [];
 var stack = 0;
 assert(returnType !== "array", 'Return type should not be "array".');
 if (args) {
  for (var i = 0; i < args.length; i++) {
   var converter = toC[argTypes[i]];
   if (converter) {
    if (stack === 0) stack = stackSave();
    cArgs[i] = converter(args[i]);
   } else {
    cArgs[i] = args[i];
   }
  }
 }
 var ret = func.apply(null, cArgs);
 assert(!(opts && opts.async), "async call is only supported with Emterpretify for now, see #9029");
 ret = convertReturnValue(ret);
 if (stack !== 0) stackRestore(stack);
 return ret;
}
function cwrap(ident, returnType, argTypes, opts) {
 return (function() {
  return ccall(ident, returnType, argTypes, arguments, opts);
 });
}
var ALLOC_NORMAL = 0;
var ALLOC_STACK = 1;
var ALLOC_DYNAMIC = 2;
var ALLOC_NONE = 3;
function allocate(slab, types, allocator, ptr) {
 var zeroinit, size;
 if (typeof slab === "number") {
  zeroinit = true;
  size = slab;
 } else {
  zeroinit = false;
  size = slab.length;
 }
 var singleType = typeof types === "string" ? types : null;
 var ret;
 if (allocator == ALLOC_NONE) {
  ret = ptr;
 } else {
  ret = [ _malloc, stackAlloc, dynamicAlloc ][allocator](Math.max(size, singleType ? 1 : types.length));
 }
 if (zeroinit) {
  var stop;
  ptr = ret;
  assert((ret & 3) == 0);
  stop = ret + (size & ~3);
  for (; ptr < stop; ptr += 4) {
   GROWABLE_HEAP_STORE_I32(ptr | 0, 0);
  }
  stop = ret + size;
  while (ptr < stop) {
   GROWABLE_HEAP_STORE_I8(ptr++ >> 0 | 0, 0);
  }
  return ret;
 }
 if (singleType === "i8") {
  if (slab.subarray || slab.slice) {
   HEAPU8.set(slab, ret);
  } else {
   HEAPU8.set(new Uint8Array(slab), ret);
  }
  return ret;
 }
 var i = 0, type, typeSize, previousType;
 while (i < size) {
  var curr = slab[i];
  type = singleType || types[i];
  if (type === 0) {
   i++;
   continue;
  }
  assert(type, "Must know what type to store in allocate!");
  if (type == "i64") type = "i32";
  setValue(ret + i, curr, type);
  if (previousType !== type) {
   typeSize = getNativeTypeSize(type);
   previousType = type;
  }
  i += typeSize;
 }
 return ret;
}
function getMemory(size) {
 if (!runtimeInitialized) return dynamicAlloc(size);
 return _malloc(size);
}
function Pointer_stringify(ptr, length) {
 abort("this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!");
}
function AsciiToString(ptr) {
 var str = "";
 while (1) {
  var ch = GROWABLE_HEAP_LOAD_U8(ptr++ >> 0 | 0);
  if (!ch) return str;
  str += String.fromCharCode(ch);
 }
}
function stringToAscii(str, outPtr) {
 return writeAsciiToMemory(str, outPtr, false);
}
function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
 var endIdx = idx + maxBytesToRead;
 var str = "";
 while (!(idx >= endIdx)) {
  var u0 = u8Array[idx++];
  if (!u0) return str;
  if (!(u0 & 128)) {
   str += String.fromCharCode(u0);
   continue;
  }
  var u1 = u8Array[idx++] & 63;
  if ((u0 & 224) == 192) {
   str += String.fromCharCode((u0 & 31) << 6 | u1);
   continue;
  }
  var u2 = u8Array[idx++] & 63;
  if ((u0 & 240) == 224) {
   u0 = (u0 & 15) << 12 | u1 << 6 | u2;
  } else {
   if ((u0 & 248) != 240) warnOnce("Invalid UTF-8 leading byte 0x" + u0.toString(16) + " encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!");
   u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
  }
  if (u0 < 65536) {
   str += String.fromCharCode(u0);
  } else {
   var ch = u0 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  }
 }
 return str;
}
function UTF8ToString(ptr, maxBytesToRead) {
 return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) {
   var u1 = str.charCodeAt(++i);
   u = 65536 + ((u & 1023) << 10) | u1 & 1023;
  }
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   outU8Array[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   outU8Array[outIdx++] = 192 | u >> 6;
   outU8Array[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   outU8Array[outIdx++] = 224 | u >> 12;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 3 >= endIdx) break;
   if (u >= 2097152) warnOnce("Invalid Unicode code point 0x" + u.toString(16) + " encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).");
   outU8Array[outIdx++] = 240 | u >> 18;
   outU8Array[outIdx++] = 128 | u >> 12 & 63;
   outU8Array[outIdx++] = 128 | u >> 6 & 63;
   outU8Array[outIdx++] = 128 | u & 63;
  }
 }
 outU8Array[outIdx] = 0;
 return outIdx - startIdx;
}
function stringToUTF8(str, outPtr, maxBytesToWrite) {
 assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}
function lengthBytesUTF8(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;
 }
 return len;
}
function UTF16ToString(ptr) {
 assert(ptr % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");
 var i = 0;
 var str = "";
 while (1) {
  var codeUnit = GROWABLE_HEAP_LOAD_I16(ptr + i * 2 | 0);
  if (codeUnit == 0) return str;
  ++i;
  str += String.fromCharCode(codeUnit);
 }
}
function stringToUTF16(str, outPtr, maxBytesToWrite) {
 assert(outPtr % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!");
 assert(typeof maxBytesToWrite == "number", "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 2) return 0;
 maxBytesToWrite -= 2;
 var startPtr = outPtr;
 var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
 for (var i = 0; i < numCharsToWrite; ++i) {
  var codeUnit = str.charCodeAt(i);
  GROWABLE_HEAP_STORE_I16(outPtr | 0, codeUnit);
  outPtr += 2;
 }
 GROWABLE_HEAP_STORE_I16(outPtr | 0, 0);
 return outPtr - startPtr;
}
function lengthBytesUTF16(str) {
 return str.length * 2;
}
function UTF32ToString(ptr) {
 assert(ptr % 4 == 0, "Pointer passed to UTF32ToString must be aligned to four bytes!");
 var i = 0;
 var str = "";
 while (1) {
  var utf32 = GROWABLE_HEAP_LOAD_I32(ptr + i * 4 | 0);
  if (utf32 == 0) return str;
  ++i;
  if (utf32 >= 65536) {
   var ch = utf32 - 65536;
   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
  } else {
   str += String.fromCharCode(utf32);
  }
 }
}
function stringToUTF32(str, outPtr, maxBytesToWrite) {
 assert(outPtr % 4 == 0, "Pointer passed to stringToUTF32 must be aligned to four bytes!");
 assert(typeof maxBytesToWrite == "number", "stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
 if (maxBytesToWrite === undefined) {
  maxBytesToWrite = 2147483647;
 }
 if (maxBytesToWrite < 4) return 0;
 var startPtr = outPtr;
 var endPtr = startPtr + maxBytesToWrite - 4;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) {
   var trailSurrogate = str.charCodeAt(++i);
   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
  }
  GROWABLE_HEAP_STORE_I32(outPtr | 0, codeUnit);
  outPtr += 4;
  if (outPtr + 4 > endPtr) break;
 }
 GROWABLE_HEAP_STORE_I32(outPtr | 0, 0);
 return outPtr - startPtr;
}
function lengthBytesUTF32(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var codeUnit = str.charCodeAt(i);
  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;
  len += 4;
 }
 return len;
}
function allocateUTF8(str) {
 var size = lengthBytesUTF8(str) + 1;
 var ret = _malloc(size);
 if (ret) stringToUTF8Array(str, HEAP8, ret, size);
 return ret;
}
function allocateUTF8OnStack(str) {
 var size = lengthBytesUTF8(str) + 1;
 var ret = stackAlloc(size);
 stringToUTF8Array(str, HEAP8, ret, size);
 return ret;
}
function writeStringToMemory(string, buffer, dontAddNull) {
 warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");
 var lastChar, end;
 if (dontAddNull) {
  end = buffer + lengthBytesUTF8(string);
  lastChar = GROWABLE_HEAP_LOAD_I8(end | 0);
 }
 stringToUTF8(string, buffer, Infinity);
 if (dontAddNull) GROWABLE_HEAP_STORE_I8(end | 0, lastChar);
}
function writeArrayToMemory(array, buffer) {
 assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
 HEAP8.set(array, buffer);
}
function writeAsciiToMemory(str, buffer, dontAddNull) {
 for (var i = 0; i < str.length; ++i) {
  assert(str.charCodeAt(i) === str.charCodeAt(i) & 255);
  GROWABLE_HEAP_STORE_I8(buffer++ >> 0 | 0, str.charCodeAt(i));
 }
 if (!dontAddNull) GROWABLE_HEAP_STORE_I8(buffer >> 0 | 0, 0);
}
var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;
function alignUp(x, multiple) {
 if (x % multiple > 0) {
  x += multiple - x % multiple;
 }
 return x;
}
var HEAP, buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
function updateGlobalBufferViews() {
 Module["HEAP8"] = HEAP8 = new Int8Array(buffer);
 Module["HEAP16"] = HEAP16 = new Int16Array(buffer);
 Module["HEAP32"] = HEAP32 = new Int32Array(buffer);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer);
}
if (!ENVIRONMENT_IS_PTHREAD) {
 var STATIC_BASE = 1024, STACK_BASE = 663152, STACKTOP = STACK_BASE, STACK_MAX = 5906032, DYNAMIC_BASE = 5906032, DYNAMICTOP_PTR = 663120;
 assert(STACK_BASE % 16 === 0, "stack must start aligned");
 assert(DYNAMIC_BASE % 16 === 0, "heap must start aligned");
}
var TOTAL_STACK = 5242880;
if (Module["TOTAL_STACK"]) assert(TOTAL_STACK === Module["TOTAL_STACK"], "the stack size can no longer be determined at runtime");
var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 16777216;
if (!Object.getOwnPropertyDescriptor(Module, "TOTAL_MEMORY")) Object.defineProperty(Module, "TOTAL_MEMORY", {
 get: (function() {
  abort("Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY");
 })
});
assert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, "TOTAL_MEMORY should be larger than TOTAL_STACK, was " + INITIAL_TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");
assert(typeof Int32Array !== "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, "JS engine does not provide full typed array support");
if (ENVIRONMENT_IS_PTHREAD) {} else {
 if (Module["wasmMemory"]) {
  wasmMemory = Module["wasmMemory"];
 } else {
  wasmMemory = new WebAssembly.Memory({
   "initial": INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE,
   "maximum": 1048576e3 / WASM_PAGE_SIZE,
   "shared": true
  });
  assert(wasmMemory.buffer instanceof SharedArrayBuffer, "requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
 }
}
if (wasmMemory) {
 buffer = wasmMemory.buffer;
}
INITIAL_TOTAL_MEMORY = buffer.byteLength;
assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
assert(65536 % WASM_PAGE_SIZE === 0);
updateGlobalBufferViews();
if (!ENVIRONMENT_IS_PTHREAD) {
 GROWABLE_HEAP_STORE_I32(DYNAMICTOP_PTR | 0, DYNAMIC_BASE);
}
function writeStackCookie() {
 assert((STACK_MAX & 3) == 0);
 GROWABLE_HEAP_STORE_I32(((STACK_MAX >> 2) - 1) * 4 | 0, 34821223);
 GROWABLE_HEAP_STORE_I32(((STACK_MAX >> 2) - 2) * 4 | 0, 2310721022);
}
function checkStackCookie() {
 var cookie1 = GROWABLE_HEAP_LOAD_U32(((STACK_MAX >> 2) - 1) * 4 | 0);
 var cookie2 = GROWABLE_HEAP_LOAD_U32(((STACK_MAX >> 2) - 2) * 4 | 0);
 if (cookie1 != 34821223 || cookie2 != 2310721022) {
  abort("Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x" + cookie2.toString(16) + " " + cookie1.toString(16));
 }
 if (GROWABLE_HEAP_LOAD_I32(0 * 4 | 0) !== 1668509029) abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
}
function abortStackOverflow(allocSize) {
 abort("Stack overflow! Attempted to allocate " + allocSize + " bytes on the stack, but stack has only " + (STACK_MAX - stackSave() + allocSize) + " bytes available!");
}
if (!ENVIRONMENT_IS_PTHREAD) {
 GROWABLE_HEAP_STORE_I32(0 * 4 | 0, 1668509029);
} else {
 if (GROWABLE_HEAP_LOAD_I32(0 * 4 | 0) !== 1668509029) abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
}
GROWABLE_HEAP_STORE_I16(1 * 2 | 0, 25459);
if (GROWABLE_HEAP_LOAD_U8(2 | 0) !== 115 || GROWABLE_HEAP_LOAD_U8(3 | 0) !== 99) throw "Runtime error: expected the system to be little-endian!";
function abortFnPtrError(ptr, sig) {
 var possibleSig = "";
 for (var x in debug_tables) {
  var tbl = debug_tables[x];
  if (tbl[ptr]) {
   possibleSig += 'as sig "' + x + '" pointing to function ' + tbl[ptr] + ", ";
  }
 }
 abort("Invalid function pointer " + ptr + " called with signature '" + sig + "'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). This pointer might make sense in another type signature: " + possibleSig);
}
function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  var callback = callbacks.shift();
  if (typeof callback == "function") {
   callback();
   continue;
  }
  var func = callback.func;
  if (typeof func === "number") {
   if (callback.arg === undefined) {
    Module["dynCall_v"](func);
   } else {
    Module["dynCall_vi"](func, callback.arg);
   }
  } else {
   func(callback.arg === undefined ? null : callback.arg);
  }
 }
}
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATMAIN__ = [];
var __ATEXIT__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = false;
var runtimeExited = false;
if (ENVIRONMENT_IS_PTHREAD) runtimeInitialized = true;
function preRun() {
 if (ENVIRONMENT_IS_PTHREAD) return;
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}
function initRuntime() {
 checkStackCookie();
 assert(!runtimeInitialized);
 runtimeInitialized = true;
 if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
 TTY.init();
 SOCKFS.root = FS.mount(SOCKFS, {}, null);
 callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
 checkStackCookie();
 if (ENVIRONMENT_IS_PTHREAD) return;
 FS.ignorePermissions = false;
 callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
 checkStackCookie();
 if (ENVIRONMENT_IS_PTHREAD) return;
 runtimeExited = true;
}
function postRun() {
 checkStackCookie();
 if (ENVIRONMENT_IS_PTHREAD) return;
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}
function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}
function addOnInit(cb) {
 __ATINIT__.unshift(cb);
}
function addOnPreMain(cb) {
 __ATMAIN__.unshift(cb);
}
function addOnExit(cb) {}
function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}
function unSign(value, bits, ignore) {
 if (value >= 0) {
  return value;
 }
 return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value : Math.pow(2, bits) + value;
}
function reSign(value, bits, ignore) {
 if (value <= 0) {
  return value;
 }
 var half = bits <= 32 ? Math.abs(1 << bits - 1) : Math.pow(2, bits - 1);
 if (value >= half && (bits <= 32 || value > half)) {
  value = -2 * half + value;
 }
 return value;
}
assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;
var runDependencyTracking = {};
function getUniqueRunDependency(id) {
 var orig = id;
 while (1) {
  if (!runDependencyTracking[id]) return id;
  id = orig + Math.random();
 }
 return id;
}
function addRunDependency(id) {
 assert(!ENVIRONMENT_IS_PTHREAD, "addRunDependency cannot be used in a pthread worker");
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (id) {
  assert(!runDependencyTracking[id]);
  runDependencyTracking[id] = 1;
  if (runDependencyWatcher === null && typeof setInterval !== "undefined") {
   runDependencyWatcher = setInterval((function() {
    if (ABORT) {
     clearInterval(runDependencyWatcher);
     runDependencyWatcher = null;
     return;
    }
    var shown = false;
    for (var dep in runDependencyTracking) {
     if (!shown) {
      shown = true;
      err("still waiting on run dependencies:");
     }
     err("dependency: " + dep);
    }
    if (shown) {
     err("(end of list)");
    }
   }), 1e4);
  }
 } else {
  err("warning: run dependency added without ID");
 }
}
function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (id) {
  assert(runDependencyTracking[id]);
  delete runDependencyTracking[id];
 } else {
  err("warning: run dependency removed without ID");
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}
Module["preloadedImages"] = {};
Module["preloadedAudios"] = {};
var memoryInitializer = null;
var dataURIPrefix = "data:application/octet-stream;base64,";
function isDataURI(filename) {
 return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
}
var wasmBinaryFile = "hsimsweb.wasm";
if (!isDataURI(wasmBinaryFile)) {
 wasmBinaryFile = locateFile(wasmBinaryFile);
}
function getBinary() {
 try {
  if (wasmBinary) {
   return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
   return readBinary(wasmBinaryFile);
  } else {
   throw "both async and sync fetching of the wasm failed";
  }
 } catch (err) {
  abort(err);
 }
}
function getBinaryPromise() {
 if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
  return fetch(wasmBinaryFile, {
   credentials: "same-origin"
  }).then((function(response) {
   if (!response["ok"]) {
    throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
   }
   return response["arrayBuffer"]();
  })).catch((function() {
   return getBinary();
  }));
 }
 return new Promise((function(resolve, reject) {
  resolve(getBinary());
 }));
}
function createWasm(env) {
 var info = {
  "env": env,
  "global": {
   "NaN": NaN,
   "Infinity": Infinity
  },
  "global.Math": Math,
  "asm2wasm": asm2wasmImports
 };
 function receiveInstance(instance, module) {
  var exports = instance.exports;
  Module["asm"] = exports;
  wasmModule = module;
  if (!ENVIRONMENT_IS_PTHREAD) removeRunDependency("wasm-instantiate");
 }
 if (!ENVIRONMENT_IS_PTHREAD) {
  addRunDependency("wasm-instantiate");
 }
 var trueModule = Module;
 function receiveInstantiatedSource(output) {
  assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
  trueModule = null;
  receiveInstance(output["instance"], output["module"]);
 }
 function instantiateArrayBuffer(receiver) {
  return getBinaryPromise().then((function(binary) {
   return WebAssembly.instantiate(binary, info);
  })).then(receiver, (function(reason) {
   err("failed to asynchronously prepare wasm: " + reason);
   abort(reason);
  }));
 }
 function instantiateAsync() {
  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
   fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then((function(response) {
    var result = WebAssembly.instantiateStreaming(response, info);
    return result.then(receiveInstantiatedSource, (function(reason) {
     err("wasm streaming compile failed: " + reason);
     err("falling back to ArrayBuffer instantiation");
     instantiateArrayBuffer(receiveInstantiatedSource);
    }));
   }));
  } else {
   return instantiateArrayBuffer(receiveInstantiatedSource);
  }
 }
 if (Module["instantiateWasm"]) {
  try {
   var exports = Module["instantiateWasm"](info, receiveInstance);
   return exports;
  } catch (e) {
   err("Module.instantiateWasm callback failed with error: " + e);
   return false;
  }
 }
 instantiateAsync();
 return {};
}
Module["asm"] = (function(global, env, providedBuffer) {
 env["memory"] = wasmMemory;
 env["table"] = wasmTable = new WebAssembly.Table({
  "initial": 19728,
  "maximum": 19728,
  "element": "anyfunc"
 });
 env["__memory_base"] = 1024;
 env["__table_base"] = 0;
 var exports = createWasm(env);
 assert(exports, "binaryen setup failed (no wasm support?)");
 return exports;
});
var tempDouble;
var tempI64;
var ASM_CONSTS = [ (function($0, $1, $2) {
 _CallSessionNotifyHandlerWrapper($0, $1, $2);
}), (function($0, $1, $2, $3) {
 _CallSessionNotifyHandlerWrapper1($0, $1, $2, $3);
}), (function($0, $1, $2, $3, $4) {
 _CallManagerNotificationHandlerWrapper($0, $1, $2, $3, $4);
}), (function($0, $1, $2, $3, $4) {
 _SystemManagerNotificationHandlerWrapper($0, $1, $2, $3, $4);
}), (function() {
 Module["websocket"]["url"] = "wss://";
}), (function() {
 Module["websocket"]["subprotocol"] = "sip";
}), (function() {
 Module["websocket"]["subprotocol"] = "msrp";
}), (function() {
 Module["websocket"]["subprotocol"] = "text";
}), (function($0, $1, $2) {
 _setRemoteDescriptionWrapper($0, $1, $2);
}), (function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 _createPeerConnectionWrapper($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
}), (function($0, $1, $2) {
 _modifyMediaStreamWrapper($0, $1, $2);
}), (function($0, $1) {
 _receivingRemoteIceWrapper($0, $1);
}), (function($0) {
 _closePeerConnectionWrapper($0);
}), (function() {
 console.error("fetch: emscripten_fetch_wait failed: main thread cannot block to wait for long periods of time! Migrate the application to run in a worker to perform synchronous file IO, or switch to using asynchronous IO.");
}), (function() {
 postMessage({
  cmd: "processQueuedMainThreadWork"
 });
}), (function($0) {
 if (!ENVIRONMENT_IS_PTHREAD) {
  if (!PThread.pthreads[$0] || !PThread.pthreads[$0].worker) {
   return 0;
  }
  PThread.pthreads[$0].worker.postMessage({
   cmd: "processThreadQueue"
  });
 } else {
  postMessage({
   targetThread: $0,
   cmd: "processThreadQueue"
  });
 }
 return 1;
}), (function() {
 return !!Module["canvas"];
}), (function() {
 Module["noExitRuntime"] = true;
}), (function() {
 throw "Canceled!";
}) ];
function _emscripten_asm_const_i(code) {
 return ASM_CONSTS[code]();
}
function _emscripten_asm_const_sync_on_main_thread_iiiiii(code, a0, a1, a2, a3, a4) {
 if (ENVIRONMENT_IS_PTHREAD) {
  return _emscripten_proxy_to_main_thread_js(-1 - code, 1, a0, a1, a2, a3, a4);
 }
 return ASM_CONSTS[code](a0, a1, a2, a3, a4);
}
function _emscripten_asm_const_sync_on_main_thread_iiii(code, a0, a1, a2) {
 if (ENVIRONMENT_IS_PTHREAD) {
  return _emscripten_proxy_to_main_thread_js(-1 - code, 1, a0, a1, a2);
 }
 return ASM_CONSTS[code](a0, a1, a2);
}
function _emscripten_asm_const_sync_on_main_thread_iiiii(code, a0, a1, a2, a3) {
 if (ENVIRONMENT_IS_PTHREAD) {
  return _emscripten_proxy_to_main_thread_js(-1 - code, 1, a0, a1, a2, a3);
 }
 return ASM_CONSTS[code](a0, a1, a2, a3);
}
function _emscripten_asm_const_sync_on_main_thread_ii(code, a0) {
 if (ENVIRONMENT_IS_PTHREAD) {
  return _emscripten_proxy_to_main_thread_js(-1 - code, 1, a0);
 }
 return ASM_CONSTS[code](a0);
}
function _emscripten_asm_const_sync_on_main_thread_iiiiiiiiiii(code, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
 if (ENVIRONMENT_IS_PTHREAD) {
  return _emscripten_proxy_to_main_thread_js(-1 - code, 1, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
 }
 return ASM_CONSTS[code](a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
}
function _emscripten_asm_const_sync_on_main_thread_iii(code, a0, a1) {
 if (ENVIRONMENT_IS_PTHREAD) {
  return _emscripten_proxy_to_main_thread_js(-1 - code, 1, a0, a1);
 }
 return ASM_CONSTS[code](a0, a1);
}
function _emscripten_asm_const_ii(code, a0) {
 return ASM_CONSTS[code](a0);
}
function _CallManagerNotificationHandlerWrapper(type, enumvalue, callId, uri, displayName) {
 var out_obj = {
  type: type,
  data: {}
 };
 const callmgrNotificationObject = {
  INCOMING_CALL: 0,
  CALL_ENDED: 1,
  SWITCH_CALL_SUCCESS: 2,
  SWITCH_CALL_FAILED: 3,
  INCOMING_CALL_REDIRECTED: 4,
  INCOMING_CALL_REJECTED: 5,
  CONFERENCE_CALL: 6,
  VOICE_MESSAGE_WAIT: 7
 };
 out_obj.type = type;
 console.log("DEBUGGGG: WASMIF CALL MANAGER NOTIFY : EMJS", out_obj.type);
 console.log("\n");
 switch (type) {
 case callmgrNotificationObject.INCOMING_CALL:
  {
   out_obj.data.eCallMode = enumvalue;
   out_obj.data.remoteUri = Module.UTF8ToString(uri);
   out_obj.data.remoteDisplayName = Module.UTF8ToString(displayName);
   out_obj.data.callId = GROWABLE_HEAP_LOAD_U32(callId | 0);
   break;
  }
 case callmgrNotificationObject.CALL_ENDED:
  {
   out_obj.data.callId = callId;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callmgrNotificationObject.SWITCH_CALL_SUCCESS:
  {
   out_obj.data = {};
   break;
  }
 case callmgrNotificationObject.SWITCH_CALL_FAILED:
  {
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callmgrNotificationObject.INCOMING_CALL_REDIRECTED:
  {
   out_obj.data = {};
   out_obj.data.remoteUri = Module.UTF8ToString(uri);
   out_obj.data.remoteDisplayName = Module.UTF8ToString(displayName);
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callmgrNotificationObject.INCOMING_CALL_REJECTED:
  {
   out_obj.data = {};
   out_obj.data.remoteUri = Module.UTF8ToString(uri);
   out_obj.data.remoteDisplayName = Module.UTF8ToString(displayName);
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callmgrNotificationObject.CONFERENCE_CALL:
  {
   out_obj.data = {};
   break;
  }
 case callmgrNotificationObject.VOICE_MESSAGE_WAIT:
  {
   out_obj.data = {};
   break;
  }
 }
 if (window.ME) window.ME.CallManagerNotification(out_obj); else console.log("ERROR>> Couldn't find window.ME object");
}
function _CallSessionNotifyHandlerWrapper(type, enumvalue, callId) {
 var out_obj = {
  type: type,
  data: {}
 };
 out_obj.type = type;
 console.log("DEBUGGGG: WASMIF SESSION NOTIFY : EMJS ", out_obj.type);
 console.log("\n");
 const callSessionNotificationObject = {
  CALL_PROGRESS: 0,
  CALL_ANSWER_FAILED: 1,
  CALL_END_FAILED: 2,
  CALL_ENDED: 3,
  REMOTE_HOLD: 4,
  IS_ON_LOCAL_HOLD: 5,
  IS_ON_MUTE: 6,
  CALL_REPLACED: 7,
  CALL_REPLACE_FAILURE: 8,
  CALL_FORWARD_REQUEST: 9,
  CALL_FORWARDED: 10,
  START_VIDEO_REQUEST: 11,
  START_VIDEO_SUCCESS: 12,
  START_VIDEO_FAILED: 13,
  STOP_VIDEO_SUCCESS: 14,
  STOP_VIDEO_FAILED: 15
 };
 switch (type) {
 case callSessionNotificationObject.CALL_PROGRESS:
  {
   out_obj.data.eCallState = enumvalue;
   break;
  }
 case callSessionNotificationObject.CALL_ANSWER_FAILED:
  {
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.CALL_END_FAILED:
  {
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.CALL_ENDED:
  {
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.CALL_REPLACED:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.CALL_REPLACE_FAILURE:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.CALL_FORWARD_REQUEST:
  {
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.CALL_FORWARDED:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.START_VIDEO_REQUEST:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.START_VIDEO_SUCCESS:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.START_VIDEO_FAILED:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.STOP_VIDEO_REQUEST:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.STOP_VIDEO_SUCCESS:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 case callSessionNotificationObject.STOP_VIDEO_FAILED:
  {
   out_obj.data = {};
   out_obj.data.eCallState = enumvalue;
   out_obj.data.eCallReasonCode = enumvalue;
   break;
  }
 }
 if (window.ME) window.ME.CallSessionNotification(out_obj); else console.log("ERROR>> Couldn't find window.ME object");
}
function _CallSessionNotifyHandlerWrapper1(type, enumvalue, reason) {
 var out_obj = {
  type: type,
  data: {}
 };
 out_obj.type = type;
 const callSessionNotificationObject = {
  CALL_PROGRESS: 0,
  CALL_ANSWER_FAILED: 1,
  CALL_END_FAILED: 2,
  CALL_ENDED: 3,
  REMOTE_HOLD: 4,
  IS_ON_LOCAL_HOLD: 5,
  IS_ON_MUTE: 6,
  CALL_REPLACED: 7,
  CALL_REPLACE_FAILURE: 8,
  CALL_FORWARD_REQUEST: 9,
  CALL_FORWARDED: 10,
  START_VIDEO_REQUEST: 11,
  START_VIDEO_SUCCESS: 12,
  START_VIDEO_FAILED: 13,
  STOP_VIDEO_SUCCESS: 14,
  STOP_VIDEO_FAILED: 15
 };
 console.log("::::: CALL SESSION NOTIFY : EMJS \n");
 switch (type) {
 case callSessionNotificationObject.IS_ON_LOCAL_HOLD:
  {
   out_obj.data.eCallState = reason;
   out_obj.data.isOnLocalHold = enumvalue;
   break;
  }
 case callSessionNotificationObject.IS_ON_MUTE:
  {
   out_obj.data.eCallReasonCode = reason;
   out_obj.data.isOnLocalMute = enumvalue;
   break;
  }
 }
 CallSessionNotification(out_obj);
}
function _CallSessionNotifyHandlerWrapperWasm(integer_value) {
 console.log("integer_value: ", integer_value);
 systemNotifyCallbackWASM(integer_value);
}
function _SystemManagerNotificationHandlerWrapper(type, reasonCode, domain_name, uri, display_name) {
 var output_object = {
  type: type,
  data: {}
 };
 console.log("::::: EM_JS: SYSTEM MANAGER NOTIFY \n");
 output_object.type = type;
 switch (type) {
 case window.ME.SystemNotification.INITIALIZATION_SUCCESS:
  {
   output_object.data.eSystemReasonCode = reasonCode;
   break;
  }
 case window.ME.SystemNotification.INITIALIZATION_FAILED:
  {
   output_object.data.eSystemReasonCode = reasonCode;
   break;
  }
 case window.ME.SystemNotification.DEINITIALIZATION_SUCCESS:
  {
   output_object.data = {};
   break;
  }
 case window.ME.SystemNotification.ON_OTP_SENT:
  {
   output_object.data = {};
   break;
  }
 case window.ME.SystemNotification.OTP_SEND_FAILED:
  {
   output_object.data.eProvisioningReasonCode = reasonCode;
   break;
  }
 case window.ME.SystemNotification.OTP_VERIFICATION_SUCCESS:
  {
   output_object.data.domainName = Module.UTF8ToString(domain_name);
   output_object.data.uid = {};
   output_object.data.uid.displayName = Module.UTF8ToString(display_name);
   output_object.data.uid.uri = Module.UTF8ToString(uri);
   break;
  }
 case window.ME.SystemNotification.OTP_VERIFICATION_FAILED:
  {
   output_object.data.eProvisioningReasonCode = reasonCode;
   break;
  }
 case window.ME.SystemNotification.REGISTRATION_SUCCESS:
  {
   output_object.data = {};
   break;
  }
 case window.ME.SystemNotification.REGISTRATION_FAILED:
  {
   output_object.data.eRegisterReasonCode = reasonCode;
   break;
  }
 case window.ME.SystemNotification.DEREGISTRATION_SUCCESS:
  {
   output_object.data = {};
   break;
  }
 case window.ME.SystemNotification.DEREGISTRATION_FAILED:
  {
   output_object.data.eRegisterReasonCode = reasonCode;
   break;
  }
 case window.ME.SystemNotification.ON_NETWORK_CONNECTED:
  {
   output_object.data.eConnectionType = reasonCode;
   break;
  }
 case window.ME.SystemNotification.ON_NETWORK_DISCONNECTED:
  {
   output_object.data = {};
   break;
  }
 }
 if (window.ME) window.ME.systemManagerNotification(output_object);
}
function _closePeerConnectionWrapper(callId) {
 var lCallId = GROWABLE_HEAP_LOAD_U32(callId | 0);
 console.log("WEBRTC-IF:EMJS : closePeerConnection : " + lCallId);
 if (window.ME) window.ME.closePeerConnection(lCallId);
 return 1;
}
function _createPeerConnectionWrapper(callId, local_aor, isAudio, isVideo, stunIp, stunPort, turnIp, turnPort, turnUser, turnPasswd) {
 var mediaConstraints = {
  audio: isAudio,
  video: isVideo
 };
 var stunAddr = "stun:" + Module.UTF8ToString(stunIp) + ":" + stunPort;
 var turnAddr = "turn:" + Module.UTF8ToString(turnIp) + ":" + turnPort;
 var servers = {
  "iceServers": [ {
   "urls": stunAddr
  }, {
   "urls": turnAddr,
   "username": Module.UTF8ToString(turnUser),
   "credential": Module.UTF8ToString(turnPasswd)
  } ]
 };
 console.log(servers);
 var lCallId = GROWABLE_HEAP_LOAD_U32(callId | 0);
 console.log("WEBRTC-IF:EMJS : createPeerConnection : " + lCallId);
 if (window.ME) window.ME.createPeerConnection(lCallId, mediaConstraints, servers);
 return 1;
}
function _initPthreadsJS() {
 PThread.initRuntime();
}
function _modifyMediaStreamWrapper(callId, audio_mode, video_mode) {
 var lCallId = GROWABLE_HEAP_LOAD_U32(callId | 0);
 console.log("WEBRTC-IF:EMJS : modifyMediaStream :" + lCallId);
 if (window.ME) window.ME.modifyMediaStream(lCallId, audio_mode, video_mode);
 return 1;
}
function _receivingRemoteIceWrapper(callId, ice_p) {
 var ice = Module.UTF8ToString(ice_p);
 console.log(ice);
 var lCallId = GROWABLE_HEAP_LOAD_U32(callId | 0);
 console.log("WEBRTC-IF:EMJS : recieving remote ICE" + lCallId);
 if (window.ME) window.ME.receivingRemoteIce(lCallId, ice);
}
function _setRemoteDescriptionWrapper(callId, sdp_p, isOffer) {
 var sdp = Module.UTF8ToString(sdp_p);
 var lCallId = GROWABLE_HEAP_LOAD_U32(callId | 0);
 console.log("WEBRTC-IF:EMJS : setRemoteDescription" + lCallId);
 if (window.ME) window.ME.setRemoteDescription(lCallId, sdp, isOffer);
 return 1;
}
if (!ENVIRONMENT_IS_PTHREAD) __ATINIT__.push({
 func: (function() {
  globalCtors();
 })
});
if (!ENVIRONMENT_IS_PTHREAD) {
 memoryInitializer = "hsimsweb.js.mem";
}
var tempDoublePtr;
if (!ENVIRONMENT_IS_PTHREAD) tempDoublePtr = 663136;
assert(tempDoublePtr % 8 == 0);
function copyTempFloat(ptr) {
 GROWABLE_HEAP_STORE_I8(tempDoublePtr | 0, GROWABLE_HEAP_LOAD_I8(ptr | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 1 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 1 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 2 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 2 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 3 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 3 | 0));
}
function copyTempDouble(ptr) {
 GROWABLE_HEAP_STORE_I8(tempDoublePtr | 0, GROWABLE_HEAP_LOAD_I8(ptr | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 1 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 1 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 2 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 2 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 3 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 3 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 4 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 4 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 5 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 5 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 6 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 6 | 0));
 GROWABLE_HEAP_STORE_I8(tempDoublePtr + 7 | 0, GROWABLE_HEAP_LOAD_I8(ptr + 7 | 0));
}
function demangle(func) {
 warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");
 return func;
}
Module["demangle"] = demangle;
function demangleAll(text) {
 var regex = /__Z[\w\d_]+/g;
 return text.replace(regex, (function(x) {
  var y = demangle(x);
  return x === y ? x : y + " [" + x + "]";
 }));
}
Module["demangleAll"] = demangleAll;
function jsStackTrace() {
 var err = new Error;
 if (!err.stack) {
  try {
   throw new Error(0);
  } catch (e) {
   err = e;
  }
  if (!err.stack) {
   return "(no stack trace available)";
  }
 }
 return err.stack.toString();
}
Module["jsStackTrace"] = jsStackTrace;
function stackTrace() {
 var js = jsStackTrace();
 if (Module["extraStackTrace"]) js += "\n" + Module["extraStackTrace"]();
 return demangleAll(js);
}
Module["stackTrace"] = stackTrace;
function ___assert_fail(condition, filename, line, func) {
 abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [ filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function" ]);
}
Module["___assert_fail"] = ___assert_fail;
var ENV = {};
Module["ENV"] = ENV;
function ___buildEnvironment(environ) {
 var MAX_ENV_VALUES = 64;
 var TOTAL_ENV_SIZE = 1024;
 var poolPtr;
 var envPtr;
 if (!___buildEnvironment.called) {
  ___buildEnvironment.called = true;
  ENV["USER"] = ENV["LOGNAME"] = "web_user";
  ENV["PATH"] = "/";
  ENV["PWD"] = "/";
  ENV["HOME"] = "/home/web_user";
  ENV["LANG"] = "C.UTF-8";
  ENV["LANG"] = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
  ENV["_"] = thisProgram;
  poolPtr = getMemory(TOTAL_ENV_SIZE);
  envPtr = getMemory(MAX_ENV_VALUES * 4);
  GROWABLE_HEAP_STORE_I32(envPtr | 0, poolPtr);
  GROWABLE_HEAP_STORE_I32(environ | 0, envPtr);
 } else {
  envPtr = GROWABLE_HEAP_LOAD_I32(environ | 0);
  poolPtr = GROWABLE_HEAP_LOAD_I32(envPtr | 0);
 }
 var strings = [];
 var totalSize = 0;
 for (var key in ENV) {
  if (typeof ENV[key] === "string") {
   var line = key + "=" + ENV[key];
   strings.push(line);
   totalSize += line.length;
  }
 }
 if (totalSize > TOTAL_ENV_SIZE) {
  throw new Error("Environment size exceeded TOTAL_ENV_SIZE!");
 }
 var ptrSize = 4;
 for (var i = 0; i < strings.length; i++) {
  var line = strings[i];
  writeAsciiToMemory(line, poolPtr);
  GROWABLE_HEAP_STORE_I32(envPtr + i * ptrSize | 0, poolPtr);
  poolPtr += line.length + 1;
 }
 GROWABLE_HEAP_STORE_I32(envPtr + strings.length * ptrSize | 0, 0);
}
Module["___buildEnvironment"] = ___buildEnvironment;
var PROCINFO = {
 ppid: 1,
 pid: 42,
 sid: 42,
 pgid: 42
};
Module["PROCINFO"] = PROCINFO;
var __pthread_ptr = 0;
Module["__pthread_ptr"] = __pthread_ptr;
var __pthread_is_main_runtime_thread = 0;
Module["__pthread_is_main_runtime_thread"] = __pthread_is_main_runtime_thread;
var __pthread_is_main_browser_thread = 0;
Module["__pthread_is_main_browser_thread"] = __pthread_is_main_browser_thread;
var ERRNO_CODES = {
 EPERM: 1,
 ENOENT: 2,
 ESRCH: 3,
 EINTR: 4,
 EIO: 5,
 ENXIO: 6,
 E2BIG: 7,
 ENOEXEC: 8,
 EBADF: 9,
 ECHILD: 10,
 EAGAIN: 11,
 EWOULDBLOCK: 11,
 ENOMEM: 12,
 EACCES: 13,
 EFAULT: 14,
 ENOTBLK: 15,
 EBUSY: 16,
 EEXIST: 17,
 EXDEV: 18,
 ENODEV: 19,
 ENOTDIR: 20,
 EISDIR: 21,
 EINVAL: 22,
 ENFILE: 23,
 EMFILE: 24,
 ENOTTY: 25,
 ETXTBSY: 26,
 EFBIG: 27,
 ENOSPC: 28,
 ESPIPE: 29,
 EROFS: 30,
 EMLINK: 31,
 EPIPE: 32,
 EDOM: 33,
 ERANGE: 34,
 ENOMSG: 42,
 EIDRM: 43,
 ECHRNG: 44,
 EL2NSYNC: 45,
 EL3HLT: 46,
 EL3RST: 47,
 ELNRNG: 48,
 EUNATCH: 49,
 ENOCSI: 50,
 EL2HLT: 51,
 EDEADLK: 35,
 ENOLCK: 37,
 EBADE: 52,
 EBADR: 53,
 EXFULL: 54,
 ENOANO: 55,
 EBADRQC: 56,
 EBADSLT: 57,
 EDEADLOCK: 35,
 EBFONT: 59,
 ENOSTR: 60,
 ENODATA: 61,
 ETIME: 62,
 ENOSR: 63,
 ENONET: 64,
 ENOPKG: 65,
 EREMOTE: 66,
 ENOLINK: 67,
 EADV: 68,
 ESRMNT: 69,
 ECOMM: 70,
 EPROTO: 71,
 EMULTIHOP: 72,
 EDOTDOT: 73,
 EBADMSG: 74,
 ENOTUNIQ: 76,
 EBADFD: 77,
 EREMCHG: 78,
 ELIBACC: 79,
 ELIBBAD: 80,
 ELIBSCN: 81,
 ELIBMAX: 82,
 ELIBEXEC: 83,
 ENOSYS: 38,
 ENOTEMPTY: 39,
 ENAMETOOLONG: 36,
 ELOOP: 40,
 EOPNOTSUPP: 95,
 EPFNOSUPPORT: 96,
 ECONNRESET: 104,
 ENOBUFS: 105,
 EAFNOSUPPORT: 97,
 EPROTOTYPE: 91,
 ENOTSOCK: 88,
 ENOPROTOOPT: 92,
 ESHUTDOWN: 108,
 ECONNREFUSED: 111,
 EADDRINUSE: 98,
 ECONNABORTED: 103,
 ENETUNREACH: 101,
 ENETDOWN: 100,
 ETIMEDOUT: 110,
 EHOSTDOWN: 112,
 EHOSTUNREACH: 113,
 EINPROGRESS: 115,
 EALREADY: 114,
 EDESTADDRREQ: 89,
 EMSGSIZE: 90,
 EPROTONOSUPPORT: 93,
 ESOCKTNOSUPPORT: 94,
 EADDRNOTAVAIL: 99,
 ENETRESET: 102,
 EISCONN: 106,
 ENOTCONN: 107,
 ETOOMANYREFS: 109,
 EUSERS: 87,
 EDQUOT: 122,
 ESTALE: 116,
 ENOTSUP: 95,
 ENOMEDIUM: 123,
 EILSEQ: 84,
 EOVERFLOW: 75,
 ECANCELED: 125,
 ENOTRECOVERABLE: 131,
 EOWNERDEAD: 130,
 ESTRPIPE: 86
};
Module["ERRNO_CODES"] = ERRNO_CODES;
var PThread = {
 MAIN_THREAD_ID: 1,
 mainThreadInfo: {
  schedPolicy: 0,
  schedPrio: 0
 },
 unusedWorkerPool: [],
 runningWorkers: [],
 initRuntime: (function() {
  __register_pthread_ptr(PThread.mainThreadBlock, !ENVIRONMENT_IS_WORKER, 1);
  _emscripten_register_main_browser_thread_id(PThread.mainThreadBlock);
 }),
 initMainThreadBlock: (function() {
  if (ENVIRONMENT_IS_PTHREAD) return undefined;
  PThread.mainThreadBlock = 662320;
  for (var i = 0; i < 244 / 4; ++i) GROWABLE_HEAP_STORE_I32((PThread.mainThreadBlock / 4 + i) * 4 | 0, 0);
  GROWABLE_HEAP_STORE_I32(PThread.mainThreadBlock + 24 | 0, PThread.mainThreadBlock);
  var headPtr = PThread.mainThreadBlock + 168;
  GROWABLE_HEAP_STORE_I32(headPtr | 0, headPtr);
  var tlsMemory = 662576;
  for (var i = 0; i < 128; ++i) GROWABLE_HEAP_STORE_I32((tlsMemory / 4 + i) * 4 | 0, 0);
  Atomics.store(HEAPU32, PThread.mainThreadBlock + 116 >> 2, tlsMemory);
  Atomics.store(HEAPU32, PThread.mainThreadBlock + 52 >> 2, PThread.mainThreadBlock);
  Atomics.store(HEAPU32, PThread.mainThreadBlock + 56 >> 2, PROCINFO.pid);
 }),
 pthreads: {},
 pthreadIdCounter: 2,
 exitHandlers: null,
 setThreadStatus: (function() {}),
 runExitHandlers: (function() {
  if (PThread.exitHandlers !== null) {
   while (PThread.exitHandlers.length > 0) {
    PThread.exitHandlers.pop()();
   }
   PThread.exitHandlers = null;
  }
  if (ENVIRONMENT_IS_PTHREAD && threadInfoStruct) ___pthread_tsd_run_dtors();
 }),
 threadExit: (function(exitCode) {
  var tb = _pthread_self();
  if (tb) {
   Atomics.store(HEAPU32, tb + 4 >> 2, exitCode);
   Atomics.store(HEAPU32, tb + 0 >> 2, 1);
   Atomics.store(HEAPU32, tb + 72 >> 2, 1);
   Atomics.store(HEAPU32, tb + 76 >> 2, 0);
   PThread.runExitHandlers();
   _emscripten_futex_wake(tb + 0, 2147483647);
   __register_pthread_ptr(0, 0, 0);
   threadInfoStruct = 0;
   if (ENVIRONMENT_IS_PTHREAD) {
    postMessage({
     cmd: "exit"
    });
   }
  }
 }),
 threadCancel: (function() {
  PThread.runExitHandlers();
  Atomics.store(HEAPU32, threadInfoStruct + 4 >> 2, -1);
  Atomics.store(HEAPU32, threadInfoStruct + 0 >> 2, 1);
  _emscripten_futex_wake(threadInfoStruct + 0, 2147483647);
  threadInfoStruct = selfThreadId = 0;
  __register_pthread_ptr(0, 0, 0);
  postMessage({
   cmd: "cancelDone"
  });
 }),
 terminateAllThreads: (function() {
  for (var t in PThread.pthreads) {
   var pthread = PThread.pthreads[t];
   if (pthread) {
    PThread.freeThreadData(pthread);
    if (pthread.worker) pthread.worker.terminate();
   }
  }
  PThread.pthreads = {};
  for (var t in PThread.unusedWorkerPool) {
   var pthread = PThread.unusedWorkerPool[t];
   if (pthread) {
    PThread.freeThreadData(pthread);
    if (pthread.worker) pthread.worker.terminate();
   }
  }
  PThread.unusedWorkerPool = [];
  for (var t in PThread.runningWorkers) {
   var pthread = PThread.runningWorkers[t];
   if (pthread) {
    PThread.freeThreadData(pthread);
    if (pthread.worker) pthread.worker.terminate();
   }
  }
  PThread.runningWorkers = [];
 }),
 freeThreadData: (function(pthread) {
  if (!pthread) return;
  if (pthread.threadInfoStruct) {
   var tlsMemory = GROWABLE_HEAP_LOAD_I32(pthread.threadInfoStruct + 116 | 0);
   GROWABLE_HEAP_STORE_I32(pthread.threadInfoStruct + 116 | 0, 0);
   _free(tlsMemory);
   _free(pthread.threadInfoStruct);
  }
  pthread.threadInfoStruct = 0;
  if (pthread.allocatedOwnStack && pthread.stackBase) _free(pthread.stackBase);
  pthread.stackBase = 0;
  if (pthread.worker) pthread.worker.pthread = null;
 }),
 returnWorkerToPool: (function(worker) {
  delete PThread.pthreads[worker.pthread.thread];
  PThread.unusedWorkerPool.push(worker);
  PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker.pthread), 1);
  PThread.freeThreadData(worker.pthread);
  worker.pthread = undefined;
 }),
 receiveObjectTransfer: (function(data) {}),
 allocateUnusedWorkers: (function(numWorkers, onFinishedLoading) {
  if (typeof SharedArrayBuffer === "undefined") return;
  var numWorkersLoaded = 0;
  var pthreadMainJs = "hsimsweb.worker.js";
  pthreadMainJs = locateFile(pthreadMainJs);
  for (var i = 0; i < numWorkers; ++i) {
   var worker = new Worker(pthreadMainJs);
   ((function(worker) {
    worker.onmessage = (function(e) {
     var d = e.data;
     if (worker.pthread) PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
     if (d.targetThread && d.targetThread != _pthread_self()) {
      var thread = PThread.pthreads[d.targetThread];
      if (thread) {
       thread.worker.postMessage(e.data, d.transferList);
      } else {
       console.error('Internal error! Worker sent a message "' + d.cmd + '" to target pthread ' + d.targetThread + ", but that thread no longer exists!");
      }
      PThread.currentProxiedOperationCallerThread = undefined;
      return;
     }
     if (d.cmd === "processQueuedMainThreadWork") {
      _emscripten_main_thread_process_queued_calls();
     } else if (d.cmd === "spawnThread") {
      __spawn_thread(e.data);
     } else if (d.cmd === "cleanupThread") {
      __cleanup_thread(d.thread);
     } else if (d.cmd === "killThread") {
      __kill_thread(d.thread);
     } else if (d.cmd === "cancelThread") {
      __cancel_thread(d.thread);
     } else if (d.cmd === "loaded") {
      worker.loaded = true;
      if (worker.runPthread) {
       worker.runPthread();
       delete worker.runPthread;
      }
      ++numWorkersLoaded;
      if (numWorkersLoaded === numWorkers && onFinishedLoading) {
       onFinishedLoading();
      }
     } else if (d.cmd === "print") {
      out("Thread " + d.threadId + ": " + d.text);
     } else if (d.cmd === "printErr") {
      err("Thread " + d.threadId + ": " + d.text);
     } else if (d.cmd === "alert") {
      alert("Thread " + d.threadId + ": " + d.text);
     } else if (d.cmd === "exit") {
      var detached = worker.pthread && Atomics.load(HEAPU32, worker.pthread.thread + 80 >> 2);
      if (detached) {
       PThread.returnWorkerToPool(worker);
      }
     } else if (d.cmd === "exitProcess") {
      Module["noExitRuntime"] = false;
      exit(d.returnCode);
     } else if (d.cmd === "cancelDone") {
      PThread.returnWorkerToPool(worker);
     } else if (d.cmd === "objectTransfer") {
      PThread.receiveObjectTransfer(e.data);
     } else if (e.data.target === "setimmediate") {
      worker.postMessage(e.data);
     } else {
      err("worker sent an unknown command " + d.cmd);
     }
     PThread.currentProxiedOperationCallerThread = undefined;
    });
    worker.onerror = (function(e) {
     err("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
    });
   }))(worker);
   var tempDoublePtr = getMemory(8);
   worker.postMessage({
    cmd: "load",
    urlOrBlob: Module["mainScriptUrlOrBlob"] || _scriptDir,
    wasmMemory: wasmMemory,
    wasmModule: wasmModule,
    tempDoublePtr: tempDoublePtr,
    DYNAMIC_BASE: DYNAMIC_BASE,
    DYNAMICTOP_PTR: DYNAMICTOP_PTR,
    PthreadWorkerInit: PthreadWorkerInit
   });
   PThread.unusedWorkerPool.push(worker);
  }
 }),
 getNewWorker: (function() {
  if (PThread.unusedWorkerPool.length == 0) PThread.allocateUnusedWorkers(1);
  if (PThread.unusedWorkerPool.length > 0) return PThread.unusedWorkerPool.pop(); else return null;
 }),
 busySpinWait: (function(msecs) {
  var t = performance.now() + msecs;
  while (performance.now() < t) {
  }
 })
};
Module["PThread"] = PThread;
function ___call_main(argc, argv) {
 var returnCode = _main(argc, argv);
 if (!Module["noExitRuntime"]) postMessage({
  cmd: "exitProcess",
  returnCode: returnCode
 });
 return returnCode;
}
Module["___call_main"] = ___call_main;
function _emscripten_get_now() {
 abort();
}
Module["_emscripten_get_now"] = _emscripten_get_now;
function _emscripten_get_now_is_monotonic() {
 return 0 || ENVIRONMENT_IS_NODE || typeof dateNow !== "undefined" || typeof performance === "object" && performance && typeof performance["now"] === "function";
}
Module["_emscripten_get_now_is_monotonic"] = _emscripten_get_now_is_monotonic;
function ___setErrNo(value) {
 if (Module["___errno_location"]) GROWABLE_HEAP_STORE_I32(Module["___errno_location"]() | 0, value); else err("failed to set errno from JS");
 return value;
}
Module["___setErrNo"] = ___setErrNo;
function _clock_gettime(clk_id, tp) {
 var now;
 if (clk_id === 0) {
  now = Date.now();
 } else if (clk_id === 1 && _emscripten_get_now_is_monotonic()) {
  now = _emscripten_get_now();
 } else {
  ___setErrNo(22);
  return -1;
 }
 GROWABLE_HEAP_STORE_I32(tp | 0, now / 1e3 | 0);
 GROWABLE_HEAP_STORE_I32(tp + 4 | 0, now % 1e3 * 1e3 * 1e3 | 0);
 return 0;
}
Module["_clock_gettime"] = _clock_gettime;
function ___clock_gettime(a0, a1) {
 return _clock_gettime(a0, a1);
}
Module["___clock_gettime"] = ___clock_gettime;
function ___cxa_allocate_exception(size) {
 return _malloc(size);
}
Module["___cxa_allocate_exception"] = ___cxa_allocate_exception;
var ___exception_infos = {};
Module["___exception_infos"] = ___exception_infos;
var ___exception_caught = [];
Module["___exception_caught"] = ___exception_caught;
function ___exception_addRef(ptr) {
 if (!ptr) return;
 var info = ___exception_infos[ptr];
 info.refcount++;
}
Module["___exception_addRef"] = ___exception_addRef;
function ___exception_deAdjust(adjusted) {
 if (!adjusted || ___exception_infos[adjusted]) return adjusted;
 for (var key in ___exception_infos) {
  var ptr = +key;
  var adj = ___exception_infos[ptr].adjusted;
  var len = adj.length;
  for (var i = 0; i < len; i++) {
   if (adj[i] === adjusted) {
    return ptr;
   }
  }
 }
 return adjusted;
}
Module["___exception_deAdjust"] = ___exception_deAdjust;
function ___cxa_begin_catch(ptr) {
 var info = ___exception_infos[ptr];
 if (info && !info.caught) {
  info.caught = true;
  __ZSt18uncaught_exceptionv.uncaught_exceptions--;
 }
 if (info) info.rethrown = false;
 ___exception_caught.push(ptr);
 ___exception_addRef(___exception_deAdjust(ptr));
 return ptr;
}
Module["___cxa_begin_catch"] = ___cxa_begin_catch;
function ___cxa_pure_virtual() {
 ABORT = true;
 throw "Pure virtual function called!";
}
Module["___cxa_pure_virtual"] = ___cxa_pure_virtual;
var ___exception_last = 0;
Module["___exception_last"] = ___exception_last;
function ___cxa_throw(ptr, type, destructor) {
 ___exception_infos[ptr] = {
  ptr: ptr,
  adjusted: [ ptr ],
  type: type,
  destructor: destructor,
  refcount: 0,
  caught: false,
  rethrown: false
 };
 ___exception_last = ptr;
 if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
  __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;
 } else {
  __ZSt18uncaught_exceptionv.uncaught_exceptions++;
 }
 throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
}
Module["___cxa_throw"] = ___cxa_throw;
function ___cxa_uncaught_exceptions() {
 return __ZSt18uncaught_exceptionv.uncaught_exceptions;
}
Module["___cxa_uncaught_exceptions"] = ___cxa_uncaught_exceptions;
function ___gxx_personality_v0() {}
Module["___gxx_personality_v0"] = ___gxx_personality_v0;
function ___lock() {}
Module["___lock"] = ___lock;
function ___map_file(pathname, size) {
 ___setErrNo(1);
 return -1;
}
Module["___map_file"] = ___map_file;
var PATH = {
 splitPath: (function(filename) {
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  return splitPathRe.exec(filename).slice(1);
 }),
 normalizeArray: (function(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
   var last = parts[i];
   if (last === ".") {
    parts.splice(i, 1);
   } else if (last === "..") {
    parts.splice(i, 1);
    up++;
   } else if (up) {
    parts.splice(i, 1);
    up--;
   }
  }
  if (allowAboveRoot) {
   for (; up; up--) {
    parts.unshift("..");
   }
  }
  return parts;
 }),
 normalize: (function(path) {
  var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
  path = PATH.normalizeArray(path.split("/").filter((function(p) {
   return !!p;
  })), !isAbsolute).join("/");
  if (!path && !isAbsolute) {
   path = ".";
  }
  if (path && trailingSlash) {
   path += "/";
  }
  return (isAbsolute ? "/" : "") + path;
 }),
 dirname: (function(path) {
  var result = PATH.splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
   return ".";
  }
  if (dir) {
   dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
 }),
 basename: (function(path) {
  if (path === "/") return "/";
  var lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) return path;
  return path.substr(lastSlash + 1);
 }),
 extname: (function(path) {
  return PATH.splitPath(path)[3];
 }),
 join: (function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return PATH.normalize(paths.join("/"));
 }),
 join2: (function(l, r) {
  return PATH.normalize(l + "/" + r);
 })
};
Module["PATH"] = PATH;
var PATH_FS = {
 resolve: (function() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
   var path = i >= 0 ? arguments[i] : FS.cwd();
   if (typeof path !== "string") {
    throw new TypeError("Arguments to path.resolve must be strings");
   } else if (!path) {
    return "";
   }
   resolvedPath = path + "/" + resolvedPath;
   resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((function(p) {
   return !!p;
  })), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
 }),
 relative: (function(from, to) {
  from = PATH_FS.resolve(from).substr(1);
  to = PATH_FS.resolve(to).substr(1);
  function trim(arr) {
   var start = 0;
   for (; start < arr.length; start++) {
    if (arr[start] !== "") break;
   }
   var end = arr.length - 1;
   for (; end >= 0; end--) {
    if (arr[end] !== "") break;
   }
   if (start > end) return [];
   return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
   if (fromParts[i] !== toParts[i]) {
    samePartsLength = i;
    break;
   }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
   outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
 })
};
Module["PATH_FS"] = PATH_FS;
var TTY = {
 ttys: [],
 init: (function() {}),
 shutdown: (function() {}),
 register: (function(dev, ops) {
  TTY.ttys[dev] = {
   input: [],
   output: [],
   ops: ops
  };
  FS.registerDevice(dev, TTY.stream_ops);
 }),
 stream_ops: {
  open: (function(stream) {
   var tty = TTY.ttys[stream.node.rdev];
   if (!tty) {
    throw new FS.ErrnoError(19);
   }
   stream.tty = tty;
   stream.seekable = false;
  }),
  close: (function(stream) {
   stream.tty.ops.flush(stream.tty);
  }),
  flush: (function(stream) {
   stream.tty.ops.flush(stream.tty);
  }),
  read: (function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.get_char) {
    throw new FS.ErrnoError(6);
   }
   var bytesRead = 0;
   for (var i = 0; i < length; i++) {
    var result;
    try {
     result = stream.tty.ops.get_char(stream.tty);
    } catch (e) {
     throw new FS.ErrnoError(5);
    }
    if (result === undefined && bytesRead === 0) {
     throw new FS.ErrnoError(11);
    }
    if (result === null || result === undefined) break;
    bytesRead++;
    buffer[offset + i] = result;
   }
   if (bytesRead) {
    stream.node.timestamp = Date.now();
   }
   return bytesRead;
  }),
  write: (function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.put_char) {
    throw new FS.ErrnoError(6);
   }
   try {
    for (var i = 0; i < length; i++) {
     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
    }
   } catch (e) {
    throw new FS.ErrnoError(5);
   }
   if (length) {
    stream.node.timestamp = Date.now();
   }
   return i;
  })
 },
 default_tty_ops: {
  get_char: (function(tty) {
   if (!tty.input.length) {
    var result = null;
    if (ENVIRONMENT_IS_NODE) {
     var BUFSIZE = 256;
     var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
     var bytesRead = 0;
     var isPosixPlatform = process.platform != "win32";
     var fd = process.stdin.fd;
     if (isPosixPlatform) {
      var usingDevice = false;
      try {
       fd = fs.openSync("/dev/stdin", "r");
       usingDevice = true;
      } catch (e) {}
     }
     try {
      bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);
     } catch (e) {
      if (e.toString().indexOf("EOF") != -1) bytesRead = 0; else throw e;
     }
     if (usingDevice) {
      fs.closeSync(fd);
     }
     if (bytesRead > 0) {
      result = buf.slice(0, bytesRead).toString("utf-8");
     } else {
      result = null;
     }
    } else if (typeof window != "undefined" && typeof window.prompt == "function") {
     result = window.prompt("Input: ");
     if (result !== null) {
      result += "\n";
     }
    } else if (typeof readline == "function") {
     result = readline();
     if (result !== null) {
      result += "\n";
     }
    }
    if (!result) {
     return null;
    }
    tty.input = intArrayFromString(result, true);
   }
   return tty.input.shift();
  }),
  put_char: (function(tty, val) {
   if (val === null || val === 10) {
    out(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  }),
  flush: (function(tty) {
   if (tty.output && tty.output.length > 0) {
    out(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  })
 },
 default_tty1_ops: {
  put_char: (function(tty, val) {
   if (val === null || val === 10) {
    err(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  }),
  flush: (function(tty) {
   if (tty.output && tty.output.length > 0) {
    err(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  })
 }
};
Module["TTY"] = TTY;
var MEMFS = {
 ops_table: null,
 mount: (function(mount) {
  return MEMFS.createNode(null, "/", 16384 | 511, 0);
 }),
 createNode: (function(parent, name, mode, dev) {
  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
   throw new FS.ErrnoError(1);
  }
  if (!MEMFS.ops_table) {
   MEMFS.ops_table = {
    dir: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      lookup: MEMFS.node_ops.lookup,
      mknod: MEMFS.node_ops.mknod,
      rename: MEMFS.node_ops.rename,
      unlink: MEMFS.node_ops.unlink,
      rmdir: MEMFS.node_ops.rmdir,
      readdir: MEMFS.node_ops.readdir,
      symlink: MEMFS.node_ops.symlink
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek
     }
    },
    file: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek,
      read: MEMFS.stream_ops.read,
      write: MEMFS.stream_ops.write,
      allocate: MEMFS.stream_ops.allocate,
      mmap: MEMFS.stream_ops.mmap,
      msync: MEMFS.stream_ops.msync
     }
    },
    link: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      readlink: MEMFS.node_ops.readlink
     },
     stream: {}
    },
    chrdev: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: FS.chrdev_stream_ops
    }
   };
  }
  var node = FS.createNode(parent, name, mode, dev);
  if (FS.isDir(node.mode)) {
   node.node_ops = MEMFS.ops_table.dir.node;
   node.stream_ops = MEMFS.ops_table.dir.stream;
   node.contents = {};
  } else if (FS.isFile(node.mode)) {
   node.node_ops = MEMFS.ops_table.file.node;
   node.stream_ops = MEMFS.ops_table.file.stream;
   node.usedBytes = 0;
   node.contents = null;
  } else if (FS.isLink(node.mode)) {
   node.node_ops = MEMFS.ops_table.link.node;
   node.stream_ops = MEMFS.ops_table.link.stream;
  } else if (FS.isChrdev(node.mode)) {
   node.node_ops = MEMFS.ops_table.chrdev.node;
   node.stream_ops = MEMFS.ops_table.chrdev.stream;
  }
  node.timestamp = Date.now();
  if (parent) {
   parent.contents[name] = node;
  }
  return node;
 }),
 getFileDataAsRegularArray: (function(node) {
  if (node.contents && node.contents.subarray) {
   var arr = [];
   for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
   return arr;
  }
  return node.contents;
 }),
 getFileDataAsTypedArray: (function(node) {
  if (!node.contents) return new Uint8Array;
  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
  return new Uint8Array(node.contents);
 }),
 expandFileStorage: (function(node, newCapacity) {
  var prevCapacity = node.contents ? node.contents.length : 0;
  if (prevCapacity >= newCapacity) return;
  var CAPACITY_DOUBLING_MAX = 1024 * 1024;
  newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);
  if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
  var oldContents = node.contents;
  node.contents = new Uint8Array(newCapacity);
  if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
  return;
 }),
 resizeFileStorage: (function(node, newSize) {
  if (node.usedBytes == newSize) return;
  if (newSize == 0) {
   node.contents = null;
   node.usedBytes = 0;
   return;
  }
  if (!node.contents || node.contents.subarray) {
   var oldContents = node.contents;
   node.contents = new Uint8Array(new ArrayBuffer(newSize));
   if (oldContents) {
    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
   }
   node.usedBytes = newSize;
   return;
  }
  if (!node.contents) node.contents = [];
  if (node.contents.length > newSize) node.contents.length = newSize; else while (node.contents.length < newSize) node.contents.push(0);
  node.usedBytes = newSize;
 }),
 node_ops: {
  getattr: (function(node) {
   var attr = {};
   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
   attr.ino = node.id;
   attr.mode = node.mode;
   attr.nlink = 1;
   attr.uid = 0;
   attr.gid = 0;
   attr.rdev = node.rdev;
   if (FS.isDir(node.mode)) {
    attr.size = 4096;
   } else if (FS.isFile(node.mode)) {
    attr.size = node.usedBytes;
   } else if (FS.isLink(node.mode)) {
    attr.size = node.link.length;
   } else {
    attr.size = 0;
   }
   attr.atime = new Date(node.timestamp);
   attr.mtime = new Date(node.timestamp);
   attr.ctime = new Date(node.timestamp);
   attr.blksize = 4096;
   attr.blocks = Math.ceil(attr.size / attr.blksize);
   return attr;
  }),
  setattr: (function(node, attr) {
   if (attr.mode !== undefined) {
    node.mode = attr.mode;
   }
   if (attr.timestamp !== undefined) {
    node.timestamp = attr.timestamp;
   }
   if (attr.size !== undefined) {
    MEMFS.resizeFileStorage(node, attr.size);
   }
  }),
  lookup: (function(parent, name) {
   throw FS.genericErrors[2];
  }),
  mknod: (function(parent, name, mode, dev) {
   return MEMFS.createNode(parent, name, mode, dev);
  }),
  rename: (function(old_node, new_dir, new_name) {
   if (FS.isDir(old_node.mode)) {
    var new_node;
    try {
     new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {}
    if (new_node) {
     for (var i in new_node.contents) {
      throw new FS.ErrnoError(39);
     }
    }
   }
   delete old_node.parent.contents[old_node.name];
   old_node.name = new_name;
   new_dir.contents[new_name] = old_node;
   old_node.parent = new_dir;
  }),
  unlink: (function(parent, name) {
   delete parent.contents[name];
  }),
  rmdir: (function(parent, name) {
   var node = FS.lookupNode(parent, name);
   for (var i in node.contents) {
    throw new FS.ErrnoError(39);
   }
   delete parent.contents[name];
  }),
  readdir: (function(node) {
   var entries = [ ".", ".." ];
   for (var key in node.contents) {
    if (!node.contents.hasOwnProperty(key)) {
     continue;
    }
    entries.push(key);
   }
   return entries;
  }),
  symlink: (function(parent, newname, oldpath) {
   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
   node.link = oldpath;
   return node;
  }),
  readlink: (function(node) {
   if (!FS.isLink(node.mode)) {
    throw new FS.ErrnoError(22);
   }
   return node.link;
  })
 },
 stream_ops: {
  read: (function(stream, buffer, offset, length, position) {
   var contents = stream.node.contents;
   if (position >= stream.node.usedBytes) return 0;
   var size = Math.min(stream.node.usedBytes - position, length);
   assert(size >= 0);
   if (size > 8 && contents.subarray) {
    buffer.set(contents.subarray(position, position + size), offset);
   } else {
    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
   }
   return size;
  }),
  write: (function(stream, buffer, offset, length, position, canOwn) {
   if (canOwn) {
    warnOnce("file packager has copied file data into memory, but in memory growth we are forced to copy it again (see --no-heap-copy)");
   }
   canOwn = false;
   if (!length) return 0;
   var node = stream.node;
   node.timestamp = Date.now();
   if (buffer.subarray && (!node.contents || node.contents.subarray)) {
    if (canOwn) {
     assert(position === 0, "canOwn must imply no weird position inside the file");
     node.contents = buffer.subarray(offset, offset + length);
     node.usedBytes = length;
     return length;
    } else if (node.usedBytes === 0 && position === 0) {
     node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
     node.usedBytes = length;
     return length;
    } else if (position + length <= node.usedBytes) {
     node.contents.set(buffer.subarray(offset, offset + length), position);
     return length;
    }
   }
   MEMFS.expandFileStorage(node, position + length);
   if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); else {
    for (var i = 0; i < length; i++) {
     node.contents[position + i] = buffer[offset + i];
    }
   }
   node.usedBytes = Math.max(node.usedBytes, position + length);
   return length;
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     position += stream.node.usedBytes;
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(22);
   }
   return position;
  }),
  allocate: (function(stream, offset, length) {
   MEMFS.expandFileStorage(stream.node, offset + length);
   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
  }),
  mmap: (function(stream, buffer, offset, length, position, prot, flags) {
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(19);
   }
   var ptr;
   var allocated;
   var contents = stream.node.contents;
   if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {
    allocated = false;
    ptr = contents.byteOffset;
   } else {
    if (position > 0 || position + length < stream.node.usedBytes) {
     if (contents.subarray) {
      contents = contents.subarray(position, position + length);
     } else {
      contents = Array.prototype.slice.call(contents, position, position + length);
     }
    }
    allocated = true;
    var fromHeap = buffer.buffer == HEAP8.buffer;
    ptr = _malloc(length);
    if (!ptr) {
     throw new FS.ErrnoError(12);
    }
    (fromHeap ? HEAP8 : buffer).set(contents, ptr);
   }
   return {
    ptr: ptr,
    allocated: allocated
   };
  }),
  msync: (function(stream, buffer, offset, length, mmapFlags) {
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(19);
   }
   if (mmapFlags & 2) {
    return 0;
   }
   var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
   return 0;
  })
 }
};
Module["MEMFS"] = MEMFS;
var IDBFS = {
 dbs: {},
 indexedDB: (function() {
  if (typeof indexedDB !== "undefined") return indexedDB;
  var ret = null;
  if (typeof window === "object") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
  assert(ret, "IDBFS used, but indexedDB not supported");
  return ret;
 }),
 DB_VERSION: 21,
 DB_STORE_NAME: "FILE_DATA",
 mount: (function(mount) {
  return MEMFS.mount.apply(null, arguments);
 }),
 syncfs: (function(mount, populate, callback) {
  IDBFS.getLocalSet(mount, (function(err, local) {
   if (err) return callback(err);
   IDBFS.getRemoteSet(mount, (function(err, remote) {
    if (err) return callback(err);
    var src = populate ? remote : local;
    var dst = populate ? local : remote;
    IDBFS.reconcile(src, dst, callback);
   }));
  }));
 }),
 getDB: (function(name, callback) {
  var db = IDBFS.dbs[name];
  if (db) {
   return callback(null, db);
  }
  var req;
  try {
   req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
  } catch (e) {
   return callback(e);
  }
  if (!req) {
   return callback("Unable to connect to IndexedDB");
  }
  req.onupgradeneeded = (function(e) {
   var db = e.target.result;
   var transaction = e.target.transaction;
   var fileStore;
   if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
    fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
   } else {
    fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
   }
   if (!fileStore.indexNames.contains("timestamp")) {
    fileStore.createIndex("timestamp", "timestamp", {
     unique: false
    });
   }
  });
  req.onsuccess = (function() {
   db = req.result;
   IDBFS.dbs[name] = db;
   callback(null, db);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 getLocalSet: (function(mount, callback) {
  var entries = {};
  function isRealDir(p) {
   return p !== "." && p !== "..";
  }
  function toAbsolute(root) {
   return (function(p) {
    return PATH.join2(root, p);
   });
  }
  var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  while (check.length) {
   var path = check.pop();
   var stat;
   try {
    stat = FS.stat(path);
   } catch (e) {
    return callback(e);
   }
   if (FS.isDir(stat.mode)) {
    check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
   }
   entries[path] = {
    timestamp: stat.mtime
   };
  }
  return callback(null, {
   type: "local",
   entries: entries
  });
 }),
 getRemoteSet: (function(mount, callback) {
  var entries = {};
  IDBFS.getDB(mount.mountpoint, (function(err, db) {
   if (err) return callback(err);
   try {
    var transaction = db.transaction([ IDBFS.DB_STORE_NAME ], "readonly");
    transaction.onerror = (function(e) {
     callback(this.error);
     e.preventDefault();
    });
    var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
    var index = store.index("timestamp");
    index.openKeyCursor().onsuccess = (function(event) {
     var cursor = event.target.result;
     if (!cursor) {
      return callback(null, {
       type: "remote",
       db: db,
       entries: entries
      });
     }
     entries[cursor.primaryKey] = {
      timestamp: cursor.key
     };
     cursor.continue();
    });
   } catch (e) {
    return callback(e);
   }
  }));
 }),
 loadLocalEntry: (function(path, callback) {
  var stat, node;
  try {
   var lookup = FS.lookupPath(path);
   node = lookup.node;
   stat = FS.stat(path);
  } catch (e) {
   return callback(e);
  }
  if (FS.isDir(stat.mode)) {
   return callback(null, {
    timestamp: stat.mtime,
    mode: stat.mode
   });
  } else if (FS.isFile(stat.mode)) {
   node.contents = MEMFS.getFileDataAsTypedArray(node);
   return callback(null, {
    timestamp: stat.mtime,
    mode: stat.mode,
    contents: node.contents
   });
  } else {
   return callback(new Error("node type not supported"));
  }
 }),
 storeLocalEntry: (function(path, entry, callback) {
  try {
   if (FS.isDir(entry.mode)) {
    FS.mkdir(path, entry.mode);
   } else if (FS.isFile(entry.mode)) {
    FS.writeFile(path, entry.contents, {
     canOwn: true
    });
   } else {
    return callback(new Error("node type not supported"));
   }
   FS.chmod(path, entry.mode);
   FS.utime(path, entry.timestamp, entry.timestamp);
  } catch (e) {
   return callback(e);
  }
  callback(null);
 }),
 removeLocalEntry: (function(path, callback) {
  try {
   var lookup = FS.lookupPath(path);
   var stat = FS.stat(path);
   if (FS.isDir(stat.mode)) {
    FS.rmdir(path);
   } else if (FS.isFile(stat.mode)) {
    FS.unlink(path);
   }
  } catch (e) {
   return callback(e);
  }
  callback(null);
 }),
 loadRemoteEntry: (function(store, path, callback) {
  var req = store.get(path);
  req.onsuccess = (function(event) {
   callback(null, event.target.result);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 storeRemoteEntry: (function(store, path, entry, callback) {
  var req = store.put(entry, path);
  req.onsuccess = (function() {
   callback(null);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 removeRemoteEntry: (function(store, path, callback) {
  var req = store.delete(path);
  req.onsuccess = (function() {
   callback(null);
  });
  req.onerror = (function(e) {
   callback(this.error);
   e.preventDefault();
  });
 }),
 reconcile: (function(src, dst, callback) {
  var total = 0;
  var create = [];
  Object.keys(src.entries).forEach((function(key) {
   var e = src.entries[key];
   var e2 = dst.entries[key];
   if (!e2 || e.timestamp > e2.timestamp) {
    create.push(key);
    total++;
   }
  }));
  var remove = [];
  Object.keys(dst.entries).forEach((function(key) {
   var e = dst.entries[key];
   var e2 = src.entries[key];
   if (!e2) {
    remove.push(key);
    total++;
   }
  }));
  if (!total) {
   return callback(null);
  }
  var errored = false;
  var db = src.type === "remote" ? src.db : dst.db;
  var transaction = db.transaction([ IDBFS.DB_STORE_NAME ], "readwrite");
  var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  function done(err) {
   if (err && !errored) {
    errored = true;
    return callback(err);
   }
  }
  transaction.onerror = (function(e) {
   done(this.error);
   e.preventDefault();
  });
  transaction.oncomplete = (function(e) {
   if (!errored) {
    callback(null);
   }
  });
  create.sort().forEach((function(path) {
   if (dst.type === "local") {
    IDBFS.loadRemoteEntry(store, path, (function(err, entry) {
     if (err) return done(err);
     IDBFS.storeLocalEntry(path, entry, done);
    }));
   } else {
    IDBFS.loadLocalEntry(path, (function(err, entry) {
     if (err) return done(err);
     IDBFS.storeRemoteEntry(store, path, entry, done);
    }));
   }
  }));
  remove.sort().reverse().forEach((function(path) {
   if (dst.type === "local") {
    IDBFS.removeLocalEntry(path, done);
   } else {
    IDBFS.removeRemoteEntry(store, path, done);
   }
  }));
 })
};
Module["IDBFS"] = IDBFS;
var NODEFS = {
 isWindows: false,
 staticInit: (function() {
  NODEFS.isWindows = !!process.platform.match(/^win/);
  var flags = process["binding"]("constants");
  if (flags["fs"]) {
   flags = flags["fs"];
  }
  NODEFS.flagsForNodeMap = {
   "1024": flags["O_APPEND"],
   "64": flags["O_CREAT"],
   "128": flags["O_EXCL"],
   "0": flags["O_RDONLY"],
   "2": flags["O_RDWR"],
   "4096": flags["O_SYNC"],
   "512": flags["O_TRUNC"],
   "1": flags["O_WRONLY"]
  };
 }),
 bufferFrom: (function(arrayBuffer) {
  return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
 }),
 mount: (function(mount) {
  assert(ENVIRONMENT_HAS_NODE);
  return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
 }),
 createNode: (function(parent, name, mode, dev) {
  if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
   throw new FS.ErrnoError(22);
  }
  var node = FS.createNode(parent, name, mode);
  node.node_ops = NODEFS.node_ops;
  node.stream_ops = NODEFS.stream_ops;
  return node;
 }),
 getMode: (function(path) {
  var stat;
  try {
   stat = fs.lstatSync(path);
   if (NODEFS.isWindows) {
    stat.mode = stat.mode | (stat.mode & 292) >> 2;
   }
  } catch (e) {
   if (!e.code) throw e;
   throw new FS.ErrnoError(-e.errno);
  }
  return stat.mode;
 }),
 realPath: (function(node) {
  var parts = [];
  while (node.parent !== node) {
   parts.push(node.name);
   node = node.parent;
  }
  parts.push(node.mount.opts.root);
  parts.reverse();
  return PATH.join.apply(null, parts);
 }),
 flagsForNode: (function(flags) {
  flags &= ~2097152;
  flags &= ~2048;
  flags &= ~32768;
  flags &= ~524288;
  var newFlags = 0;
  for (var k in NODEFS.flagsForNodeMap) {
   if (flags & k) {
    newFlags |= NODEFS.flagsForNodeMap[k];
    flags ^= k;
   }
  }
  if (!flags) {
   return newFlags;
  } else {
   throw new FS.ErrnoError(22);
  }
 }),
 node_ops: {
  getattr: (function(node) {
   var path = NODEFS.realPath(node);
   var stat;
   try {
    stat = fs.lstatSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
   if (NODEFS.isWindows && !stat.blksize) {
    stat.blksize = 4096;
   }
   if (NODEFS.isWindows && !stat.blocks) {
    stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
   }
   return {
    dev: stat.dev,
    ino: stat.ino,
    mode: stat.mode,
    nlink: stat.nlink,
    uid: stat.uid,
    gid: stat.gid,
    rdev: stat.rdev,
    size: stat.size,
    atime: stat.atime,
    mtime: stat.mtime,
    ctime: stat.ctime,
    blksize: stat.blksize,
    blocks: stat.blocks
   };
  }),
  setattr: (function(node, attr) {
   var path = NODEFS.realPath(node);
   try {
    if (attr.mode !== undefined) {
     fs.chmodSync(path, attr.mode);
     node.mode = attr.mode;
    }
    if (attr.timestamp !== undefined) {
     var date = new Date(attr.timestamp);
     fs.utimesSync(path, date, date);
    }
    if (attr.size !== undefined) {
     fs.truncateSync(path, attr.size);
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  lookup: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   var mode = NODEFS.getMode(path);
   return NODEFS.createNode(parent, name, mode);
  }),
  mknod: (function(parent, name, mode, dev) {
   var node = NODEFS.createNode(parent, name, mode, dev);
   var path = NODEFS.realPath(node);
   try {
    if (FS.isDir(node.mode)) {
     fs.mkdirSync(path, node.mode);
    } else {
     fs.writeFileSync(path, "", {
      mode: node.mode
     });
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
   return node;
  }),
  rename: (function(oldNode, newDir, newName) {
   var oldPath = NODEFS.realPath(oldNode);
   var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
   try {
    fs.renameSync(oldPath, newPath);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  unlink: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   try {
    fs.unlinkSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  rmdir: (function(parent, name) {
   var path = PATH.join2(NODEFS.realPath(parent), name);
   try {
    fs.rmdirSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  readdir: (function(node) {
   var path = NODEFS.realPath(node);
   try {
    return fs.readdirSync(path);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  symlink: (function(parent, newName, oldPath) {
   var newPath = PATH.join2(NODEFS.realPath(parent), newName);
   try {
    fs.symlinkSync(oldPath, newPath);
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  readlink: (function(node) {
   var path = NODEFS.realPath(node);
   try {
    path = fs.readlinkSync(path);
    path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
    return path;
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  })
 },
 stream_ops: {
  open: (function(stream) {
   var path = NODEFS.realPath(stream.node);
   try {
    if (FS.isFile(stream.node.mode)) {
     stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  close: (function(stream) {
   try {
    if (FS.isFile(stream.node.mode) && stream.nfd) {
     fs.closeSync(stream.nfd);
    }
   } catch (e) {
    if (!e.code) throw e;
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  read: (function(stream, buffer, offset, length, position) {
   if (length === 0) return 0;
   try {
    return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
   } catch (e) {
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  write: (function(stream, buffer, offset, length, position) {
   try {
    return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
   } catch (e) {
    throw new FS.ErrnoError(-e.errno);
   }
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     try {
      var stat = fs.fstatSync(stream.nfd);
      position += stat.size;
     } catch (e) {
      throw new FS.ErrnoError(-e.errno);
     }
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(22);
   }
   return position;
  })
 }
};
Module["NODEFS"] = NODEFS;
var WORKERFS = {
 DIR_MODE: 16895,
 FILE_MODE: 33279,
 reader: null,
 mount: (function(mount) {
  assert(ENVIRONMENT_IS_WORKER);
  if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync;
  var root = WORKERFS.createNode(null, "/", WORKERFS.DIR_MODE, 0);
  var createdParents = {};
  function ensureParent(path) {
   var parts = path.split("/");
   var parent = root;
   for (var i = 0; i < parts.length - 1; i++) {
    var curr = parts.slice(0, i + 1).join("/");
    if (!createdParents[curr]) {
     createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);
    }
    parent = createdParents[curr];
   }
   return parent;
  }
  function base(path) {
   var parts = path.split("/");
   return parts[parts.length - 1];
  }
  Array.prototype.forEach.call(mount.opts["files"] || [], (function(file) {
   WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);
  }));
  (mount.opts["blobs"] || []).forEach((function(obj) {
   WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"]);
  }));
  (mount.opts["packages"] || []).forEach((function(pack) {
   pack["metadata"].files.forEach((function(file) {
    var name = file.filename.substr(1);
    WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack["blob"].slice(file.start, file.end));
   }));
  }));
  return root;
 }),
 createNode: (function(parent, name, mode, dev, contents, mtime) {
  var node = FS.createNode(parent, name, mode);
  node.mode = mode;
  node.node_ops = WORKERFS.node_ops;
  node.stream_ops = WORKERFS.stream_ops;
  node.timestamp = (mtime || new Date).getTime();
  assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
  if (mode === WORKERFS.FILE_MODE) {
   node.size = contents.size;
   node.contents = contents;
  } else {
   node.size = 4096;
   node.contents = {};
  }
  if (parent) {
   parent.contents[name] = node;
  }
  return node;
 }),
 node_ops: {
  getattr: (function(node) {
   return {
    dev: 1,
    ino: undefined,
    mode: node.mode,
    nlink: 1,
    uid: 0,
    gid: 0,
    rdev: undefined,
    size: node.size,
    atime: new Date(node.timestamp),
    mtime: new Date(node.timestamp),
    ctime: new Date(node.timestamp),
    blksize: 4096,
    blocks: Math.ceil(node.size / 4096)
   };
  }),
  setattr: (function(node, attr) {
   if (attr.mode !== undefined) {
    node.mode = attr.mode;
   }
   if (attr.timestamp !== undefined) {
    node.timestamp = attr.timestamp;
   }
  }),
  lookup: (function(parent, name) {
   throw new FS.ErrnoError(2);
  }),
  mknod: (function(parent, name, mode, dev) {
   throw new FS.ErrnoError(1);
  }),
  rename: (function(oldNode, newDir, newName) {
   throw new FS.ErrnoError(1);
  }),
  unlink: (function(parent, name) {
   throw new FS.ErrnoError(1);
  }),
  rmdir: (function(parent, name) {
   throw new FS.ErrnoError(1);
  }),
  readdir: (function(node) {
   var entries = [ ".", ".." ];
   for (var key in node.contents) {
    if (!node.contents.hasOwnProperty(key)) {
     continue;
    }
    entries.push(key);
   }
   return entries;
  }),
  symlink: (function(parent, newName, oldPath) {
   throw new FS.ErrnoError(1);
  }),
  readlink: (function(node) {
   throw new FS.ErrnoError(1);
  })
 },
 stream_ops: {
  read: (function(stream, buffer, offset, length, position) {
   if (position >= stream.node.size) return 0;
   var chunk = stream.node.contents.slice(position, position + length);
   var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
   buffer.set(new Uint8Array(ab), offset);
   return chunk.size;
  }),
  write: (function(stream, buffer, offset, length, position) {
   throw new FS.ErrnoError(5);
  }),
  llseek: (function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     position += stream.node.size;
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(22);
   }
   return position;
  })
 }
};
Module["WORKERFS"] = WORKERFS;
var ERRNO_MESSAGES = {
 0: "Success",
 1: "Not super-user",
 2: "No such file or directory",
 3: "No such process",
 4: "Interrupted system call",
 5: "I/O error",
 6: "No such device or address",
 7: "Arg list too long",
 8: "Exec format error",
 9: "Bad file number",
 10: "No children",
 11: "No more processes",
 12: "Not enough core",
 13: "Permission denied",
 14: "Bad address",
 15: "Block device required",
 16: "Mount device busy",
 17: "File exists",
 18: "Cross-device link",
 19: "No such device",
 20: "Not a directory",
 21: "Is a directory",
 22: "Invalid argument",
 23: "Too many open files in system",
 24: "Too many open files",
 25: "Not a typewriter",
 26: "Text file busy",
 27: "File too large",
 28: "No space left on device",
 29: "Illegal seek",
 30: "Read only file system",
 31: "Too many links",
 32: "Broken pipe",
 33: "Math arg out of domain of func",
 34: "Math result not representable",
 35: "File locking deadlock error",
 36: "File or path name too long",
 37: "No record locks available",
 38: "Function not implemented",
 39: "Directory not empty",
 40: "Too many symbolic links",
 42: "No message of desired type",
 43: "Identifier removed",
 44: "Channel number out of range",
 45: "Level 2 not synchronized",
 46: "Level 3 halted",
 47: "Level 3 reset",
 48: "Link number out of range",
 49: "Protocol driver not attached",
 50: "No CSI structure available",
 51: "Level 2 halted",
 52: "Invalid exchange",
 53: "Invalid request descriptor",
 54: "Exchange full",
 55: "No anode",
 56: "Invalid request code",
 57: "Invalid slot",
 59: "Bad font file fmt",
 60: "Device not a stream",
 61: "No data (for no delay io)",
 62: "Timer expired",
 63: "Out of streams resources",
 64: "Machine is not on the network",
 65: "Package not installed",
 66: "The object is remote",
 67: "The link has been severed",
 68: "Advertise error",
 69: "Srmount error",
 70: "Communication error on send",
 71: "Protocol error",
 72: "Multihop attempted",
 73: "Cross mount point (not really error)",
 74: "Trying to read unreadable message",
 75: "Value too large for defined data type",
 76: "Given log. name not unique",
 77: "f.d. invalid for this operation",
 78: "Remote address changed",
 79: "Can   access a needed shared lib",
 80: "Accessing a corrupted shared lib",
 81: ".lib section in a.out corrupted",
 82: "Attempting to link in too many libs",
 83: "Attempting to exec a shared library",
 84: "Illegal byte sequence",
 86: "Streams pipe error",
 87: "Too many users",
 88: "Socket operation on non-socket",
 89: "Destination address required",
 90: "Message too long",
 91: "Protocol wrong type for socket",
 92: "Protocol not available",
 93: "Unknown protocol",
 94: "Socket type not supported",
 95: "Not supported",
 96: "Protocol family not supported",
 97: "Address family not supported by protocol family",
 98: "Address already in use",
 99: "Address not available",
 100: "Network interface is not configured",
 101: "Network is unreachable",
 102: "Connection reset by network",
 103: "Connection aborted",
 104: "Connection reset by peer",
 105: "No buffer space available",
 106: "Socket is already connected",
 107: "Socket is not connected",
 108: "Can't send after socket shutdown",
 109: "Too many references",
 110: "Connection timed out",
 111: "Connection refused",
 112: "Host is down",
 113: "Host is unreachable",
 114: "Socket already connected",
 115: "Connection already in progress",
 116: "Stale file handle",
 122: "Quota exceeded",
 123: "No medium (in tape drive)",
 125: "Operation canceled",
 130: "Previous owner died",
 131: "State not recoverable"
};
Module["ERRNO_MESSAGES"] = ERRNO_MESSAGES;
var FS = {
 root: null,
 mounts: [],
 devices: {},
 streams: [],
 nextInode: 1,
 nameTable: null,
 currentPath: "/",
 initialized: false,
 ignorePermissions: true,
 trackingDelegate: {},
 tracking: {
  openFlags: {
   READ: 1,
   WRITE: 2
  }
 },
 ErrnoError: null,
 genericErrors: {},
 filesystems: null,
 syncFSRequests: 0,
 handleFSError: (function(e) {
  if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
  return ___setErrNo(e.errno);
 }),
 lookupPath: (function(path, opts) {
  path = PATH_FS.resolve(FS.cwd(), path);
  opts = opts || {};
  if (!path) return {
   path: "",
   node: null
  };
  var defaults = {
   follow_mount: true,
   recurse_count: 0
  };
  for (var key in defaults) {
   if (opts[key] === undefined) {
    opts[key] = defaults[key];
   }
  }
  if (opts.recurse_count > 8) {
   throw new FS.ErrnoError(40);
  }
  var parts = PATH.normalizeArray(path.split("/").filter((function(p) {
   return !!p;
  })), false);
  var current = FS.root;
  var current_path = "/";
  for (var i = 0; i < parts.length; i++) {
   var islast = i === parts.length - 1;
   if (islast && opts.parent) {
    break;
   }
   current = FS.lookupNode(current, parts[i]);
   current_path = PATH.join2(current_path, parts[i]);
   if (FS.isMountpoint(current)) {
    if (!islast || islast && opts.follow_mount) {
     current = current.mounted.root;
    }
   }
   if (!islast || opts.follow) {
    var count = 0;
    while (FS.isLink(current.mode)) {
     var link = FS.readlink(current_path);
     current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
     var lookup = FS.lookupPath(current_path, {
      recurse_count: opts.recurse_count
     });
     current = lookup.node;
     if (count++ > 40) {
      throw new FS.ErrnoError(40);
     }
    }
   }
  }
  return {
   path: current_path,
   node: current
  };
 }),
 getPath: (function(node) {
  var path;
  while (true) {
   if (FS.isRoot(node)) {
    var mount = node.mount.mountpoint;
    if (!path) return mount;
    return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
   }
   path = path ? node.name + "/" + path : node.name;
   node = node.parent;
  }
 }),
 hashName: (function(parentid, name) {
  var hash = 0;
  for (var i = 0; i < name.length; i++) {
   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
  }
  return (parentid + hash >>> 0) % FS.nameTable.length;
 }),
 hashAddNode: (function(node) {
  var hash = FS.hashName(node.parent.id, node.name);
  node.name_next = FS.nameTable[hash];
  FS.nameTable[hash] = node;
 }),
 hashRemoveNode: (function(node) {
  var hash = FS.hashName(node.parent.id, node.name);
  if (FS.nameTable[hash] === node) {
   FS.nameTable[hash] = node.name_next;
  } else {
   var current = FS.nameTable[hash];
   while (current) {
    if (current.name_next === node) {
     current.name_next = node.name_next;
     break;
    }
    current = current.name_next;
   }
  }
 }),
 lookupNode: (function(parent, name) {
  var err = FS.mayLookup(parent);
  if (err) {
   throw new FS.ErrnoError(err, parent);
  }
  var hash = FS.hashName(parent.id, name);
  for (var node = FS.nameTable[hash]; node; node = node.name_next) {
   var nodeName = node.name;
   if (node.parent.id === parent.id && nodeName === name) {
    return node;
   }
  }
  return FS.lookup(parent, name);
 }),
 createNode: (function(parent, name, mode, rdev) {
  if (!FS.FSNode) {
   FS.FSNode = (function(parent, name, mode, rdev) {
    if (!parent) {
     parent = this;
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
   });
   FS.FSNode.prototype = {};
   var readMode = 292 | 73;
   var writeMode = 146;
   Object.defineProperties(FS.FSNode.prototype, {
    read: {
     get: (function() {
      return (this.mode & readMode) === readMode;
     }),
     set: (function(val) {
      val ? this.mode |= readMode : this.mode &= ~readMode;
     })
    },
    write: {
     get: (function() {
      return (this.mode & writeMode) === writeMode;
     }),
     set: (function(val) {
      val ? this.mode |= writeMode : this.mode &= ~writeMode;
     })
    },
    isFolder: {
     get: (function() {
      return FS.isDir(this.mode);
     })
    },
    isDevice: {
     get: (function() {
      return FS.isChrdev(this.mode);
     })
    }
   });
  }
  var node = new FS.FSNode(parent, name, mode, rdev);
  FS.hashAddNode(node);
  return node;
 }),
 destroyNode: (function(node) {
  FS.hashRemoveNode(node);
 }),
 isRoot: (function(node) {
  return node === node.parent;
 }),
 isMountpoint: (function(node) {
  return !!node.mounted;
 }),
 isFile: (function(mode) {
  return (mode & 61440) === 32768;
 }),
 isDir: (function(mode) {
  return (mode & 61440) === 16384;
 }),
 isLink: (function(mode) {
  return (mode & 61440) === 40960;
 }),
 isChrdev: (function(mode) {
  return (mode & 61440) === 8192;
 }),
 isBlkdev: (function(mode) {
  return (mode & 61440) === 24576;
 }),
 isFIFO: (function(mode) {
  return (mode & 61440) === 4096;
 }),
 isSocket: (function(mode) {
  return (mode & 49152) === 49152;
 }),
 flagModes: {
  "r": 0,
  "rs": 1052672,
  "r+": 2,
  "w": 577,
  "wx": 705,
  "xw": 705,
  "w+": 578,
  "wx+": 706,
  "xw+": 706,
  "a": 1089,
  "ax": 1217,
  "xa": 1217,
  "a+": 1090,
  "ax+": 1218,
  "xa+": 1218
 },
 modeStringToFlags: (function(str) {
  var flags = FS.flagModes[str];
  if (typeof flags === "undefined") {
   throw new Error("Unknown file open mode: " + str);
  }
  return flags;
 }),
 flagsToPermissionString: (function(flag) {
  var perms = [ "r", "w", "rw" ][flag & 3];
  if (flag & 512) {
   perms += "w";
  }
  return perms;
 }),
 nodePermissions: (function(node, perms) {
  if (FS.ignorePermissions) {
   return 0;
  }
  if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
   return 13;
  } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
   return 13;
  } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
   return 13;
  }
  return 0;
 }),
 mayLookup: (function(dir) {
  var err = FS.nodePermissions(dir, "x");
  if (err) return err;
  if (!dir.node_ops.lookup) return 13;
  return 0;
 }),
 mayCreate: (function(dir, name) {
  try {
   var node = FS.lookupNode(dir, name);
   return 17;
  } catch (e) {}
  return FS.nodePermissions(dir, "wx");
 }),
 mayDelete: (function(dir, name, isdir) {
  var node;
  try {
   node = FS.lookupNode(dir, name);
  } catch (e) {
   return e.errno;
  }
  var err = FS.nodePermissions(dir, "wx");
  if (err) {
   return err;
  }
  if (isdir) {
   if (!FS.isDir(node.mode)) {
    return 20;
   }
   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
    return 16;
   }
  } else {
   if (FS.isDir(node.mode)) {
    return 21;
   }
  }
  return 0;
 }),
 mayOpen: (function(node, flags) {
  if (!node) {
   return 2;
  }
  if (FS.isLink(node.mode)) {
   return 40;
  } else if (FS.isDir(node.mode)) {
   if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
    return 21;
   }
  }
  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
 }),
 MAX_OPEN_FDS: 4096,
 nextfd: (function(fd_start, fd_end) {
  fd_start = fd_start || 0;
  fd_end = fd_end || FS.MAX_OPEN_FDS;
  for (var fd = fd_start; fd <= fd_end; fd++) {
   if (!FS.streams[fd]) {
    return fd;
   }
  }
  throw new FS.ErrnoError(24);
 }),
 getStream: (function(fd) {
  return FS.streams[fd];
 }),
 createStream: (function(stream, fd_start, fd_end) {
  if (!FS.FSStream) {
   FS.FSStream = (function() {});
   FS.FSStream.prototype = {};
   Object.defineProperties(FS.FSStream.prototype, {
    object: {
     get: (function() {
      return this.node;
     }),
     set: (function(val) {
      this.node = val;
     })
    },
    isRead: {
     get: (function() {
      return (this.flags & 2097155) !== 1;
     })
    },
    isWrite: {
     get: (function() {
      return (this.flags & 2097155) !== 0;
     })
    },
    isAppend: {
     get: (function() {
      return this.flags & 1024;
     })
    }
   });
  }
  var newStream = new FS.FSStream;
  for (var p in stream) {
   newStream[p] = stream[p];
  }
  stream = newStream;
  var fd = FS.nextfd(fd_start, fd_end);
  stream.fd = fd;
  FS.streams[fd] = stream;
  return stream;
 }),
 closeStream: (function(fd) {
  FS.streams[fd] = null;
 }),
 chrdev_stream_ops: {
  open: (function(stream) {
   var device = FS.getDevice(stream.node.rdev);
   stream.stream_ops = device.stream_ops;
   if (stream.stream_ops.open) {
    stream.stream_ops.open(stream);
   }
  }),
  llseek: (function() {
   throw new FS.ErrnoError(29);
  })
 },
 major: (function(dev) {
  return dev >> 8;
 }),
 minor: (function(dev) {
  return dev & 255;
 }),
 makedev: (function(ma, mi) {
  return ma << 8 | mi;
 }),
 registerDevice: (function(dev, ops) {
  FS.devices[dev] = {
   stream_ops: ops
  };
 }),
 getDevice: (function(dev) {
  return FS.devices[dev];
 }),
 getMounts: (function(mount) {
  var mounts = [];
  var check = [ mount ];
  while (check.length) {
   var m = check.pop();
   mounts.push(m);
   check.push.apply(check, m.mounts);
  }
  return mounts;
 }),
 syncfs: (function(populate, callback) {
  if (typeof populate === "function") {
   callback = populate;
   populate = false;
  }
  FS.syncFSRequests++;
  if (FS.syncFSRequests > 1) {
   console.log("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
  }
  var mounts = FS.getMounts(FS.root.mount);
  var completed = 0;
  function doCallback(err) {
   assert(FS.syncFSRequests > 0);
   FS.syncFSRequests--;
   return callback(err);
  }
  function done(err) {
   if (err) {
    if (!done.errored) {
     done.errored = true;
     return doCallback(err);
    }
    return;
   }
   if (++completed >= mounts.length) {
    doCallback(null);
   }
  }
  mounts.forEach((function(mount) {
   if (!mount.type.syncfs) {
    return done(null);
   }
   mount.type.syncfs(mount, populate, done);
  }));
 }),
 mount: (function(type, opts, mountpoint) {
  var root = mountpoint === "/";
  var pseudo = !mountpoint;
  var node;
  if (root && FS.root) {
   throw new FS.ErrnoError(16);
  } else if (!root && !pseudo) {
   var lookup = FS.lookupPath(mountpoint, {
    follow_mount: false
   });
   mountpoint = lookup.path;
   node = lookup.node;
   if (FS.isMountpoint(node)) {
    throw new FS.ErrnoError(16);
   }
   if (!FS.isDir(node.mode)) {
    throw new FS.ErrnoError(20);
   }
  }
  var mount = {
   type: type,
   opts: opts,
   mountpoint: mountpoint,
   mounts: []
  };
  var mountRoot = type.mount(mount);
  mountRoot.mount = mount;
  mount.root = mountRoot;
  if (root) {
   FS.root = mountRoot;
  } else if (node) {
   node.mounted = mount;
   if (node.mount) {
    node.mount.mounts.push(mount);
   }
  }
  return mountRoot;
 }),
 unmount: (function(mountpoint) {
  var lookup = FS.lookupPath(mountpoint, {
   follow_mount: false
  });
  if (!FS.isMountpoint(lookup.node)) {
   throw new FS.ErrnoError(22);
  }
  var node = lookup.node;
  var mount = node.mounted;
  var mounts = FS.getMounts(mount);
  Object.keys(FS.nameTable).forEach((function(hash) {
   var current = FS.nameTable[hash];
   while (current) {
    var next = current.name_next;
    if (mounts.indexOf(current.mount) !== -1) {
     FS.destroyNode(current);
    }
    current = next;
   }
  }));
  node.mounted = null;
  var idx = node.mount.mounts.indexOf(mount);
  assert(idx !== -1);
  node.mount.mounts.splice(idx, 1);
 }),
 lookup: (function(parent, name) {
  return parent.node_ops.lookup(parent, name);
 }),
 mknod: (function(path, mode, dev) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  if (!name || name === "." || name === "..") {
   throw new FS.ErrnoError(22);
  }
  var err = FS.mayCreate(parent, name);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.mknod) {
   throw new FS.ErrnoError(1);
  }
  return parent.node_ops.mknod(parent, name, mode, dev);
 }),
 create: (function(path, mode) {
  mode = mode !== undefined ? mode : 438;
  mode &= 4095;
  mode |= 32768;
  return FS.mknod(path, mode, 0);
 }),
 mkdir: (function(path, mode) {
  mode = mode !== undefined ? mode : 511;
  mode &= 511 | 512;
  mode |= 16384;
  return FS.mknod(path, mode, 0);
 }),
 mkdirTree: (function(path, mode) {
  var dirs = path.split("/");
  var d = "";
  for (var i = 0; i < dirs.length; ++i) {
   if (!dirs[i]) continue;
   d += "/" + dirs[i];
   try {
    FS.mkdir(d, mode);
   } catch (e) {
    if (e.errno != 17) throw e;
   }
  }
 }),
 mkdev: (function(path, mode, dev) {
  if (typeof dev === "undefined") {
   dev = mode;
   mode = 438;
  }
  mode |= 8192;
  return FS.mknod(path, mode, dev);
 }),
 symlink: (function(oldpath, newpath) {
  if (!PATH_FS.resolve(oldpath)) {
   throw new FS.ErrnoError(2);
  }
  var lookup = FS.lookupPath(newpath, {
   parent: true
  });
  var parent = lookup.node;
  if (!parent) {
   throw new FS.ErrnoError(2);
  }
  var newname = PATH.basename(newpath);
  var err = FS.mayCreate(parent, newname);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.symlink) {
   throw new FS.ErrnoError(1);
  }
  return parent.node_ops.symlink(parent, newname, oldpath);
 }),
 rename: (function(old_path, new_path) {
  var old_dirname = PATH.dirname(old_path);
  var new_dirname = PATH.dirname(new_path);
  var old_name = PATH.basename(old_path);
  var new_name = PATH.basename(new_path);
  var lookup, old_dir, new_dir;
  try {
   lookup = FS.lookupPath(old_path, {
    parent: true
   });
   old_dir = lookup.node;
   lookup = FS.lookupPath(new_path, {
    parent: true
   });
   new_dir = lookup.node;
  } catch (e) {
   throw new FS.ErrnoError(16);
  }
  if (!old_dir || !new_dir) throw new FS.ErrnoError(2);
  if (old_dir.mount !== new_dir.mount) {
   throw new FS.ErrnoError(18);
  }
  var old_node = FS.lookupNode(old_dir, old_name);
  var relative = PATH_FS.relative(old_path, new_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(22);
  }
  relative = PATH_FS.relative(new_path, old_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(39);
  }
  var new_node;
  try {
   new_node = FS.lookupNode(new_dir, new_name);
  } catch (e) {}
  if (old_node === new_node) {
   return;
  }
  var isdir = FS.isDir(old_node.mode);
  var err = FS.mayDelete(old_dir, old_name, isdir);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!old_dir.node_ops.rename) {
   throw new FS.ErrnoError(1);
  }
  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
   throw new FS.ErrnoError(16);
  }
  if (new_dir !== old_dir) {
   err = FS.nodePermissions(old_dir, "w");
   if (err) {
    throw new FS.ErrnoError(err);
   }
  }
  try {
   if (FS.trackingDelegate["willMovePath"]) {
    FS.trackingDelegate["willMovePath"](old_path, new_path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
  }
  FS.hashRemoveNode(old_node);
  try {
   old_dir.node_ops.rename(old_node, new_dir, new_name);
  } catch (e) {
   throw e;
  } finally {
   FS.hashAddNode(old_node);
  }
  try {
   if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path);
  } catch (e) {
   console.log("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
  }
 }),
 rmdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var err = FS.mayDelete(parent, name, true);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.rmdir) {
   throw new FS.ErrnoError(1);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(16);
  }
  try {
   if (FS.trackingDelegate["willDeletePath"]) {
    FS.trackingDelegate["willDeletePath"](path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
  }
  parent.node_ops.rmdir(parent, name);
  FS.destroyNode(node);
  try {
   if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
  } catch (e) {
   console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
  }
 }),
 readdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  if (!node.node_ops.readdir) {
   throw new FS.ErrnoError(20);
  }
  return node.node_ops.readdir(node);
 }),
 unlink: (function(path) {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var err = FS.mayDelete(parent, name, false);
  if (err) {
   throw new FS.ErrnoError(err);
  }
  if (!parent.node_ops.unlink) {
   throw new FS.ErrnoError(1);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(16);
  }
  try {
   if (FS.trackingDelegate["willDeletePath"]) {
    FS.trackingDelegate["willDeletePath"](path);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
  }
  parent.node_ops.unlink(parent, name);
  FS.destroyNode(node);
  try {
   if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
  } catch (e) {
   console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
  }
 }),
 readlink: (function(path) {
  var lookup = FS.lookupPath(path);
  var link = lookup.node;
  if (!link) {
   throw new FS.ErrnoError(2);
  }
  if (!link.node_ops.readlink) {
   throw new FS.ErrnoError(22);
  }
  return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
 }),
 stat: (function(path, dontFollow) {
  var lookup = FS.lookupPath(path, {
   follow: !dontFollow
  });
  var node = lookup.node;
  if (!node) {
   throw new FS.ErrnoError(2);
  }
  if (!node.node_ops.getattr) {
   throw new FS.ErrnoError(1);
  }
  return node.node_ops.getattr(node);
 }),
 lstat: (function(path) {
  return FS.stat(path, true);
 }),
 chmod: (function(path, mode, dontFollow) {
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(1);
  }
  node.node_ops.setattr(node, {
   mode: mode & 4095 | node.mode & ~4095,
   timestamp: Date.now()
  });
 }),
 lchmod: (function(path, mode) {
  FS.chmod(path, mode, true);
 }),
 fchmod: (function(fd, mode) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(9);
  }
  FS.chmod(stream.node, mode);
 }),
 chown: (function(path, uid, gid, dontFollow) {
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(1);
  }
  node.node_ops.setattr(node, {
   timestamp: Date.now()
  });
 }),
 lchown: (function(path, uid, gid) {
  FS.chown(path, uid, gid, true);
 }),
 fchown: (function(fd, uid, gid) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(9);
  }
  FS.chown(stream.node, uid, gid);
 }),
 truncate: (function(path, len) {
  if (len < 0) {
   throw new FS.ErrnoError(22);
  }
  var node;
  if (typeof path === "string") {
   var lookup = FS.lookupPath(path, {
    follow: true
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(1);
  }
  if (FS.isDir(node.mode)) {
   throw new FS.ErrnoError(21);
  }
  if (!FS.isFile(node.mode)) {
   throw new FS.ErrnoError(22);
  }
  var err = FS.nodePermissions(node, "w");
  if (err) {
   throw new FS.ErrnoError(err);
  }
  node.node_ops.setattr(node, {
   size: len,
   timestamp: Date.now()
  });
 }),
 ftruncate: (function(fd, len) {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(9);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(22);
  }
  FS.truncate(stream.node, len);
 }),
 utime: (function(path, atime, mtime) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  node.node_ops.setattr(node, {
   timestamp: Math.max(atime, mtime)
  });
 }),
 open: (function(path, flags, mode, fd_start, fd_end) {
  if (path === "") {
   throw new FS.ErrnoError(2);
  }
  flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
  mode = typeof mode === "undefined" ? 438 : mode;
  if (flags & 64) {
   mode = mode & 4095 | 32768;
  } else {
   mode = 0;
  }
  var node;
  if (typeof path === "object") {
   node = path;
  } else {
   path = PATH.normalize(path);
   try {
    var lookup = FS.lookupPath(path, {
     follow: !(flags & 131072)
    });
    node = lookup.node;
   } catch (e) {}
  }
  var created = false;
  if (flags & 64) {
   if (node) {
    if (flags & 128) {
     throw new FS.ErrnoError(17);
    }
   } else {
    node = FS.mknod(path, mode, 0);
    created = true;
   }
  }
  if (!node) {
   throw new FS.ErrnoError(2);
  }
  if (FS.isChrdev(node.mode)) {
   flags &= ~512;
  }
  if (flags & 65536 && !FS.isDir(node.mode)) {
   throw new FS.ErrnoError(20);
  }
  if (!created) {
   var err = FS.mayOpen(node, flags);
   if (err) {
    throw new FS.ErrnoError(err);
   }
  }
  if (flags & 512) {
   FS.truncate(node, 0);
  }
  flags &= ~(128 | 512);
  var stream = FS.createStream({
   node: node,
   path: FS.getPath(node),
   flags: flags,
   seekable: true,
   position: 0,
   stream_ops: node.stream_ops,
   ungotten: [],
   error: false
  }, fd_start, fd_end);
  if (stream.stream_ops.open) {
   stream.stream_ops.open(stream);
  }
  if (Module["logReadFiles"] && !(flags & 1)) {
   if (!FS.readFiles) FS.readFiles = {};
   if (!(path in FS.readFiles)) {
    FS.readFiles[path] = 1;
    console.log("FS.trackingDelegate error on read file: " + path);
   }
  }
  try {
   if (FS.trackingDelegate["onOpenFile"]) {
    var trackingFlags = 0;
    if ((flags & 2097155) !== 1) {
     trackingFlags |= FS.tracking.openFlags.READ;
    }
    if ((flags & 2097155) !== 0) {
     trackingFlags |= FS.tracking.openFlags.WRITE;
    }
    FS.trackingDelegate["onOpenFile"](path, trackingFlags);
   }
  } catch (e) {
   console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
  }
  return stream;
 }),
 close: (function(stream) {
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(9);
  }
  if (stream.getdents) stream.getdents = null;
  try {
   if (stream.stream_ops.close) {
    stream.stream_ops.close(stream);
   }
  } catch (e) {
   throw e;
  } finally {
   FS.closeStream(stream.fd);
  }
  stream.fd = null;
 }),
 isClosed: (function(stream) {
  return stream.fd === null;
 }),
 llseek: (function(stream, offset, whence) {
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(9);
  }
  if (!stream.seekable || !stream.stream_ops.llseek) {
   throw new FS.ErrnoError(29);
  }
  if (whence != 0 && whence != 1 && whence != 2) {
   throw new FS.ErrnoError(22);
  }
  stream.position = stream.stream_ops.llseek(stream, offset, whence);
  stream.ungotten = [];
  return stream.position;
 }),
 read: (function(stream, buffer, offset, length, position) {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(22);
  }
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(9);
  }
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(9);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(21);
  }
  if (!stream.stream_ops.read) {
   throw new FS.ErrnoError(22);
  }
  var seeking = typeof position !== "undefined";
  if (!seeking) {
   position = stream.position;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(29);
  }
  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
  if (!seeking) stream.position += bytesRead;
  return bytesRead;
 }),
 write: (function(stream, buffer, offset, length, position, canOwn) {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(22);
  }
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(9);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(9);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(21);
  }
  if (!stream.stream_ops.write) {
   throw new FS.ErrnoError(22);
  }
  if (stream.flags & 1024) {
   FS.llseek(stream, 0, 2);
  }
  var seeking = typeof position !== "undefined";
  if (!seeking) {
   position = stream.position;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(29);
  }
  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
  if (!seeking) stream.position += bytesWritten;
  try {
   if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path);
  } catch (e) {
   console.log("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
  }
  return bytesWritten;
 }),
 allocate: (function(stream, offset, length) {
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(9);
  }
  if (offset < 0 || length <= 0) {
   throw new FS.ErrnoError(22);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(9);
  }
  if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(19);
  }
  if (!stream.stream_ops.allocate) {
   throw new FS.ErrnoError(95);
  }
  stream.stream_ops.allocate(stream, offset, length);
 }),
 mmap: (function(stream, buffer, offset, length, position, prot, flags) {
  if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
   throw new FS.ErrnoError(13);
  }
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(13);
  }
  if (!stream.stream_ops.mmap) {
   throw new FS.ErrnoError(19);
  }
  return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
 }),
 msync: (function(stream, buffer, offset, length, mmapFlags) {
  if (!stream || !stream.stream_ops.msync) {
   return 0;
  }
  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
 }),
 munmap: (function(stream) {
  return 0;
 }),
 ioctl: (function(stream, cmd, arg) {
  if (!stream.stream_ops.ioctl) {
   throw new FS.ErrnoError(25);
  }
  return stream.stream_ops.ioctl(stream, cmd, arg);
 }),
 readFile: (function(path, opts) {
  opts = opts || {};
  opts.flags = opts.flags || "r";
  opts.encoding = opts.encoding || "binary";
  if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
   throw new Error('Invalid encoding type "' + opts.encoding + '"');
  }
  var ret;
  var stream = FS.open(path, opts.flags);
  var stat = FS.stat(path);
  var length = stat.size;
  var buf = new Uint8Array(length);
  FS.read(stream, buf, 0, length, 0);
  if (opts.encoding === "utf8") {
   ret = UTF8ArrayToString(buf, 0);
  } else if (opts.encoding === "binary") {
   ret = buf;
  }
  FS.close(stream);
  return ret;
 }),
 writeFile: (function(path, data, opts) {
  opts = opts || {};
  opts.flags = opts.flags || "w";
  var stream = FS.open(path, opts.flags, opts.mode);
  if (typeof data === "string") {
   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
   FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
  } else if (ArrayBuffer.isView(data)) {
   FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
  } else {
   throw new Error("Unsupported data type");
  }
  FS.close(stream);
 }),
 cwd: (function() {
  return FS.currentPath;
 }),
 chdir: (function(path) {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  if (lookup.node === null) {
   throw new FS.ErrnoError(2);
  }
  if (!FS.isDir(lookup.node.mode)) {
   throw new FS.ErrnoError(20);
  }
  var err = FS.nodePermissions(lookup.node, "x");
  if (err) {
   throw new FS.ErrnoError(err);
  }
  FS.currentPath = lookup.path;
 }),
 createDefaultDirectories: (function() {
  FS.mkdir("/tmp");
  FS.mkdir("/home");
  FS.mkdir("/home/web_user");
 }),
 createDefaultDevices: (function() {
  FS.mkdir("/dev");
  FS.registerDevice(FS.makedev(1, 3), {
   read: (function() {
    return 0;
   }),
   write: (function(stream, buffer, offset, length, pos) {
    return length;
   })
  });
  FS.mkdev("/dev/null", FS.makedev(1, 3));
  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
  FS.mkdev("/dev/tty", FS.makedev(5, 0));
  FS.mkdev("/dev/tty1", FS.makedev(6, 0));
  var random_device;
  if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
   var randomBuffer = new Uint8Array(1);
   random_device = (function() {
    crypto.getRandomValues(randomBuffer);
    return randomBuffer[0];
   });
  } else if (ENVIRONMENT_IS_NODE) {
   try {
    var crypto_module = require("crypto");
    random_device = (function() {
     return crypto_module["randomBytes"](1)[0];
    });
   } catch (e) {}
  } else {}
  if (!random_device) {
   random_device = (function() {
    abort("no cryptographic support found for random_device. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
   });
  }
  FS.createDevice("/dev", "random", random_device);
  FS.createDevice("/dev", "urandom", random_device);
  FS.mkdir("/dev/shm");
  FS.mkdir("/dev/shm/tmp");
 }),
 createSpecialDirectories: (function() {
  FS.mkdir("/proc");
  FS.mkdir("/proc/self");
  FS.mkdir("/proc/self/fd");
  FS.mount({
   mount: (function() {
    var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
    node.node_ops = {
     lookup: (function(parent, name) {
      var fd = +name;
      var stream = FS.getStream(fd);
      if (!stream) throw new FS.ErrnoError(9);
      var ret = {
       parent: null,
       mount: {
        mountpoint: "fake"
       },
       node_ops: {
        readlink: (function() {
         return stream.path;
        })
       }
      };
      ret.parent = ret;
      return ret;
     })
    };
    return node;
   })
  }, {}, "/proc/self/fd");
 }),
 createStandardStreams: (function() {
  if (Module["stdin"]) {
   FS.createDevice("/dev", "stdin", Module["stdin"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdin");
  }
  if (Module["stdout"]) {
   FS.createDevice("/dev", "stdout", null, Module["stdout"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdout");
  }
  if (Module["stderr"]) {
   FS.createDevice("/dev", "stderr", null, Module["stderr"]);
  } else {
   FS.symlink("/dev/tty1", "/dev/stderr");
  }
  var stdin = FS.open("/dev/stdin", "r");
  var stdout = FS.open("/dev/stdout", "w");
  var stderr = FS.open("/dev/stderr", "w");
  assert(stdin.fd === 0, "invalid handle for stdin (" + stdin.fd + ")");
  assert(stdout.fd === 1, "invalid handle for stdout (" + stdout.fd + ")");
  assert(stderr.fd === 2, "invalid handle for stderr (" + stderr.fd + ")");
 }),
 ensureErrnoError: (function() {
  if (FS.ErrnoError) return;
  FS.ErrnoError = function ErrnoError(errno, node) {
   this.node = node;
   this.setErrno = (function(errno) {
    this.errno = errno;
    for (var key in ERRNO_CODES) {
     if (ERRNO_CODES[key] === errno) {
      this.code = key;
      break;
     }
    }
   });
   this.setErrno(errno);
   this.message = ERRNO_MESSAGES[errno];
   if (this.stack) Object.defineProperty(this, "stack", {
    value: (new Error).stack,
    writable: true
   });
   if (this.stack) this.stack = demangleAll(this.stack);
  };
  FS.ErrnoError.prototype = new Error;
  FS.ErrnoError.prototype.constructor = FS.ErrnoError;
  [ 2 ].forEach((function(code) {
   FS.genericErrors[code] = new FS.ErrnoError(code);
   FS.genericErrors[code].stack = "<generic error, no stack>";
  }));
 }),
 staticInit: (function() {
  FS.ensureErrnoError();
  FS.nameTable = new Array(4096);
  FS.mount(MEMFS, {}, "/");
  FS.createDefaultDirectories();
  FS.createDefaultDevices();
  FS.createSpecialDirectories();
  FS.filesystems = {
   "MEMFS": MEMFS,
   "IDBFS": IDBFS,
   "NODEFS": NODEFS,
   "WORKERFS": WORKERFS
  };
 }),
 init: (function(input, output, error) {
  assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
  FS.init.initialized = true;
  FS.ensureErrnoError();
  Module["stdin"] = input || Module["stdin"];
  Module["stdout"] = output || Module["stdout"];
  Module["stderr"] = error || Module["stderr"];
  FS.createStandardStreams();
 }),
 quit: (function() {
  FS.init.initialized = false;
  var fflush = Module["_fflush"];
  if (fflush) fflush(0);
  for (var i = 0; i < FS.streams.length; i++) {
   var stream = FS.streams[i];
   if (!stream) {
    continue;
   }
   FS.close(stream);
  }
 }),
 getMode: (function(canRead, canWrite) {
  var mode = 0;
  if (canRead) mode |= 292 | 73;
  if (canWrite) mode |= 146;
  return mode;
 }),
 joinPath: (function(parts, forceRelative) {
  var path = PATH.join.apply(null, parts);
  if (forceRelative && path[0] == "/") path = path.substr(1);
  return path;
 }),
 absolutePath: (function(relative, base) {
  return PATH_FS.resolve(base, relative);
 }),
 standardizePath: (function(path) {
  return PATH.normalize(path);
 }),
 findObject: (function(path, dontResolveLastLink) {
  var ret = FS.analyzePath(path, dontResolveLastLink);
  if (ret.exists) {
   return ret.object;
  } else {
   ___setErrNo(ret.error);
   return null;
  }
 }),
 analyzePath: (function(path, dontResolveLastLink) {
  try {
   var lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   path = lookup.path;
  } catch (e) {}
  var ret = {
   isRoot: false,
   exists: false,
   error: 0,
   name: null,
   path: null,
   object: null,
   parentExists: false,
   parentPath: null,
   parentObject: null
  };
  try {
   var lookup = FS.lookupPath(path, {
    parent: true
   });
   ret.parentExists = true;
   ret.parentPath = lookup.path;
   ret.parentObject = lookup.node;
   ret.name = PATH.basename(path);
   lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   ret.exists = true;
   ret.path = lookup.path;
   ret.object = lookup.node;
   ret.name = lookup.node.name;
   ret.isRoot = lookup.path === "/";
  } catch (e) {
   ret.error = e.errno;
  }
  return ret;
 }),
 createFolder: (function(parent, name, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(canRead, canWrite);
  return FS.mkdir(path, mode);
 }),
 createPath: (function(parent, path, canRead, canWrite) {
  parent = typeof parent === "string" ? parent : FS.getPath(parent);
  var parts = path.split("/").reverse();
  while (parts.length) {
   var part = parts.pop();
   if (!part) continue;
   var current = PATH.join2(parent, part);
   try {
    FS.mkdir(current);
   } catch (e) {}
   parent = current;
  }
  return current;
 }),
 createFile: (function(parent, name, properties, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(canRead, canWrite);
  return FS.create(path, mode);
 }),
 createDataFile: (function(parent, name, data, canRead, canWrite, canOwn) {
  var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
  var mode = FS.getMode(canRead, canWrite);
  var node = FS.create(path, mode);
  if (data) {
   if (typeof data === "string") {
    var arr = new Array(data.length);
    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
    data = arr;
   }
   FS.chmod(node, mode | 146);
   var stream = FS.open(node, "w");
   FS.write(stream, data, 0, data.length, 0, canOwn);
   FS.close(stream);
   FS.chmod(node, mode);
  }
  return node;
 }),
 createDevice: (function(parent, name, input, output) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(!!input, !!output);
  if (!FS.createDevice.major) FS.createDevice.major = 64;
  var dev = FS.makedev(FS.createDevice.major++, 0);
  FS.registerDevice(dev, {
   open: (function(stream) {
    stream.seekable = false;
   }),
   close: (function(stream) {
    if (output && output.buffer && output.buffer.length) {
     output(10);
    }
   }),
   read: (function(stream, buffer, offset, length, pos) {
    var bytesRead = 0;
    for (var i = 0; i < length; i++) {
     var result;
     try {
      result = input();
     } catch (e) {
      throw new FS.ErrnoError(5);
     }
     if (result === undefined && bytesRead === 0) {
      throw new FS.ErrnoError(11);
     }
     if (result === null || result === undefined) break;
     bytesRead++;
     buffer[offset + i] = result;
    }
    if (bytesRead) {
     stream.node.timestamp = Date.now();
    }
    return bytesRead;
   }),
   write: (function(stream, buffer, offset, length, pos) {
    for (var i = 0; i < length; i++) {
     try {
      output(buffer[offset + i]);
     } catch (e) {
      throw new FS.ErrnoError(5);
     }
    }
    if (length) {
     stream.node.timestamp = Date.now();
    }
    return i;
   })
  });
  return FS.mkdev(path, mode, dev);
 }),
 createLink: (function(parent, name, target, canRead, canWrite) {
  var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
  return FS.symlink(target, path);
 }),
 forceLoadFile: (function(obj) {
  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
  var success = true;
  if (typeof XMLHttpRequest !== "undefined") {
   throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
  } else if (read_) {
   try {
    obj.contents = intArrayFromString(read_(obj.url), true);
    obj.usedBytes = obj.contents.length;
   } catch (e) {
    success = false;
   }
  } else {
   throw new Error("Cannot load without read() or XMLHttpRequest.");
  }
  if (!success) ___setErrNo(5);
  return success;
 }),
 createLazyFile: (function(parent, name, url, canRead, canWrite) {
  function LazyUint8Array() {
   this.lengthKnown = false;
   this.chunks = [];
  }
  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
   if (idx > this.length - 1 || idx < 0) {
    return undefined;
   }
   var chunkOffset = idx % this.chunkSize;
   var chunkNum = idx / this.chunkSize | 0;
   return this.getter(chunkNum)[chunkOffset];
  };
  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
   this.getter = getter;
  };
  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
   var xhr = new XMLHttpRequest;
   xhr.open("HEAD", url, false);
   xhr.send(null);
   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
   var datalength = Number(xhr.getResponseHeader("Content-length"));
   var header;
   var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
   var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
   var chunkSize = 1024 * 1024;
   if (!hasByteServing) chunkSize = datalength;
   var doXHR = (function(from, to) {
    if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
    if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
    var xhr = new XMLHttpRequest;
    xhr.open("GET", url, false);
    if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
    if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";
    if (xhr.overrideMimeType) {
     xhr.overrideMimeType("text/plain; charset=x-user-defined");
    }
    xhr.send(null);
    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
    if (xhr.response !== undefined) {
     return new Uint8Array(xhr.response || []);
    } else {
     return intArrayFromString(xhr.responseText || "", true);
    }
   });
   var lazyArray = this;
   lazyArray.setDataGetter((function(chunkNum) {
    var start = chunkNum * chunkSize;
    var end = (chunkNum + 1) * chunkSize - 1;
    end = Math.min(end, datalength - 1);
    if (typeof lazyArray.chunks[chunkNum] === "undefined") {
     lazyArray.chunks[chunkNum] = doXHR(start, end);
    }
    if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");
    return lazyArray.chunks[chunkNum];
   }));
   if (usesGzip || !datalength) {
    chunkSize = datalength = 1;
    datalength = this.getter(0).length;
    chunkSize = datalength;
    console.log("LazyFiles on gzip forces download of the whole file when length is accessed");
   }
   this._length = datalength;
   this._chunkSize = chunkSize;
   this.lengthKnown = true;
  };
  if (typeof XMLHttpRequest !== "undefined") {
   if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
   var lazyArray = new LazyUint8Array;
   Object.defineProperties(lazyArray, {
    length: {
     get: (function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._length;
     })
    },
    chunkSize: {
     get: (function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._chunkSize;
     })
    }
   });
   var properties = {
    isDevice: false,
    contents: lazyArray
   };
  } else {
   var properties = {
    isDevice: false,
    url: url
   };
  }
  var node = FS.createFile(parent, name, properties, canRead, canWrite);
  if (properties.contents) {
   node.contents = properties.contents;
  } else if (properties.url) {
   node.contents = null;
   node.url = properties.url;
  }
  Object.defineProperties(node, {
   usedBytes: {
    get: (function() {
     return this.contents.length;
    })
   }
  });
  var stream_ops = {};
  var keys = Object.keys(node.stream_ops);
  keys.forEach((function(key) {
   var fn = node.stream_ops[key];
   stream_ops[key] = function forceLoadLazyFile() {
    if (!FS.forceLoadFile(node)) {
     throw new FS.ErrnoError(5);
    }
    return fn.apply(null, arguments);
   };
  }));
  stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
   if (!FS.forceLoadFile(node)) {
    throw new FS.ErrnoError(5);
   }
   var contents = stream.node.contents;
   if (position >= contents.length) return 0;
   var size = Math.min(contents.length - position, length);
   assert(size >= 0);
   if (contents.slice) {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents[position + i];
    }
   } else {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents.get(position + i);
    }
   }
   return size;
  };
  node.stream_ops = stream_ops;
  return node;
 }),
 createPreloadedFile: (function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
  Browser.init();
  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
  var dep = getUniqueRunDependency("cp " + fullname);
  function processData(byteArray) {
   function finish(byteArray) {
    if (preFinish) preFinish();
    if (!dontCreateFile) {
     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
    }
    if (onload) onload();
    removeRunDependency(dep);
   }
   var handled = false;
   Module["preloadPlugins"].forEach((function(plugin) {
    if (handled) return;
    if (plugin["canHandle"](fullname)) {
     plugin["handle"](byteArray, fullname, finish, (function() {
      if (onerror) onerror();
      removeRunDependency(dep);
     }));
     handled = true;
    }
   }));
   if (!handled) finish(byteArray);
  }
  addRunDependency(dep);
  if (typeof url == "string") {
   Browser.asyncLoad(url, (function(byteArray) {
    processData(byteArray);
   }), onerror);
  } else {
   processData(url);
  }
 }),
 indexedDB: (function() {
  return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
 }),
 DB_NAME: (function() {
  return "EM_FS_" + window.location.pathname;
 }),
 DB_VERSION: 20,
 DB_STORE_NAME: "FILE_DATA",
 saveFilesToDB: (function(paths, onload, onerror) {
  onload = onload || (function() {});
  onerror = onerror || (function() {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
   console.log("creating db");
   var db = openRequest.result;
   db.createObjectStore(FS.DB_STORE_NAME);
  };
  openRequest.onsuccess = function openRequest_onsuccess() {
   var db = openRequest.result;
   var transaction = db.transaction([ FS.DB_STORE_NAME ], "readwrite");
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach((function(path) {
    var putRequest = files.put(FS.analyzePath(path).object.contents, path);
    putRequest.onsuccess = function putRequest_onsuccess() {
     ok++;
     if (ok + fail == total) finish();
    };
    putRequest.onerror = function putRequest_onerror() {
     fail++;
     if (ok + fail == total) finish();
    };
   }));
   transaction.onerror = onerror;
  };
  openRequest.onerror = onerror;
 }),
 loadFilesFromDB: (function(paths, onload, onerror) {
  onload = onload || (function() {});
  onerror = onerror || (function() {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = onerror;
  openRequest.onsuccess = function openRequest_onsuccess() {
   var db = openRequest.result;
   try {
    var transaction = db.transaction([ FS.DB_STORE_NAME ], "readonly");
   } catch (e) {
    onerror(e);
    return;
   }
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach((function(path) {
    var getRequest = files.get(path);
    getRequest.onsuccess = function getRequest_onsuccess() {
     if (FS.analyzePath(path).exists) {
      FS.unlink(path);
     }
     FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
     ok++;
     if (ok + fail == total) finish();
    };
    getRequest.onerror = function getRequest_onerror() {
     fail++;
     if (ok + fail == total) finish();
    };
   }));
   transaction.onerror = onerror;
  };
  openRequest.onerror = onerror;
 })
};
Module["FS"] = FS;
var SYSCALLS = {
 DEFAULT_POLLMASK: 5,
 mappings: {},
 umask: 511,
 calculateAt: (function(dirfd, path) {
  if (path[0] !== "/") {
   var dir;
   if (dirfd === -100) {
    dir = FS.cwd();
   } else {
    var dirstream = FS.getStream(dirfd);
    if (!dirstream) throw new FS.ErrnoError(9);
    dir = dirstream.path;
   }
   path = PATH.join2(dir, path);
  }
  return path;
 }),
 doStat: (function(func, path, buf) {
  try {
   var stat = func(path);
  } catch (e) {
   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
    return -20;
   }
   throw e;
  }
  GROWABLE_HEAP_STORE_I32(buf | 0, stat.dev);
  GROWABLE_HEAP_STORE_I32(buf + 4 | 0, 0);
  GROWABLE_HEAP_STORE_I32(buf + 8 | 0, stat.ino);
  GROWABLE_HEAP_STORE_I32(buf + 12 | 0, stat.mode);
  GROWABLE_HEAP_STORE_I32(buf + 16 | 0, stat.nlink);
  GROWABLE_HEAP_STORE_I32(buf + 20 | 0, stat.uid);
  GROWABLE_HEAP_STORE_I32(buf + 24 | 0, stat.gid);
  GROWABLE_HEAP_STORE_I32(buf + 28 | 0, stat.rdev);
  GROWABLE_HEAP_STORE_I32(buf + 32 | 0, 0);
  tempI64 = [ stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], GROWABLE_HEAP_STORE_I32(buf + 40 | 0, tempI64[0]), GROWABLE_HEAP_STORE_I32(buf + 44 | 0, tempI64[1]);
  GROWABLE_HEAP_STORE_I32(buf + 48 | 0, 4096);
  GROWABLE_HEAP_STORE_I32(buf + 52 | 0, stat.blocks);
  GROWABLE_HEAP_STORE_I32(buf + 56 | 0, stat.atime.getTime() / 1e3 | 0);
  GROWABLE_HEAP_STORE_I32(buf + 60 | 0, 0);
  GROWABLE_HEAP_STORE_I32(buf + 64 | 0, stat.mtime.getTime() / 1e3 | 0);
  GROWABLE_HEAP_STORE_I32(buf + 68 | 0, 0);
  GROWABLE_HEAP_STORE_I32(buf + 72 | 0, stat.ctime.getTime() / 1e3 | 0);
  GROWABLE_HEAP_STORE_I32(buf + 76 | 0, 0);
  tempI64 = [ stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], GROWABLE_HEAP_STORE_I32(buf + 80 | 0, tempI64[0]), GROWABLE_HEAP_STORE_I32(buf + 84 | 0, tempI64[1]);
  return 0;
 }),
 doMsync: (function(addr, stream, len, flags) {
  var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
  FS.msync(stream, buffer, 0, len, flags);
 }),
 doMkdir: (function(path, mode) {
  path = PATH.normalize(path);
  if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
  FS.mkdir(path, mode, 0);
  return 0;
 }),
 doMknod: (function(path, mode, dev) {
  switch (mode & 61440) {
  case 32768:
  case 8192:
  case 24576:
  case 4096:
  case 49152:
   break;
  default:
   return -22;
  }
  FS.mknod(path, mode, dev);
  return 0;
 }),
 doReadlink: (function(path, buf, bufsize) {
  if (bufsize <= 0) return -22;
  var ret = FS.readlink(path);
  var len = Math.min(bufsize, lengthBytesUTF8(ret));
  var endChar = GROWABLE_HEAP_LOAD_I8(buf + len | 0);
  stringToUTF8(ret, buf, bufsize + 1);
  GROWABLE_HEAP_STORE_I8(buf + len | 0, endChar);
  return len;
 }),
 doAccess: (function(path, amode) {
  if (amode & ~7) {
   return -22;
  }
  var node;
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  node = lookup.node;
  if (!node) {
   return -2;
  }
  var perms = "";
  if (amode & 4) perms += "r";
  if (amode & 2) perms += "w";
  if (amode & 1) perms += "x";
  if (perms && FS.nodePermissions(node, perms)) {
   return -13;
  }
  return 0;
 }),
 doDup: (function(path, flags, suggestFD) {
  var suggest = FS.getStream(suggestFD);
  if (suggest) FS.close(suggest);
  return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
 }),
 doReadv: (function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = GROWABLE_HEAP_LOAD_I32(iov + i * 8 | 0);
   var len = GROWABLE_HEAP_LOAD_I32(iov + (i * 8 + 4) | 0);
   var curr = FS.read(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
   if (curr < len) break;
  }
  return ret;
 }),
 doWritev: (function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = GROWABLE_HEAP_LOAD_I32(iov + i * 8 | 0);
   var len = GROWABLE_HEAP_LOAD_I32(iov + (i * 8 + 4) | 0);
   var curr = FS.write(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
  }
  return ret;
 }),
 varargs: 0,
 get: (function(varargs) {
  SYSCALLS.varargs += 4;
  var ret = GROWABLE_HEAP_LOAD_I32(SYSCALLS.varargs - 4 | 0);
  return ret;
 }),
 getStr: (function() {
  var ret = UTF8ToString(SYSCALLS.get());
  return ret;
 }),
 getStreamFromFD: (function() {
  var stream = FS.getStream(SYSCALLS.get());
  if (!stream) throw new FS.ErrnoError(9);
  return stream;
 }),
 get64: (function() {
  var low = SYSCALLS.get(), high = SYSCALLS.get();
  if (low >= 0) assert(high === 0); else assert(high === -1);
  return low;
 }),
 getZero: (function() {
  assert(SYSCALLS.get() === 0);
 })
};
Module["SYSCALLS"] = SYSCALLS;
function ___syscall10(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(1, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var path = SYSCALLS.getStr();
  FS.unlink(path);
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall10"] = ___syscall10;
var SOCKFS = {
 mount: (function(mount) {
  Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {};
  Module["websocket"]._callbacks = {};
  Module["websocket"]["on"] = (function(event, callback) {
   if ("function" === typeof callback) {
    this._callbacks[event] = callback;
   }
   return this;
  });
  Module["websocket"].emit = (function(event, param) {
   if ("function" === typeof this._callbacks[event]) {
    this._callbacks[event].call(this, param);
   }
  });
  return FS.createNode(null, "/", 16384 | 511, 0);
 }),
 createSocket: (function(family, type, protocol) {
  var streaming = type == 1;
  if (protocol) {
   assert(streaming == (protocol == 6));
  }
  var sock = {
   family: family,
   type: type,
   protocol: protocol,
   server: null,
   error: null,
   peers: {},
   pending: [],
   recv_queue: [],
   sock_ops: SOCKFS.websocket_sock_ops
  };
  var name = SOCKFS.nextname();
  var node = FS.createNode(SOCKFS.root, name, 49152, 0);
  node.sock = sock;
  var stream = FS.createStream({
   path: name,
   node: node,
   flags: FS.modeStringToFlags("r+"),
   seekable: false,
   stream_ops: SOCKFS.stream_ops
  });
  sock.stream = stream;
  return sock;
 }),
 getSocket: (function(fd) {
  var stream = FS.getStream(fd);
  if (!stream || !FS.isSocket(stream.node.mode)) {
   return null;
  }
  return stream.node.sock;
 }),
 stream_ops: {
  poll: (function(stream) {
   var sock = stream.node.sock;
   return sock.sock_ops.poll(sock);
  }),
  ioctl: (function(stream, request, varargs) {
   var sock = stream.node.sock;
   return sock.sock_ops.ioctl(sock, request, varargs);
  }),
  read: (function(stream, buffer, offset, length, position) {
   var sock = stream.node.sock;
   var msg = sock.sock_ops.recvmsg(sock, length);
   if (!msg) {
    return 0;
   }
   buffer.set(msg.buffer, offset);
   return msg.buffer.length;
  }),
  write: (function(stream, buffer, offset, length, position) {
   var sock = stream.node.sock;
   return sock.sock_ops.sendmsg(sock, buffer, offset, length);
  }),
  close: (function(stream) {
   var sock = stream.node.sock;
   sock.sock_ops.close(sock);
  })
 },
 nextname: (function() {
  if (!SOCKFS.nextname.current) {
   SOCKFS.nextname.current = 0;
  }
  return "socket[" + SOCKFS.nextname.current++ + "]";
 }),
 websocket_sock_ops: {
  createPeer: (function(sock, addr, port) {
   var ws;
   if (typeof addr === "object") {
    ws = addr;
    addr = null;
    port = null;
   }
   if (ws) {
    if (ws._socket) {
     addr = ws._socket.remoteAddress;
     port = ws._socket.remotePort;
    } else {
     var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
     if (!result) {
      throw new Error("WebSocket URL must be in the format ws(s)://address:port");
     }
     addr = result[1];
     port = parseInt(result[2], 10);
    }
   } else {
    try {
     var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"];
     var url = "ws:#".replace("#", "//");
     if (runtimeConfig) {
      if ("string" === typeof Module["websocket"]["url"]) {
       url = Module["websocket"]["url"];
      }
     }
     if (url === "ws://" || url === "wss://") {
      var parts = addr.split("/");
      url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/");
     }
     var subProtocols = "binary,text,sip";
     if (runtimeConfig) {
      if ("string" === typeof Module["websocket"]["subprotocol"]) {
       subProtocols = Module["websocket"]["subprotocol"];
      }
     }
     subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);
     var opts = ENVIRONMENT_IS_NODE ? {
      "protocol": subProtocols.toString()
     } : subProtocols;
     if (runtimeConfig && null === Module["websocket"]["subprotocol"]) {
      subProtocols = "null";
      opts = undefined;
     }
     var WebSocketConstructor;
     if (ENVIRONMENT_IS_NODE) {
      WebSocketConstructor = require("ws");
     } else if (ENVIRONMENT_IS_WEB) {
      WebSocketConstructor = window["WebSocket"];
     } else {
      WebSocketConstructor = WebSocket;
     }
     ws = new WebSocketConstructor(url, opts);
     ws.binaryType = "arraybuffer";
    } catch (e) {
     throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
    }
   }
   var peer = {
    addr: addr,
    port: port,
    socket: ws,
    dgram_send_queue: []
   };
   SOCKFS.websocket_sock_ops.addPeer(sock, peer);
   SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
   if (sock.type === 2 && typeof sock.sport !== "undefined") {
    peer.dgram_send_queue.push(new Uint8Array([ 255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255 ]));
   }
   return peer;
  }),
  getPeer: (function(sock, addr, port) {
   return sock.peers[addr + ":" + port];
  }),
  addPeer: (function(sock, peer) {
   sock.peers[peer.addr + ":" + peer.port] = peer;
  }),
  removePeer: (function(sock, peer) {
   delete sock.peers[peer.addr + ":" + peer.port];
  }),
  handlePeerEvents: (function(sock, peer) {
   var first = true;
   var handleOpen = (function() {
    Module["websocket"].emit("open", sock.stream.fd);
    try {
     var queued = peer.dgram_send_queue.shift();
     while (queued) {
      peer.socket.send(queued);
      queued = peer.dgram_send_queue.shift();
     }
    } catch (e) {
     peer.socket.close();
    }
   });
   function handleMessage(data) {
    
    //stack_modified...
    if(typeof data === "string" && data.byteLength === undefined)
    {
       var enc = new TextEncoder(); // always utf-8
       data=enc.encode(data);
    }
    assert(typeof data !== "string" && data.byteLength !== undefined);

    if (data.byteLength == 0) {
     return;
    }
    data = new Uint8Array(data);
    var wasfirst = first;
    first = false;
    if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) {
     var newport = data[8] << 8 | data[9];
     SOCKFS.websocket_sock_ops.removePeer(sock, peer);
     peer.port = newport;
     SOCKFS.websocket_sock_ops.addPeer(sock, peer);
     return;
    }
    sock.recv_queue.push({
     addr: peer.addr,
     port: peer.port,
     data: data
    });
    Module["websocket"].emit("message", sock.stream.fd);
   }
   if (ENVIRONMENT_IS_NODE) {
    peer.socket.on("open", handleOpen);
    peer.socket.on("message", (function(data, flags) {
     if (!flags.binary) {
      return;
     }
     handleMessage((new Uint8Array(data)).buffer);
    }));
    peer.socket.on("close", (function() {
     Module["websocket"].emit("close", sock.stream.fd);
    }));
    peer.socket.on("error", (function(error) {
     sock.error = ERRNO_CODES.ECONNREFUSED;
     Module["websocket"].emit("error", [ sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused" ]);
    }));
   } else {
    peer.socket.onopen = handleOpen;
    peer.socket.onclose = (function() {
     Module["websocket"].emit("close", sock.stream.fd);
    });
    peer.socket.onmessage = function peer_socket_onmessage(event) {
     handleMessage(event.data);
    };
    peer.socket.onerror = (function(error) {
     sock.error = ERRNO_CODES.ECONNREFUSED;
     Module["websocket"].emit("error", [ sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused" ]);
    });
   }
  }),
  poll: (function(sock) {
   if (sock.type === 1 && sock.server) {
    return sock.pending.length ? 64 | 1 : 0;
   }
   var mask = 0;
   var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null;
   if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
    mask |= 64 | 1;
   }
   if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) {
    mask |= 4;
   }
   if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) {
    mask |= 16;
   }
   return mask;
  }),
  ioctl: (function(sock, request, arg) {
   switch (request) {
   case 21531:
    var bytes = 0;
    if (sock.recv_queue.length) {
     bytes = sock.recv_queue[0].data.length;
    }
    GROWABLE_HEAP_STORE_I32(arg | 0, bytes);
    return 0;
   default:
    return ERRNO_CODES.EINVAL;
   }
  }),
  close: (function(sock) {
   if (sock.server) {
    try {
     sock.server.close();
    } catch (e) {}
    sock.server = null;
   }
   var peers = Object.keys(sock.peers);
   for (var i = 0; i < peers.length; i++) {
    var peer = sock.peers[peers[i]];
    try {
     peer.socket.close();
    } catch (e) {}
    SOCKFS.websocket_sock_ops.removePeer(sock, peer);
   }
   return 0;
  }),
  bind: (function(sock, addr, port) {
   if (typeof sock.saddr !== "undefined" || typeof sock.sport !== "undefined") {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   sock.saddr = addr;
   sock.sport = port;
   if (sock.type === 2) {
    if (sock.server) {
     sock.server.close();
     sock.server = null;
    }
    try {
     sock.sock_ops.listen(sock, 0);
    } catch (e) {
     if (!(e instanceof FS.ErrnoError)) throw e;
     if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
    }
   }
  }),
  connect: (function(sock, addr, port) {
   if (sock.server) {
    throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
   }
   if (typeof sock.daddr !== "undefined" && typeof sock.dport !== "undefined") {
    var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
    if (dest) {
     if (dest.socket.readyState === dest.socket.CONNECTING) {
      throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
     } else {
      throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
     }
    }
   }
   var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
   sock.daddr = peer.addr;
   sock.dport = peer.port;
   throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
  }),
  listen: (function(sock, backlog) {
   if (!ENVIRONMENT_IS_NODE) {
    throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
   }
   if (sock.server) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   var WebSocketServer = require("ws").Server;
   var host = sock.saddr;
   sock.server = new WebSocketServer({
    host: host,
    port: sock.sport
   });
   Module["websocket"].emit("listen", sock.stream.fd);
   sock.server.on("connection", (function(ws) {
    if (sock.type === 1) {
     var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
     var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
     newsock.daddr = peer.addr;
     newsock.dport = peer.port;
     sock.pending.push(newsock);
     Module["websocket"].emit("connection", newsock.stream.fd);
    } else {
     SOCKFS.websocket_sock_ops.createPeer(sock, ws);
     Module["websocket"].emit("connection", sock.stream.fd);
    }
   }));
   sock.server.on("closed", (function() {
    Module["websocket"].emit("close", sock.stream.fd);
    sock.server = null;
   }));
   sock.server.on("error", (function(error) {
    sock.error = ERRNO_CODES.EHOSTUNREACH;
    Module["websocket"].emit("error", [ sock.stream.fd, sock.error, "EHOSTUNREACH: Host is unreachable" ]);
   }));
  }),
  accept: (function(listensock) {
   if (!listensock.server) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
   var newsock = listensock.pending.shift();
   newsock.stream.flags = listensock.stream.flags;
   return newsock;
  }),
  getname: (function(sock, peer) {
   var addr, port;
   if (peer) {
    if (sock.daddr === undefined || sock.dport === undefined) {
     throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
    }
    addr = sock.daddr;
    port = sock.dport;
   } else {
    addr = sock.saddr || 0;
    port = sock.sport || 0;
   }
   return {
    addr: addr,
    port: port
   };
  }),
  sendmsg: (function(sock, buffer, offset, length, addr, port) {
   if (sock.type === 2) {
    if (addr === undefined || port === undefined) {
     addr = sock.daddr;
     port = sock.dport;
    }
    if (addr === undefined || port === undefined) {
     throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
    }
   } else {
    addr = sock.daddr;
    port = sock.dport;
   }
   var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
   if (sock.type === 1) {
    if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
     throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
    } else if (dest.socket.readyState === dest.socket.CONNECTING) {
     throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
    }
   }
   if (ArrayBuffer.isView(buffer)) {
    offset += buffer.byteOffset;
    buffer = buffer.buffer;
   }
   var data;
   if (buffer instanceof SharedArrayBuffer) {
    data = (new Uint8Array(new Uint8Array(buffer.slice(offset, offset + length)))).buffer;
   } else {
    data = buffer.slice(offset, offset + length);
   }
   if (sock.type === 2) {
    if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
     if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
      dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
     }
     dest.dgram_send_queue.push(data);
     return length;
    }
   }
   try {
    dest.socket.send(data);
    return length;
   } catch (e) {
    throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
   }
  }),
  recvmsg: (function(sock, length) {
   if (sock.type === 1 && sock.server) {
    throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
   }
   var queued = sock.recv_queue.shift();
   if (!queued) {
    if (sock.type === 1) {
     var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
     if (!dest) {
      throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
     } else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
      return null;
     } else {
      throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
     }
    } else {
     throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
    }
   }
   var queuedLength = queued.data.byteLength || queued.data.length;
   var queuedOffset = queued.data.byteOffset || 0;
   var queuedBuffer = queued.data.buffer || queued.data;
   var bytesRead = Math.min(length, queuedLength);
   var res = {
    buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
    addr: queued.addr,
    port: queued.port
   };
   if (sock.type === 1 && bytesRead < queuedLength) {
    var bytesRemaining = queuedLength - bytesRead;
    queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
    sock.recv_queue.unshift(queued);
   }
   return res;
  })
 }
};
Module["SOCKFS"] = SOCKFS;
function __inet_pton4_raw(str) {
 var b = str.split(".");
 for (var i = 0; i < 4; i++) {
  var tmp = Number(b[i]);
  if (isNaN(tmp)) return null;
  b[i] = tmp;
 }
 return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
}
Module["__inet_pton4_raw"] = __inet_pton4_raw;
function __inet_pton6_raw(str) {
 var words;
 var w, offset, z, i;
 var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
 var parts = [];
 if (!valid6regx.test(str)) {
  return null;
 }
 if (str === "::") {
  return [ 0, 0, 0, 0, 0, 0, 0, 0 ];
 }
 if (str.indexOf("::") === 0) {
  str = str.replace("::", "Z:");
 } else {
  str = str.replace("::", ":Z:");
 }
 if (str.indexOf(".") > 0) {
  str = str.replace(new RegExp("[.]", "g"), ":");
  words = str.split(":");
  words[words.length - 4] = parseInt(words[words.length - 4]) + parseInt(words[words.length - 3]) * 256;
  words[words.length - 3] = parseInt(words[words.length - 2]) + parseInt(words[words.length - 1]) * 256;
  words = words.slice(0, words.length - 2);
 } else {
  words = str.split(":");
 }
 offset = 0;
 z = 0;
 for (w = 0; w < words.length; w++) {
  if (typeof words[w] === "string") {
   if (words[w] === "Z") {
    for (z = 0; z < 8 - words.length + 1; z++) {
     parts[w + z] = 0;
    }
    offset = z - 1;
   } else {
    parts[w + offset] = _htons(parseInt(words[w], 16));
   }
  } else {
   parts[w + offset] = words[w];
  }
 }
 return [ parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6] ];
}
Module["__inet_pton6_raw"] = __inet_pton6_raw;
var DNS = {
 address_map: {
  id: 1,
  addrs: {},
  names: {}
 },
 lookup_name: (function(name) {
  var res = __inet_pton4_raw(name);
  if (res !== null) {
   return name;
  }
  res = __inet_pton6_raw(name);
  if (res !== null) {
   return name;
  }
  var addr;
  if (DNS.address_map.addrs[name]) {
   addr = DNS.address_map.addrs[name];
  } else {
   var id = DNS.address_map.id++;
   assert(id < 65535, "exceeded max address mappings of 65535");
   addr = "172.29." + (id & 255) + "." + (id & 65280);
   DNS.address_map.names[addr] = name;
   DNS.address_map.addrs[name] = addr;
  }
  return addr;
 }),
 lookup_addr: (function(addr) {
  if (DNS.address_map.names[addr]) {
   return DNS.address_map.names[addr];
  }
  return null;
 })
};
Module["DNS"] = DNS;
var Sockets = {
 BUFFER_SIZE: 10240,
 MAX_BUFFER_SIZE: 10485760,
 nextFd: 1,
 fds: {},
 nextport: 1,
 maxport: 65535,
 peer: null,
 connections: {},
 portmap: {},
 localAddr: 4261412874,
 addrPool: [ 33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034 ]
};
Module["Sockets"] = Sockets;
function __inet_ntop4_raw(addr) {
 return (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
}
Module["__inet_ntop4_raw"] = __inet_ntop4_raw;
function __inet_ntop6_raw(ints) {
 var str = "";
 var word = 0;
 var longest = 0;
 var lastzero = 0;
 var zstart = 0;
 var len = 0;
 var i = 0;
 var parts = [ ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16 ];
 var hasipv4 = true;
 var v4part = "";
 for (i = 0; i < 5; i++) {
  if (parts[i] !== 0) {
   hasipv4 = false;
   break;
  }
 }
 if (hasipv4) {
  v4part = __inet_ntop4_raw(parts[6] | parts[7] << 16);
  if (parts[5] === -1) {
   str = "::ffff:";
   str += v4part;
   return str;
  }
  if (parts[5] === 0) {
   str = "::";
   if (v4part === "0.0.0.0") v4part = "";
   if (v4part === "0.0.0.1") v4part = "1";
   str += v4part;
   return str;
  }
 }
 for (word = 0; word < 8; word++) {
  if (parts[word] === 0) {
   if (word - lastzero > 1) {
    len = 0;
   }
   lastzero = word;
   len++;
  }
  if (len > longest) {
   longest = len;
   zstart = word - longest + 1;
  }
 }
 for (word = 0; word < 8; word++) {
  if (longest > 1) {
   if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
    if (word === zstart) {
     str += ":";
     if (zstart === 0) str += ":";
    }
    continue;
   }
  }
  str += Number(_ntohs(parts[word] & 65535)).toString(16);
  str += word < 7 ? ":" : "";
 }
 return str;
}
Module["__inet_ntop6_raw"] = __inet_ntop6_raw;
function __read_sockaddr(sa, salen) {
 var family = GROWABLE_HEAP_LOAD_I16(sa | 0);
 var port = _ntohs(GROWABLE_HEAP_LOAD_I16(sa + 2 | 0));
 var addr;
 switch (family) {
 case 2:
  if (salen !== 16) {
   return {
    errno: 22
   };
  }
  addr = GROWABLE_HEAP_LOAD_I32(sa + 4 | 0);
  addr = __inet_ntop4_raw(addr);
  break;
 case 10:
  if (salen !== 28) {
   return {
    errno: 22
   };
  }
  addr = [ GROWABLE_HEAP_LOAD_I32(sa + 8 | 0), GROWABLE_HEAP_LOAD_I32(sa + 12 | 0), GROWABLE_HEAP_LOAD_I32(sa + 16 | 0), GROWABLE_HEAP_LOAD_I32(sa + 20 | 0) ];
  addr = __inet_ntop6_raw(addr);
  break;
 default:
  return {
   errno: 97
  };
 }
 return {
  family: family,
  addr: addr,
  port: port
 };
}
Module["__read_sockaddr"] = __read_sockaddr;
function __write_sockaddr(sa, family, addr, port) {
 switch (family) {
 case 2:
  addr = __inet_pton4_raw(addr);
  GROWABLE_HEAP_STORE_I16(sa | 0, family);
  GROWABLE_HEAP_STORE_I32(sa + 4 | 0, addr);
  GROWABLE_HEAP_STORE_I16(sa + 2 | 0, _htons(port));
  break;
 case 10:
  addr = __inet_pton6_raw(addr);
  GROWABLE_HEAP_STORE_I32(sa | 0, family);
  GROWABLE_HEAP_STORE_I32(sa + 8 | 0, addr[0]);
  GROWABLE_HEAP_STORE_I32(sa + 12 | 0, addr[1]);
  GROWABLE_HEAP_STORE_I32(sa + 16 | 0, addr[2]);
  GROWABLE_HEAP_STORE_I32(sa + 20 | 0, addr[3]);
  GROWABLE_HEAP_STORE_I16(sa + 2 | 0, _htons(port));
  GROWABLE_HEAP_STORE_I32(sa + 4 | 0, 0);
  GROWABLE_HEAP_STORE_I32(sa + 24 | 0, 0);
  break;
 default:
  return {
   errno: 97
  };
 }
 return {};
}
Module["__write_sockaddr"] = __write_sockaddr;
function ___syscall102(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(2, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var call = SYSCALLS.get(), socketvararg = SYSCALLS.get();
  SYSCALLS.varargs = socketvararg;
  var getSocketFromFD = (function() {
   var socket = SOCKFS.getSocket(SYSCALLS.get());
   if (!socket) throw new FS.ErrnoError(9);
   return socket;
  });
  var getSocketAddress = (function(allowNull) {
   var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();
   if (allowNull && addrp === 0) return null;
   var info = __read_sockaddr(addrp, addrlen);
   if (info.errno) throw new FS.ErrnoError(info.errno);
   info.addr = DNS.lookup_addr(info.addr) || info.addr;
   return info;
  });
  switch (call) {
  case 1:
   {
    var domain = SYSCALLS.get(), type = SYSCALLS.get(), protocol = SYSCALLS.get();
    var sock = SOCKFS.createSocket(domain, type, protocol);
    assert(sock.stream.fd < 64);
    return sock.stream.fd;
   }
  case 2:
   {
    var sock = getSocketFromFD(), info = getSocketAddress();
    sock.sock_ops.bind(sock, info.addr, info.port);
    return 0;
   }
  case 3:
   {
    var sock = getSocketFromFD(), info = getSocketAddress();
    sock.sock_ops.connect(sock, info.addr, info.port);
    return 0;
   }
  case 4:
   {
    var sock = getSocketFromFD(), backlog = SYSCALLS.get();
    sock.sock_ops.listen(sock, backlog);
    return 0;
   }
  case 5:
   {
    var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
    var newsock = sock.sock_ops.accept(sock);
    if (addr) {
     var res = __write_sockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport);
     assert(!res.errno);
    }
    return newsock.stream.fd;
   }
  case 6:
   {
    var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
    var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || "0.0.0.0"), sock.sport);
    assert(!res.errno);
    return 0;
   }
  case 7:
   {
    var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
    if (!sock.daddr) {
     return -107;
    }
    var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport);
    assert(!res.errno);
    return 0;
   }
  case 11:
   {
    var sock = getSocketFromFD(), message = SYSCALLS.get(), length = SYSCALLS.get(), flags = SYSCALLS.get(), dest = getSocketAddress(true);
    if (!dest) {
     return FS.write(sock.stream, HEAP8, message, length);
    } else {
     return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    }
   }
  case 12:
   {
    var sock = getSocketFromFD(), buf = SYSCALLS.get(), len = SYSCALLS.get(), flags = SYSCALLS.get(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
    var msg = sock.sock_ops.recvmsg(sock, len);
    if (!msg) return 0;
    if (addr) {
     var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port);
     assert(!res.errno);
    }
    HEAPU8.set(msg.buffer, buf);
    return msg.buffer.byteLength;
   }
  case 14:
   {
    return -92;
   }
  case 15:
   {
    var sock = getSocketFromFD(), level = SYSCALLS.get(), optname = SYSCALLS.get(), optval = SYSCALLS.get(), optlen = SYSCALLS.get();
    if (level === 1) {
     if (optname === 4) {
      GROWABLE_HEAP_STORE_I32(optval | 0, sock.error);
      GROWABLE_HEAP_STORE_I32(optlen | 0, 4);
      sock.error = null;
      return 0;
     }
    }
    return -92;
   }
  case 16:
   {
    var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();
    var iov = GROWABLE_HEAP_LOAD_I32(message + 8 | 0);
    var num = GROWABLE_HEAP_LOAD_I32(message + 12 | 0);
    var addr, port;
    var name = GROWABLE_HEAP_LOAD_I32(message | 0);
    var namelen = GROWABLE_HEAP_LOAD_I32(message + 4 | 0);
    if (name) {
     var info = __read_sockaddr(name, namelen);
     if (info.errno) return -info.errno;
     port = info.port;
     addr = DNS.lookup_addr(info.addr) || info.addr;
    }
    var total = 0;
    for (var i = 0; i < num; i++) {
     total += GROWABLE_HEAP_LOAD_I32(iov + (8 * i + 4) | 0);
    }
    var view = new Uint8Array(total);
    var offset = 0;
    for (var i = 0; i < num; i++) {
     var iovbase = GROWABLE_HEAP_LOAD_I32(iov + (8 * i + 0) | 0);
     var iovlen = GROWABLE_HEAP_LOAD_I32(iov + (8 * i + 4) | 0);
     for (var j = 0; j < iovlen; j++) {
      view[offset++] = GROWABLE_HEAP_LOAD_I8(iovbase + j >> 0 | 0);
     }
    }
    return sock.sock_ops.sendmsg(sock, view, 0, total, addr, port);
   }
  case 17:
   {
    var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();
    var iov = GROWABLE_HEAP_LOAD_I32(message + 8 | 0);
    var num = GROWABLE_HEAP_LOAD_I32(message + 12 | 0);
    var total = 0;
    for (var i = 0; i < num; i++) {
     total += GROWABLE_HEAP_LOAD_I32(iov + (8 * i + 4) | 0);
    }
    var msg = sock.sock_ops.recvmsg(sock, total);
    if (!msg) return 0;
    var name = GROWABLE_HEAP_LOAD_I32(message | 0);
    if (name) {
     var res = __write_sockaddr(name, sock.family, DNS.lookup_name(msg.addr), msg.port);
     assert(!res.errno);
    }
    var bytesRead = 0;
    var bytesRemaining = msg.buffer.byteLength;
    for (var i = 0; bytesRemaining > 0 && i < num; i++) {
     var iovbase = GROWABLE_HEAP_LOAD_I32(iov + (8 * i + 0) | 0);
     var iovlen = GROWABLE_HEAP_LOAD_I32(iov + (8 * i + 4) | 0);
     if (!iovlen) {
      continue;
     }
     var length = Math.min(iovlen, bytesRemaining);
     var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
     HEAPU8.set(buf, iovbase + bytesRead);
     bytesRead += length;
     bytesRemaining -= length;
    }
    return bytesRead;
   }
  default:
   abort("unsupported socketcall syscall " + call);
  }
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall102"] = ___syscall102;
function ___syscall122(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(3, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var buf = SYSCALLS.get();
  if (!buf) return -14;
  var layout = {
   "sysname": 0,
   "nodename": 65,
   "domainname": 325,
   "machine": 260,
   "version": 195,
   "release": 130,
   "__size__": 390
  };
  var copyString = (function(element, value) {
   var offset = layout[element];
   writeAsciiToMemory(value, buf + offset);
  });
  copyString("sysname", "Emscripten");
  copyString("nodename", "emscripten");
  copyString("release", "1.0");
  copyString("version", "#1");
  copyString("machine", "x86-JS");
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall122"] = ___syscall122;
function ___syscall140(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(4, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
  var HIGH_OFFSET = 4294967296;
  var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  var DOUBLE_LIMIT = 9007199254740992;
  if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
   return -75;
  }
  FS.llseek(stream, offset, whence);
  tempI64 = [ stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], GROWABLE_HEAP_STORE_I32(result | 0, tempI64[0]), GROWABLE_HEAP_STORE_I32(result + 4 | 0, tempI64[1]);
  if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall140"] = ___syscall140;
function ___syscall142(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(5, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var nfds = SYSCALLS.get(), readfds = SYSCALLS.get(), writefds = SYSCALLS.get(), exceptfds = SYSCALLS.get(), timeout = SYSCALLS.get();
  assert(nfds <= 64, "nfds must be less than or equal to 64");
  assert(!exceptfds, "exceptfds not supported");
  var total = 0;
  var srcReadLow = readfds ? GROWABLE_HEAP_LOAD_I32(readfds | 0) : 0, srcReadHigh = readfds ? GROWABLE_HEAP_LOAD_I32(readfds + 4 | 0) : 0;
  var srcWriteLow = writefds ? GROWABLE_HEAP_LOAD_I32(writefds | 0) : 0, srcWriteHigh = writefds ? GROWABLE_HEAP_LOAD_I32(writefds + 4 | 0) : 0;
  var srcExceptLow = exceptfds ? GROWABLE_HEAP_LOAD_I32(exceptfds | 0) : 0, srcExceptHigh = exceptfds ? GROWABLE_HEAP_LOAD_I32(exceptfds + 4 | 0) : 0;
  var dstReadLow = 0, dstReadHigh = 0;
  var dstWriteLow = 0, dstWriteHigh = 0;
  var dstExceptLow = 0, dstExceptHigh = 0;
  var allLow = (readfds ? GROWABLE_HEAP_LOAD_I32(readfds | 0) : 0) | (writefds ? GROWABLE_HEAP_LOAD_I32(writefds | 0) : 0) | (exceptfds ? GROWABLE_HEAP_LOAD_I32(exceptfds | 0) : 0);
  var allHigh = (readfds ? GROWABLE_HEAP_LOAD_I32(readfds + 4 | 0) : 0) | (writefds ? GROWABLE_HEAP_LOAD_I32(writefds + 4 | 0) : 0) | (exceptfds ? GROWABLE_HEAP_LOAD_I32(exceptfds + 4 | 0) : 0);
  var check = (function(fd, low, high, val) {
   return fd < 32 ? low & val : high & val;
  });
  for (var fd = 0; fd < nfds; fd++) {
   var mask = 1 << fd % 32;
   if (!check(fd, allLow, allHigh, mask)) {
    continue;
   }
   var stream = FS.getStream(fd);
   if (!stream) throw new FS.ErrnoError(9);
   var flags = SYSCALLS.DEFAULT_POLLMASK;
   if (stream.stream_ops.poll) {
    flags = stream.stream_ops.poll(stream);
   }
   if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
    fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
    total++;
   }
   if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
    fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
    total++;
   }
   if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
    fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
    total++;
   }
  }
  if (readfds) {
   GROWABLE_HEAP_STORE_I32(readfds | 0, dstReadLow);
   GROWABLE_HEAP_STORE_I32(readfds + 4 | 0, dstReadHigh);
  }
  if (writefds) {
   GROWABLE_HEAP_STORE_I32(writefds | 0, dstWriteLow);
   GROWABLE_HEAP_STORE_I32(writefds + 4 | 0, dstWriteHigh);
  }
  if (exceptfds) {
   GROWABLE_HEAP_STORE_I32(exceptfds | 0, dstExceptLow);
   GROWABLE_HEAP_STORE_I32(exceptfds + 4 | 0, dstExceptHigh);
  }
  return total;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall142"] = ___syscall142;
function ___syscall145(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(6, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
  return SYSCALLS.doReadv(stream, iov, iovcnt);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall145"] = ___syscall145;
function ___syscall146(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(7, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
  return SYSCALLS.doWritev(stream, iov, iovcnt);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall146"] = ___syscall146;
function ___syscall195(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(8, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var path = SYSCALLS.getStr(), buf = SYSCALLS.get();
  return SYSCALLS.doStat(FS.stat, path, buf);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall195"] = ___syscall195;
function ___syscall20(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(9, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  return PROCINFO.pid;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall20"] = ___syscall20;
function ___syscall220(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(10, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), dirp = SYSCALLS.get(), count = SYSCALLS.get();
  if (!stream.getdents) {
   stream.getdents = FS.readdir(stream.path);
  }
  var struct_size = 280;
  var pos = 0;
  var off = FS.llseek(stream, 0, 1);
  var idx = Math.floor(off / struct_size);
  while (idx < stream.getdents.length && pos + struct_size <= count) {
   var id;
   var type;
   var name = stream.getdents[idx];
   if (name[0] === ".") {
    id = 1;
    type = 4;
   } else {
    var child = FS.lookupNode(stream.node, name);
    id = child.id;
    type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;
   }
   tempI64 = [ id >>> 0, (tempDouble = id, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], GROWABLE_HEAP_STORE_I32(dirp + pos | 0, tempI64[0]), GROWABLE_HEAP_STORE_I32(dirp + pos + 4 | 0, tempI64[1]);
   tempI64 = [ (idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], GROWABLE_HEAP_STORE_I32(dirp + pos + 8 | 0, tempI64[0]), GROWABLE_HEAP_STORE_I32(dirp + pos + 12 | 0, tempI64[1]);
   GROWABLE_HEAP_STORE_I16(dirp + pos + 16 | 0, 280);
   GROWABLE_HEAP_STORE_I8(dirp + pos + 18 >> 0 | 0, type);
   stringToUTF8(name, dirp + pos + 19, 256);
   pos += struct_size;
   idx += 1;
  }
  FS.llseek(stream, idx * struct_size, 0);
  return pos;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall220"] = ___syscall220;
function ___syscall221(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(11, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();
  switch (cmd) {
  case 0:
   {
    var arg = SYSCALLS.get();
    if (arg < 0) {
     return -22;
    }
    var newStream;
    newStream = FS.open(stream.path, stream.flags, 0, arg);
    return newStream.fd;
   }
  case 1:
  case 2:
   return 0;
  case 3:
   return stream.flags;
  case 4:
   {
    var arg = SYSCALLS.get();
    stream.flags |= arg;
    return 0;
   }
  case 12:
   {
    var arg = SYSCALLS.get();
    var offset = 0;
    GROWABLE_HEAP_STORE_I16(arg + offset | 0, 2);
    return 0;
   }
  case 13:
  case 14:
   return 0;
  case 16:
  case 8:
   return -22;
  case 9:
   ___setErrNo(22);
   return -1;
  default:
   {
    return -22;
   }
  }
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall221"] = ___syscall221;
function ___syscall38(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(12, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var old_path = SYSCALLS.getStr(), new_path = SYSCALLS.getStr();
  FS.rename(old_path, new_path);
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall38"] = ___syscall38;
function ___syscall39(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(13, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var path = SYSCALLS.getStr(), mode = SYSCALLS.get();
  return SYSCALLS.doMkdir(path, mode);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall39"] = ___syscall39;
function ___syscall40(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(14, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var path = SYSCALLS.getStr();
  FS.rmdir(path);
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall40"] = ___syscall40;
function ___syscall5(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(15, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get();
  var stream = FS.open(pathname, flags, mode);
  return stream.fd;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall5"] = ___syscall5;
function ___syscall54(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(16, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();
  switch (op) {
  case 21509:
  case 21505:
   {
    if (!stream.tty) return -25;
    return 0;
   }
  case 21510:
  case 21511:
  case 21512:
  case 21506:
  case 21507:
  case 21508:
   {
    if (!stream.tty) return -25;
    return 0;
   }
  case 21519:
   {
    if (!stream.tty) return -25;
    var argp = SYSCALLS.get();
    GROWABLE_HEAP_STORE_I32(argp | 0, 0);
    return 0;
   }
  case 21520:
   {
    if (!stream.tty) return -25;
    return -22;
   }
  case 21531:
   {
    var argp = SYSCALLS.get();
    return FS.ioctl(stream, op, argp);
   }
  case 21523:
   {
    if (!stream.tty) return -25;
    return 0;
   }
  case 21524:
   {
    if (!stream.tty) return -25;
    return 0;
   }
  default:
   abort("bad ioctl syscall " + op);
  }
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall54"] = ___syscall54;
function ___syscall6(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(17, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var stream = SYSCALLS.getStreamFromFD();
  FS.close(stream);
  return 0;
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall6"] = ___syscall6;
function __emscripten_syscall_munmap(addr, len) {
 if (addr === -1 || len === 0) {
  return -22;
 }
 var info = SYSCALLS.mappings[addr];
 if (!info) return 0;
 if (len === info.len) {
  var stream = FS.getStream(info.fd);
  SYSCALLS.doMsync(addr, stream, len, info.flags);
  FS.munmap(stream);
  SYSCALLS.mappings[addr] = null;
  if (info.allocated) {
   _free(info.malloc);
  }
 }
 return 0;
}
Module["__emscripten_syscall_munmap"] = __emscripten_syscall_munmap;
function ___syscall91(which, varargs) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(18, 1, which, varargs);
 SYSCALLS.varargs = varargs;
 try {
  var addr = SYSCALLS.get(), len = SYSCALLS.get();
  return __emscripten_syscall_munmap(addr, len);
 } catch (e) {
  if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
  return -e.errno;
 }
}
Module["___syscall91"] = ___syscall91;
function ___unlock() {}
Module["___unlock"] = ___unlock;
function getShiftFromSize(size) {
 switch (size) {
 case 1:
  return 0;
 case 2:
  return 1;
 case 4:
  return 2;
 case 8:
  return 3;
 default:
  throw new TypeError("Unknown type size: " + size);
 }
}
Module["getShiftFromSize"] = getShiftFromSize;
function embind_init_charCodes() {
 var codes = new Array(256);
 for (var i = 0; i < 256; ++i) {
  codes[i] = String.fromCharCode(i);
 }
 embind_charCodes = codes;
}
Module["embind_init_charCodes"] = embind_init_charCodes;
var embind_charCodes = undefined;
Module["embind_charCodes"] = embind_charCodes;
function readLatin1String(ptr) {
 var ret = "";
 var c = ptr;
 while (GROWABLE_HEAP_LOAD_U8(c | 0)) {
  ret += embind_charCodes[GROWABLE_HEAP_LOAD_U8(c++ | 0)];
 }
 return ret;
}
Module["readLatin1String"] = readLatin1String;
var awaitingDependencies = {};
Module["awaitingDependencies"] = awaitingDependencies;
var registeredTypes = {};
Module["registeredTypes"] = registeredTypes;
var typeDependencies = {};
Module["typeDependencies"] = typeDependencies;
var char_0 = 48;
Module["char_0"] = char_0;
var char_9 = 57;
Module["char_9"] = char_9;
function makeLegalFunctionName(name) {
 if (undefined === name) {
  return "_unknown";
 }
 name = name.replace(/[^a-zA-Z0-9_]/g, "$");
 var f = name.charCodeAt(0);
 if (f >= char_0 && f <= char_9) {
  return "_" + name;
 } else {
  return name;
 }
}
Module["makeLegalFunctionName"] = makeLegalFunctionName;
function createNamedFunction(name, body) {
 name = makeLegalFunctionName(name);
 return (new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n"))(body);
}
Module["createNamedFunction"] = createNamedFunction;
function extendError(baseErrorType, errorName) {
 var errorClass = createNamedFunction(errorName, (function(message) {
  this.name = errorName;
  this.message = message;
  var stack = (new Error(message)).stack;
  if (stack !== undefined) {
   this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
  }
 }));
 errorClass.prototype = Object.create(baseErrorType.prototype);
 errorClass.prototype.constructor = errorClass;
 errorClass.prototype.toString = (function() {
  if (this.message === undefined) {
   return this.name;
  } else {
   return this.name + ": " + this.message;
  }
 });
 return errorClass;
}
Module["extendError"] = extendError;
var BindingError = undefined;
Module["BindingError"] = BindingError;
function throwBindingError(message) {
 throw new BindingError(message);
}
Module["throwBindingError"] = throwBindingError;
var InternalError = undefined;
Module["InternalError"] = InternalError;
function throwInternalError(message) {
 throw new InternalError(message);
}
Module["throwInternalError"] = throwInternalError;
function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
 myTypes.forEach((function(type) {
  typeDependencies[type] = dependentTypes;
 }));
 function onComplete(typeConverters) {
  var myTypeConverters = getTypeConverters(typeConverters);
  if (myTypeConverters.length !== myTypes.length) {
   throwInternalError("Mismatched type converter count");
  }
  for (var i = 0; i < myTypes.length; ++i) {
   registerType(myTypes[i], myTypeConverters[i]);
  }
 }
 var typeConverters = new Array(dependentTypes.length);
 var unregisteredTypes = [];
 var registered = 0;
 dependentTypes.forEach((function(dt, i) {
  if (registeredTypes.hasOwnProperty(dt)) {
   typeConverters[i] = registeredTypes[dt];
  } else {
   unregisteredTypes.push(dt);
   if (!awaitingDependencies.hasOwnProperty(dt)) {
    awaitingDependencies[dt] = [];
   }
   awaitingDependencies[dt].push((function() {
    typeConverters[i] = registeredTypes[dt];
    ++registered;
    if (registered === unregisteredTypes.length) {
     onComplete(typeConverters);
    }
   }));
  }
 }));
 if (0 === unregisteredTypes.length) {
  onComplete(typeConverters);
 }
}
Module["whenDependentTypesAreResolved"] = whenDependentTypesAreResolved;
function registerType(rawType, registeredInstance, options) {
 options = options || {};
 if (!("argPackAdvance" in registeredInstance)) {
  throw new TypeError("registerType registeredInstance requires argPackAdvance");
 }
 var name = registeredInstance.name;
 if (!rawType) {
  throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
 }
 if (registeredTypes.hasOwnProperty(rawType)) {
  if (options.ignoreDuplicateRegistrations) {
   return;
  } else {
   throwBindingError("Cannot register type '" + name + "' twice");
  }
 }
 registeredTypes[rawType] = registeredInstance;
 delete typeDependencies[rawType];
 if (awaitingDependencies.hasOwnProperty(rawType)) {
  var callbacks = awaitingDependencies[rawType];
  delete awaitingDependencies[rawType];
  callbacks.forEach((function(cb) {
   cb();
  }));
 }
}
Module["registerType"] = registerType;
function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": (function(wt) {
   return !!wt;
  }),
  "toWireType": (function(destructors, o) {
   return o ? trueValue : falseValue;
  }),
  "argPackAdvance": 8,
  "readValueFromPointer": (function(pointer) {
   var heap;
   if (size === 1) {
    heap = HEAP8;
   } else if (size === 2) {
    heap = HEAP16;
   } else if (size === 4) {
    heap = HEAP32;
   } else {
    throw new TypeError("Unknown boolean type size: " + name);
   }
   return this["fromWireType"](heap[pointer >> shift]);
  }),
  destructorFunction: null
 });
}
Module["__embind_register_bool"] = __embind_register_bool;
function ClassHandle_isAliasOf(other) {
 if (!(this instanceof ClassHandle)) {
  return false;
 }
 if (!(other instanceof ClassHandle)) {
  return false;
 }
 var leftClass = this.$$.ptrType.registeredClass;
 var left = this.$$.ptr;
 var rightClass = other.$$.ptrType.registeredClass;
 var right = other.$$.ptr;
 while (leftClass.baseClass) {
  left = leftClass.upcast(left);
  leftClass = leftClass.baseClass;
 }
 while (rightClass.baseClass) {
  right = rightClass.upcast(right);
  rightClass = rightClass.baseClass;
 }
 return leftClass === rightClass && left === right;
}
Module["ClassHandle_isAliasOf"] = ClassHandle_isAliasOf;
function shallowCopyInternalPointer(o) {
 return {
  count: o.count,
  deleteScheduled: o.deleteScheduled,
  preservePointerOnDelete: o.preservePointerOnDelete,
  ptr: o.ptr,
  ptrType: o.ptrType,
  smartPtr: o.smartPtr,
  smartPtrType: o.smartPtrType
 };
}
Module["shallowCopyInternalPointer"] = shallowCopyInternalPointer;
function throwInstanceAlreadyDeleted(obj) {
 function getInstanceTypeName(handle) {
  return handle.$$.ptrType.registeredClass.name;
 }
 throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
}
Module["throwInstanceAlreadyDeleted"] = throwInstanceAlreadyDeleted;
var finalizationGroup = false;
Module["finalizationGroup"] = finalizationGroup;
function detachFinalizer(handle) {}
Module["detachFinalizer"] = detachFinalizer;
function runDestructor($$) {
 if ($$.smartPtr) {
  $$.smartPtrType.rawDestructor($$.smartPtr);
 } else {
  $$.ptrType.registeredClass.rawDestructor($$.ptr);
 }
}
Module["runDestructor"] = runDestructor;
function releaseClassHandle($$) {
 $$.count.value -= 1;
 var toDelete = 0 === $$.count.value;
 if (toDelete) {
  runDestructor($$);
 }
}
Module["releaseClassHandle"] = releaseClassHandle;
function attachFinalizer(handle) {
 if ("undefined" === typeof FinalizationGroup) {
  attachFinalizer = (function(handle) {
   return handle;
  });
  return handle;
 }
 finalizationGroup = new FinalizationGroup((function(iter) {
  for (var result = iter.next(); !result.done; result = iter.next()) {
   var $$ = result.value;
   if (!$$.ptr) {
    console.warn("object already deleted: " + $$.ptr);
   } else {
    releaseClassHandle($$);
   }
  }
 }));
 attachFinalizer = (function(handle) {
  finalizationGroup.register(handle, handle.$$, handle.$$);
  return handle;
 });
 detachFinalizer = (function(handle) {
  finalizationGroup.unregister(handle.$$);
 });
 return attachFinalizer(handle);
}
Module["attachFinalizer"] = attachFinalizer;
function ClassHandle_clone() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.preservePointerOnDelete) {
  this.$$.count.value += 1;
  return this;
 } else {
  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
   $$: {
    value: shallowCopyInternalPointer(this.$$)
   }
  }));
  clone.$$.count.value += 1;
  clone.$$.deleteScheduled = false;
  return clone;
 }
}
Module["ClassHandle_clone"] = ClassHandle_clone;
function ClassHandle_delete() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 detachFinalizer(this);
 releaseClassHandle(this.$$);
 if (!this.$$.preservePointerOnDelete) {
  this.$$.smartPtr = undefined;
  this.$$.ptr = undefined;
 }
}
Module["ClassHandle_delete"] = ClassHandle_delete;
function ClassHandle_isDeleted() {
 return !this.$$.ptr;
}
Module["ClassHandle_isDeleted"] = ClassHandle_isDeleted;
var delayFunction = undefined;
Module["delayFunction"] = delayFunction;
var deletionQueue = [];
Module["deletionQueue"] = deletionQueue;
function flushPendingDeletes() {
 while (deletionQueue.length) {
  var obj = deletionQueue.pop();
  obj.$$.deleteScheduled = false;
  obj["delete"]();
 }
}
Module["flushPendingDeletes"] = flushPendingDeletes;
function ClassHandle_deleteLater() {
 if (!this.$$.ptr) {
  throwInstanceAlreadyDeleted(this);
 }
 if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
  throwBindingError("Object already scheduled for deletion");
 }
 deletionQueue.push(this);
 if (deletionQueue.length === 1 && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
 this.$$.deleteScheduled = true;
 return this;
}
Module["ClassHandle_deleteLater"] = ClassHandle_deleteLater;
function init_ClassHandle() {
 ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
 ClassHandle.prototype["clone"] = ClassHandle_clone;
 ClassHandle.prototype["delete"] = ClassHandle_delete;
 ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
 ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
}
Module["init_ClassHandle"] = init_ClassHandle;
function ClassHandle() {}
Module["ClassHandle"] = ClassHandle;
var registeredPointers = {};
Module["registeredPointers"] = registeredPointers;
function ensureOverloadTable(proto, methodName, humanName) {
 if (undefined === proto[methodName].overloadTable) {
  var prevFunc = proto[methodName];
  proto[methodName] = (function() {
   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
    throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
   }
   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
  });
  proto[methodName].overloadTable = [];
  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
 }
}
Module["ensureOverloadTable"] = ensureOverloadTable;
function exposePublicSymbol(name, value, numArguments) {
 if (Module.hasOwnProperty(name)) {
  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
   throwBindingError("Cannot register public name '" + name + "' twice");
  }
  ensureOverloadTable(Module, name, name);
  if (Module.hasOwnProperty(numArguments)) {
   throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
  }
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  if (undefined !== numArguments) {
   Module[name].numArguments = numArguments;
  }
 }
}
Module["exposePublicSymbol"] = exposePublicSymbol;
function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
 this.name = name;
 this.constructor = constructor;
 this.instancePrototype = instancePrototype;
 this.rawDestructor = rawDestructor;
 this.baseClass = baseClass;
 this.getActualType = getActualType;
 this.upcast = upcast;
 this.downcast = downcast;
 this.pureVirtualFunctions = [];
}
Module["RegisteredClass"] = RegisteredClass;
function upcastPointer(ptr, ptrClass, desiredClass) {
 while (ptrClass !== desiredClass) {
  if (!ptrClass.upcast) {
   throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
  }
  ptr = ptrClass.upcast(ptr);
  ptrClass = ptrClass.baseClass;
 }
 return ptr;
}
Module["upcastPointer"] = upcastPointer;
function constNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}
Module["constNoSmartPtrRawPointerToWireType"] = constNoSmartPtrRawPointerToWireType;
function genericPointerToWireType(destructors, handle) {
 var ptr;
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  if (this.isSmartPointer) {
   ptr = this.rawConstructor();
   if (destructors !== null) {
    destructors.push(this.rawDestructor, ptr);
   }
   return ptr;
  } else {
   return 0;
  }
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (!this.isConst && handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 if (this.isSmartPointer) {
  if (undefined === handle.$$.smartPtr) {
   throwBindingError("Passing raw pointer to smart pointer is illegal");
  }
  switch (this.sharingPolicy) {
  case 0:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
   }
   break;
  case 1:
   ptr = handle.$$.smartPtr;
   break;
  case 2:
   if (handle.$$.smartPtrType === this) {
    ptr = handle.$$.smartPtr;
   } else {
    var clonedHandle = handle["clone"]();
    ptr = this.rawShare(ptr, __emval_register((function() {
     clonedHandle["delete"]();
    })));
    if (destructors !== null) {
     destructors.push(this.rawDestructor, ptr);
    }
   }
   break;
  default:
   throwBindingError("Unsupporting sharing policy");
  }
 }
 return ptr;
}
Module["genericPointerToWireType"] = genericPointerToWireType;
function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
 if (handle === null) {
  if (this.isReference) {
   throwBindingError("null is not a valid " + this.name);
  }
  return 0;
 }
 if (!handle.$$) {
  throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
 }
 if (!handle.$$.ptr) {
  throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
 }
 if (handle.$$.ptrType.isConst) {
  throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
 }
 var handleClass = handle.$$.ptrType.registeredClass;
 var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
 return ptr;
}
Module["nonConstNoSmartPtrRawPointerToWireType"] = nonConstNoSmartPtrRawPointerToWireType;
function simpleReadValueFromPointer(pointer) {
 return this["fromWireType"](GROWABLE_HEAP_LOAD_U32(pointer | 0));
}
Module["simpleReadValueFromPointer"] = simpleReadValueFromPointer;
function RegisteredPointer_getPointee(ptr) {
 if (this.rawGetPointee) {
  ptr = this.rawGetPointee(ptr);
 }
 return ptr;
}
Module["RegisteredPointer_getPointee"] = RegisteredPointer_getPointee;
function RegisteredPointer_destructor(ptr) {
 if (this.rawDestructor) {
  this.rawDestructor(ptr);
 }
}
Module["RegisteredPointer_destructor"] = RegisteredPointer_destructor;
function RegisteredPointer_deleteObject(handle) {
 if (handle !== null) {
  handle["delete"]();
 }
}
Module["RegisteredPointer_deleteObject"] = RegisteredPointer_deleteObject;
function downcastPointer(ptr, ptrClass, desiredClass) {
 if (ptrClass === desiredClass) {
  return ptr;
 }
 if (undefined === desiredClass.baseClass) {
  return null;
 }
 var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
 if (rv === null) {
  return null;
 }
 return desiredClass.downcast(rv);
}
Module["downcastPointer"] = downcastPointer;
function getInheritedInstanceCount() {
 return Object.keys(registeredInstances).length;
}
Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
function getLiveInheritedInstances() {
 var rv = [];
 for (var k in registeredInstances) {
  if (registeredInstances.hasOwnProperty(k)) {
   rv.push(registeredInstances[k]);
  }
 }
 return rv;
}
Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
function setDelayFunction(fn) {
 delayFunction = fn;
 if (deletionQueue.length && delayFunction) {
  delayFunction(flushPendingDeletes);
 }
}
Module["setDelayFunction"] = setDelayFunction;
function init_embind() {
 Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
 Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
 Module["flushPendingDeletes"] = flushPendingDeletes;
 Module["setDelayFunction"] = setDelayFunction;
}
Module["init_embind"] = init_embind;
var registeredInstances = {};
Module["registeredInstances"] = registeredInstances;
function getBasestPointer(class_, ptr) {
 if (ptr === undefined) {
  throwBindingError("ptr should not be undefined");
 }
 while (class_.baseClass) {
  ptr = class_.upcast(ptr);
  class_ = class_.baseClass;
 }
 return ptr;
}
Module["getBasestPointer"] = getBasestPointer;
function getInheritedInstance(class_, ptr) {
 ptr = getBasestPointer(class_, ptr);
 return registeredInstances[ptr];
}
Module["getInheritedInstance"] = getInheritedInstance;
function makeClassHandle(prototype, record) {
 if (!record.ptrType || !record.ptr) {
  throwInternalError("makeClassHandle requires ptr and ptrType");
 }
 var hasSmartPtrType = !!record.smartPtrType;
 var hasSmartPtr = !!record.smartPtr;
 if (hasSmartPtrType !== hasSmartPtr) {
  throwInternalError("Both smartPtrType and smartPtr must be specified");
 }
 record.count = {
  value: 1
 };
 return attachFinalizer(Object.create(prototype, {
  $$: {
   value: record
  }
 }));
}
Module["makeClassHandle"] = makeClassHandle;
function RegisteredPointer_fromWireType(ptr) {
 var rawPointer = this.getPointee(ptr);
 if (!rawPointer) {
  this.destructor(ptr);
  return null;
 }
 var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
 if (undefined !== registeredInstance) {
  if (0 === registeredInstance.$$.count.value) {
   registeredInstance.$$.ptr = rawPointer;
   registeredInstance.$$.smartPtr = ptr;
   return registeredInstance["clone"]();
  } else {
   var rv = registeredInstance["clone"]();
   this.destructor(ptr);
   return rv;
  }
 }
 function makeDefaultHandle() {
  if (this.isSmartPointer) {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this.pointeeType,
    ptr: rawPointer,
    smartPtrType: this,
    smartPtr: ptr
   });
  } else {
   return makeClassHandle(this.registeredClass.instancePrototype, {
    ptrType: this,
    ptr: ptr
   });
  }
 }
 var actualType = this.registeredClass.getActualType(rawPointer);
 var registeredPointerRecord = registeredPointers[actualType];
 if (!registeredPointerRecord) {
  return makeDefaultHandle.call(this);
 }
 var toType;
 if (this.isConst) {
  toType = registeredPointerRecord.constPointerType;
 } else {
  toType = registeredPointerRecord.pointerType;
 }
 var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
 if (dp === null) {
  return makeDefaultHandle.call(this);
 }
 if (this.isSmartPointer) {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp,
   smartPtrType: this,
   smartPtr: ptr
  });
 } else {
  return makeClassHandle(toType.registeredClass.instancePrototype, {
   ptrType: toType,
   ptr: dp
  });
 }
}
Module["RegisteredPointer_fromWireType"] = RegisteredPointer_fromWireType;
function init_RegisteredPointer() {
 RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
 RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
 RegisteredPointer.prototype["argPackAdvance"] = 8;
 RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
 RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
 RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
}
Module["init_RegisteredPointer"] = init_RegisteredPointer;
function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
 this.name = name;
 this.registeredClass = registeredClass;
 this.isReference = isReference;
 this.isConst = isConst;
 this.isSmartPointer = isSmartPointer;
 this.pointeeType = pointeeType;
 this.sharingPolicy = sharingPolicy;
 this.rawGetPointee = rawGetPointee;
 this.rawConstructor = rawConstructor;
 this.rawShare = rawShare;
 this.rawDestructor = rawDestructor;
 if (!isSmartPointer && registeredClass.baseClass === undefined) {
  if (isConst) {
   this["toWireType"] = constNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  } else {
   this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
   this.destructorFunction = null;
  }
 } else {
  this["toWireType"] = genericPointerToWireType;
 }
}
Module["RegisteredPointer"] = RegisteredPointer;
function replacePublicSymbol(name, value, numArguments) {
 if (!Module.hasOwnProperty(name)) {
  throwInternalError("Replacing nonexistant public symbol");
 }
 if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
  Module[name].overloadTable[numArguments] = value;
 } else {
  Module[name] = value;
  Module[name].argCount = numArguments;
 }
}
Module["replacePublicSymbol"] = replacePublicSymbol;
function embind__requireFunction(signature, rawFunction) {
 signature = readLatin1String(signature);
 function makeDynCaller(dynCall) {
  var args = [];
  for (var i = 1; i < signature.length; ++i) {
   args.push("a" + i);
  }
  var name = "dynCall_" + signature + "_" + rawFunction;
  var body = "return function " + name + "(" + args.join(", ") + ") {\n";
  body += "    return dynCall(rawFunction" + (args.length ? ", " : "") + args.join(", ") + ");\n";
  body += "};\n";
  return (new Function("dynCall", "rawFunction", body))(dynCall, rawFunction);
 }
 var fp;
 if (Module["FUNCTION_TABLE_" + signature] !== undefined) {
  fp = Module["FUNCTION_TABLE_" + signature][rawFunction];
 } else if (typeof FUNCTION_TABLE !== "undefined") {
  fp = FUNCTION_TABLE[rawFunction];
 } else {
  var dc = Module["dynCall_" + signature];
  if (dc === undefined) {
   dc = Module["dynCall_" + signature.replace(/f/g, "d")];
   if (dc === undefined) {
    throwBindingError("No dynCall invoker for signature: " + signature);
   }
  }
  fp = makeDynCaller(dc);
 }
 if (typeof fp !== "function") {
  throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
 }
 return fp;
}
Module["embind__requireFunction"] = embind__requireFunction;
var UnboundTypeError = undefined;
Module["UnboundTypeError"] = UnboundTypeError;
function getTypeName(type) {
 var ptr = ___getTypeName(type);
 var rv = readLatin1String(ptr);
 _free(ptr);
 return rv;
}
Module["getTypeName"] = getTypeName;
function throwUnboundTypeError(message, types) {
 var unboundTypes = [];
 var seen = {};
 function visit(type) {
  if (seen[type]) {
   return;
  }
  if (registeredTypes[type]) {
   return;
  }
  if (typeDependencies[type]) {
   typeDependencies[type].forEach(visit);
   return;
  }
  unboundTypes.push(type);
  seen[type] = true;
 }
 types.forEach(visit);
 throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([ ", " ]));
}
Module["throwUnboundTypeError"] = throwUnboundTypeError;
function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
 name = readLatin1String(name);
 getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
 if (upcast) {
  upcast = embind__requireFunction(upcastSignature, upcast);
 }
 if (downcast) {
  downcast = embind__requireFunction(downcastSignature, downcast);
 }
 rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
 var legalFunctionName = makeLegalFunctionName(name);
 exposePublicSymbol(legalFunctionName, (function() {
  throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [ baseClassRawType ]);
 }));
 whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], (function(base) {
  base = base[0];
  var baseClass;
  var basePrototype;
  if (baseClassRawType) {
   baseClass = base.registeredClass;
   basePrototype = baseClass.instancePrototype;
  } else {
   basePrototype = ClassHandle.prototype;
  }
  var constructor = createNamedFunction(legalFunctionName, (function() {
   if (Object.getPrototypeOf(this) !== instancePrototype) {
    throw new BindingError("Use 'new' to construct " + name);
   }
   if (undefined === registeredClass.constructor_body) {
    throw new BindingError(name + " has no accessible constructor");
   }
   var body = registeredClass.constructor_body[arguments.length];
   if (undefined === body) {
    throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
   }
   return body.apply(this, arguments);
  }));
  var instancePrototype = Object.create(basePrototype, {
   constructor: {
    value: constructor
   }
  });
  constructor.prototype = instancePrototype;
  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
  var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
  var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
  registeredPointers[rawType] = {
   pointerType: pointerConverter,
   constPointerType: constPointerConverter
  };
  replacePublicSymbol(legalFunctionName, constructor);
  return [ referenceConverter, pointerConverter, constPointerConverter ];
 }));
}
Module["__embind_register_class"] = __embind_register_class;
function heap32VectorToArray(count, firstElement) {
 var array = [];
 for (var i = 0; i < count; i++) {
  array.push(GROWABLE_HEAP_LOAD_I32(((firstElement >> 2) + i) * 4 | 0));
 }
 return array;
}
Module["heap32VectorToArray"] = heap32VectorToArray;
function runDestructors(destructors) {
 while (destructors.length) {
  var ptr = destructors.pop();
  var del = destructors.pop();
  del(ptr);
 }
}
Module["runDestructors"] = runDestructors;
function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 invoker = embind__requireFunction(invokerSignature, invoker);
 whenDependentTypesAreResolved([], [ rawClassType ], (function(classType) {
  classType = classType[0];
  var humanName = "constructor " + classType.name;
  if (undefined === classType.registeredClass.constructor_body) {
   classType.registeredClass.constructor_body = [];
  }
  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
   throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
  }
  classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
   throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
  };
  whenDependentTypesAreResolved([], rawArgTypes, (function(argTypes) {
   classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
    if (arguments.length !== argCount - 1) {
     throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
    }
    var destructors = [];
    var args = new Array(argCount);
    args[0] = rawConstructor;
    for (var i = 1; i < argCount; ++i) {
     args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
    }
    var ptr = invoker.apply(null, args);
    runDestructors(destructors);
    return argTypes[0]["fromWireType"](ptr);
   };
   return [];
  }));
  return [];
 }));
}
Module["__embind_register_class_constructor"] = __embind_register_class_constructor;
function new_(constructor, argumentList) {
 if (!(constructor instanceof Function)) {
  throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
 }
 var dummy = createNamedFunction(constructor.name || "unknownFunctionName", (function() {}));
 dummy.prototype = constructor.prototype;
 var obj = new dummy;
 var r = constructor.apply(obj, argumentList);
 return r instanceof Object ? r : obj;
}
Module["new_"] = new_;
function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
 var argCount = argTypes.length;
 if (argCount < 2) {
  throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
 }
 var isClassMethodFunc = argTypes[1] !== null && classType !== null;
 var needsDestructorStack = false;
 for (var i = 1; i < argTypes.length; ++i) {
  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
   needsDestructorStack = true;
   break;
  }
 }
 var returns = argTypes[0].name !== "void";
 var argsList = "";
 var argsListWired = "";
 for (var i = 0; i < argCount - 2; ++i) {
  argsList += (i !== 0 ? ", " : "") + "arg" + i;
  argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
 }
 var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\n" + "if (arguments.length !== " + (argCount - 2) + ") {\n" + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n" + "}\n";
 if (needsDestructorStack) {
  invokerFnBody += "var destructors = [];\n";
 }
 var dtorStack = needsDestructorStack ? "destructors" : "null";
 var args1 = [ "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam" ];
 var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];
 if (isClassMethodFunc) {
  invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
 }
 for (var i = 0; i < argCount - 2; ++i) {
  invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
  args1.push("argType" + i);
  args2.push(argTypes[i + 2]);
 }
 if (isClassMethodFunc) {
  argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
 }
 invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
 if (needsDestructorStack) {
  invokerFnBody += "runDestructors(destructors);\n";
 } else {
  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
   var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
   if (argTypes[i].destructorFunction !== null) {
    invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
    args1.push(paramName + "_dtor");
    args2.push(argTypes[i].destructorFunction);
   }
  }
 }
 if (returns) {
  invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
 } else {}
 invokerFnBody += "}\n";
 args1.push(invokerFnBody);
 var invokerFunction = new_(Function, args1).apply(null, args2);
 return invokerFunction;
}
Module["craftInvokerFunction"] = craftInvokerFunction;
function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
 var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
 methodName = readLatin1String(methodName);
 rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
 whenDependentTypesAreResolved([], [ rawClassType ], (function(classType) {
  classType = classType[0];
  var humanName = classType.name + "." + methodName;
  if (isPureVirtual) {
   classType.registeredClass.pureVirtualFunctions.push(methodName);
  }
  function unboundTypesHandler() {
   throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
  }
  var proto = classType.registeredClass.instancePrototype;
  var method = proto[methodName];
  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
   unboundTypesHandler.argCount = argCount - 2;
   unboundTypesHandler.className = classType.name;
   proto[methodName] = unboundTypesHandler;
  } else {
   ensureOverloadTable(proto, methodName, humanName);
   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
  }
  whenDependentTypesAreResolved([], rawArgTypes, (function(argTypes) {
   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
   if (undefined === proto[methodName].overloadTable) {
    memberFunction.argCount = argCount - 2;
    proto[methodName] = memberFunction;
   } else {
    proto[methodName].overloadTable[argCount - 2] = memberFunction;
   }
   return [];
  }));
  return [];
 }));
}
Module["__embind_register_class_function"] = __embind_register_class_function;
var emval_free_list = [];
Module["emval_free_list"] = emval_free_list;
var emval_handle_array = [ {}, {
 value: undefined
}, {
 value: null
}, {
 value: true
}, {
 value: false
} ];
Module["emval_handle_array"] = emval_handle_array;
function __emval_decref(handle) {
 if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
  emval_handle_array[handle] = undefined;
  emval_free_list.push(handle);
 }
}
Module["__emval_decref"] = __emval_decref;
function count_emval_handles() {
 var count = 0;
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   ++count;
  }
 }
 return count;
}
Module["count_emval_handles"] = count_emval_handles;
function get_first_emval() {
 for (var i = 5; i < emval_handle_array.length; ++i) {
  if (emval_handle_array[i] !== undefined) {
   return emval_handle_array[i];
  }
 }
 return null;
}
Module["get_first_emval"] = get_first_emval;
function init_emval() {
 Module["count_emval_handles"] = count_emval_handles;
 Module["get_first_emval"] = get_first_emval;
}
Module["init_emval"] = init_emval;
function __emval_register(value) {
 switch (value) {
 case undefined:
  {
   return 1;
  }
 case null:
  {
   return 2;
  }
 case true:
  {
   return 3;
  }
 case false:
  {
   return 4;
  }
 default:
  {
   var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
   emval_handle_array[handle] = {
    refcount: 1,
    value: value
   };
   return handle;
  }
 }
}
Module["__emval_register"] = __emval_register;
function __embind_register_emval(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": (function(handle) {
   var rv = emval_handle_array[handle].value;
   __emval_decref(handle);
   return rv;
  }),
  "toWireType": (function(destructors, value) {
   return __emval_register(value);
  }),
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: null
 });
}
Module["__embind_register_emval"] = __embind_register_emval;
function enumReadValueFromPointer(name, shift, signed) {
 switch (shift) {
 case 0:
  return (function(pointer) {
   var heap = signed ? HEAP8 : HEAPU8;
   return this["fromWireType"](heap[pointer]);
  });
 case 1:
  return (function(pointer) {
   var heap = signed ? HEAP16 : HEAPU16;
   return this["fromWireType"](heap[pointer >> 1]);
  });
 case 2:
  return (function(pointer) {
   var heap = signed ? HEAP32 : HEAPU32;
   return this["fromWireType"](heap[pointer >> 2]);
  });
 default:
  throw new TypeError("Unknown integer type: " + name);
 }
}
Module["enumReadValueFromPointer"] = enumReadValueFromPointer;
function __embind_register_enum(rawType, name, size, isSigned) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 function ctor() {}
 ctor.values = {};
 registerType(rawType, {
  name: name,
  constructor: ctor,
  "fromWireType": (function(c) {
   return this.constructor.values[c];
  }),
  "toWireType": (function(destructors, c) {
   return c.value;
  }),
  "argPackAdvance": 8,
  "readValueFromPointer": enumReadValueFromPointer(name, shift, isSigned),
  destructorFunction: null
 });
 exposePublicSymbol(name, ctor);
}
Module["__embind_register_enum"] = __embind_register_enum;
function requireRegisteredType(rawType, humanName) {
 var impl = registeredTypes[rawType];
 if (undefined === impl) {
  throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
 }
 return impl;
}
Module["requireRegisteredType"] = requireRegisteredType;
function __embind_register_enum_value(rawEnumType, name, enumValue) {
 var enumType = requireRegisteredType(rawEnumType, "enum");
 name = readLatin1String(name);
 var Enum = enumType.constructor;
 var Value = Object.create(enumType.constructor.prototype, {
  value: {
   value: enumValue
  },
  constructor: {
   value: createNamedFunction(enumType.name + "_" + name, (function() {}))
  }
 });
 Enum.values[enumValue] = Value;
 Enum[name] = Value;
}
Module["__embind_register_enum_value"] = __embind_register_enum_value;
function _embind_repr(v) {
 if (v === null) {
  return "null";
 }
 var t = typeof v;
 if (t === "object" || t === "array" || t === "function") {
  return v.toString();
 } else {
  return "" + v;
 }
}
Module["_embind_repr"] = _embind_repr;
function floatReadValueFromPointer(name, shift) {
 switch (shift) {
 case 2:
  return (function(pointer) {
   return this["fromWireType"](GROWABLE_HEAP_LOAD_F32(pointer | 0));
  });
 case 3:
  return (function(pointer) {
   return this["fromWireType"](GROWABLE_HEAP_LOAD_F64(pointer | 0));
  });
 default:
  throw new TypeError("Unknown float type: " + name);
 }
}
Module["floatReadValueFromPointer"] = floatReadValueFromPointer;
function __embind_register_float(rawType, name, size) {
 var shift = getShiftFromSize(size);
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": (function(value) {
   return value;
  }),
  "toWireType": (function(destructors, value) {
   if (typeof value !== "number" && typeof value !== "boolean") {
    throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
   }
   return value;
  }),
  "argPackAdvance": 8,
  "readValueFromPointer": floatReadValueFromPointer(name, shift),
  destructorFunction: null
 });
}
Module["__embind_register_float"] = __embind_register_float;
function integerReadValueFromPointer(name, shift, signed) {
 switch (shift) {
 case 0:
  return signed ? function readS8FromPointer(pointer) {
   return GROWABLE_HEAP_LOAD_I8(pointer | 0);
  } : function readU8FromPointer(pointer) {
   return GROWABLE_HEAP_LOAD_U8(pointer | 0);
  };
 case 1:
  return signed ? function readS16FromPointer(pointer) {
   return GROWABLE_HEAP_LOAD_I16(pointer | 0);
  } : function readU16FromPointer(pointer) {
   return GROWABLE_HEAP_LOAD_U16(pointer | 0);
  };
 case 2:
  return signed ? function readS32FromPointer(pointer) {
   return GROWABLE_HEAP_LOAD_I32(pointer | 0);
  } : function readU32FromPointer(pointer) {
   return GROWABLE_HEAP_LOAD_U32(pointer | 0);
  };
 default:
  throw new TypeError("Unknown integer type: " + name);
 }
}
Module["integerReadValueFromPointer"] = integerReadValueFromPointer;
function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
 name = readLatin1String(name);
 if (maxRange === -1) {
  maxRange = 4294967295;
 }
 var shift = getShiftFromSize(size);
 var fromWireType = (function(value) {
  return value;
 });
 if (minRange === 0) {
  var bitshift = 32 - 8 * size;
  fromWireType = (function(value) {
   return value << bitshift >>> bitshift;
  });
 }
 var isUnsignedType = name.indexOf("unsigned") != -1;
 registerType(primitiveType, {
  name: name,
  "fromWireType": fromWireType,
  "toWireType": (function(destructors, value) {
   if (typeof value !== "number" && typeof value !== "boolean") {
    throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
   }
   if (value < minRange || value > maxRange) {
    throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
   }
   return isUnsignedType ? value >>> 0 : value | 0;
  }),
  "argPackAdvance": 8,
  "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0),
  destructorFunction: null
 });
}
Module["__embind_register_integer"] = __embind_register_integer;
function __embind_register_memory_view(rawType, dataTypeIndex, name) {
 var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
 var TA = typeMapping[dataTypeIndex];
 function decodeMemoryView(handle) {
  handle = handle >> 2;
  var heap = HEAPU32;
  var size = heap[handle];
  var data = heap[handle + 1];
  return new TA(heap["buffer"], data, size);
 }
 name = readLatin1String(name);
 registerType(rawType, {
  name: name,
  "fromWireType": decodeMemoryView,
  "argPackAdvance": 8,
  "readValueFromPointer": decodeMemoryView
 }, {
  ignoreDuplicateRegistrations: true
 });
}
Module["__embind_register_memory_view"] = __embind_register_memory_view;
function __embind_register_std_string(rawType, name) {
 name = readLatin1String(name);
 var stdStringIsUTF8 = name === "std::string";
 registerType(rawType, {
  name: name,
  "fromWireType": (function(value) {
   var length = GROWABLE_HEAP_LOAD_U32(value | 0);
   var str;
   if (stdStringIsUTF8) {
    var endChar = GROWABLE_HEAP_LOAD_U8(value + 4 + length | 0);
    var endCharSwap = 0;
    if (endChar != 0) {
     endCharSwap = endChar;
     GROWABLE_HEAP_STORE_I8(value + 4 + length | 0, 0);
    }
    var decodeStartPtr = value + 4;
    for (var i = 0; i <= length; ++i) {
     var currentBytePtr = value + 4 + i;
     if (GROWABLE_HEAP_LOAD_U8(currentBytePtr | 0) == 0) {
      var stringSegment = UTF8ToString(decodeStartPtr);
      if (str === undefined) str = stringSegment; else {
       str += String.fromCharCode(0);
       str += stringSegment;
      }
      decodeStartPtr = currentBytePtr + 1;
     }
    }
    if (endCharSwap != 0) GROWABLE_HEAP_STORE_I8(value + 4 + length | 0, endCharSwap);
   } else {
    var a = new Array(length);
    for (var i = 0; i < length; ++i) {
     a[i] = String.fromCharCode(GROWABLE_HEAP_LOAD_U8(value + 4 + i | 0));
    }
    str = a.join("");
   }
   _free(value);
   return str;
  }),
  "toWireType": (function(destructors, value) {
   if (value instanceof ArrayBuffer) {
    value = new Uint8Array(value);
   }
   var getLength;
   var valueIsOfTypeString = typeof value === "string";
   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
    throwBindingError("Cannot pass non-string to std::string");
   }
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    getLength = (function() {
     return lengthBytesUTF8(value);
    });
   } else {
    getLength = (function() {
     return value.length;
    });
   }
   var length = getLength();
   var ptr = _malloc(4 + length + 1);
   GROWABLE_HEAP_STORE_I32(ptr | 0, length);
   if (stdStringIsUTF8 && valueIsOfTypeString) {
    stringToUTF8(value, ptr + 4, length + 1);
   } else {
    if (valueIsOfTypeString) {
     for (var i = 0; i < length; ++i) {
      var charCode = value.charCodeAt(i);
      if (charCode > 255) {
       _free(ptr);
       throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
      }
      GROWABLE_HEAP_STORE_I8(ptr + 4 + i | 0, charCode);
     }
    } else {
     for (var i = 0; i < length; ++i) {
      GROWABLE_HEAP_STORE_I8(ptr + 4 + i | 0, value[i]);
     }
    }
   }
   if (destructors !== null) {
    destructors.push(_free, ptr);
   }
   return ptr;
  }),
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: (function(ptr) {
   _free(ptr);
  })
 });
}
Module["__embind_register_std_string"] = __embind_register_std_string;
function __embind_register_std_wstring(rawType, charSize, name) {
 name = readLatin1String(name);
 var getHeap, shift;
 if (charSize === 2) {
  getHeap = (function() {
   return HEAPU16;
  });
  shift = 1;
 } else if (charSize === 4) {
  getHeap = (function() {
   return HEAPU32;
  });
  shift = 2;
 }
 registerType(rawType, {
  name: name,
  "fromWireType": (function(value) {
   var HEAP = getHeap();
   var length = GROWABLE_HEAP_LOAD_U32(value | 0);
   var a = new Array(length);
   var start = value + 4 >> shift;
   for (var i = 0; i < length; ++i) {
    a[i] = String.fromCharCode(HEAP[start + i]);
   }
   _free(value);
   return a.join("");
  }),
  "toWireType": (function(destructors, value) {
   var HEAP = getHeap();
   var length = value.length;
   var ptr = _malloc(4 + length * charSize);
   GROWABLE_HEAP_STORE_I32(ptr | 0, length);
   var start = ptr + 4 >> shift;
   for (var i = 0; i < length; ++i) {
    HEAP[start + i] = value.charCodeAt(i);
   }
   if (destructors !== null) {
    destructors.push(_free, ptr);
   }
   return ptr;
  }),
  "argPackAdvance": 8,
  "readValueFromPointer": simpleReadValueFromPointer,
  destructorFunction: (function(ptr) {
   _free(ptr);
  })
 });
}
Module["__embind_register_std_wstring"] = __embind_register_std_wstring;
function __embind_register_void(rawType, name) {
 name = readLatin1String(name);
 registerType(rawType, {
  isVoid: true,
  name: name,
  "argPackAdvance": 0,
  "fromWireType": (function() {
   return undefined;
  }),
  "toWireType": (function(destructors, o) {
   return undefined;
  })
 });
}
Module["__embind_register_void"] = __embind_register_void;
function __emscripten_fetch_free(id) {
 delete Fetch.xhrs[id - 1];
}
Module["__emscripten_fetch_free"] = __emscripten_fetch_free;
var _fetch_work_queue;
if (ENVIRONMENT_IS_PTHREAD) _fetch_work_queue = PthreadWorkerInit._fetch_work_queue; else PthreadWorkerInit._fetch_work_queue = _fetch_work_queue = 662304;
Module["_fetch_work_queue"] = _fetch_work_queue;
function __emscripten_get_fetch_work_queue() {
 return _fetch_work_queue;
}
Module["__emscripten_get_fetch_work_queue"] = __emscripten_get_fetch_work_queue;
function _abort() {
 Module["abort"]();
}
Module["_abort"] = _abort;
function _difftime(time1, time0) {
 return time1 - time0;
}
Module["_difftime"] = _difftime;
var _emscripten_asm_const_int = true;
Module["_emscripten_asm_const_int"] = _emscripten_asm_const_int;
var _emscripten_asm_const_int_sync_on_main_thread = true;
Module["_emscripten_asm_const_int_sync_on_main_thread"] = _emscripten_asm_const_int_sync_on_main_thread;
function _emscripten_conditional_set_current_thread_status_js(expectedStatus, newStatus) {}
Module["_emscripten_conditional_set_current_thread_status_js"] = _emscripten_conditional_set_current_thread_status_js;
var __main_thread_futex_wait_address;
if (ENVIRONMENT_IS_PTHREAD) __main_thread_futex_wait_address = PthreadWorkerInit.__main_thread_futex_wait_address; else PthreadWorkerInit.__main_thread_futex_wait_address = __main_thread_futex_wait_address = 663104;
Module["__main_thread_futex_wait_address"] = __main_thread_futex_wait_address;
function _emscripten_futex_wait(addr, val, timeout) {
 if (addr <= 0 || addr > HEAP8.length || addr & 3 != 0) return -22;
 if (ENVIRONMENT_IS_WORKER) {
  var ret = Atomics.wait(HEAP32, addr >> 2, val, timeout);
  if (ret === "timed-out") return -110;
  if (ret === "not-equal") return -11;
  if (ret === "ok") return 0;
  throw "Atomics.wait returned an unexpected value " + ret;
 } else {
  var loadedVal = Atomics.load(HEAP32, addr >> 2);
  if (val != loadedVal) return -11;
  var tNow = performance.now();
  var tEnd = tNow + timeout;
  Atomics.store(HEAP32, __main_thread_futex_wait_address >> 2, addr);
  var ourWaitAddress = addr;
  while (addr == ourWaitAddress) {
   tNow = performance.now();
   if (tNow > tEnd) {
    return -110;
   }
   _emscripten_main_thread_process_queued_calls();
   addr = Atomics.load(HEAP32, __main_thread_futex_wait_address >> 2);
  }
  return 0;
 }
}
Module["_emscripten_futex_wait"] = _emscripten_futex_wait;
function _emscripten_futex_wake(addr, count) {
 if (addr <= 0 || addr > HEAP8.length || addr & 3 != 0 || count < 0) return -22;
 if (count == 0) return 0;
 if (count >= 2147483647) count = Infinity;
 var mainThreadWaitAddress = Atomics.load(HEAP32, __main_thread_futex_wait_address >> 2);
 var mainThreadWoken = 0;
 if (mainThreadWaitAddress == addr) {
  var loadedAddr = Atomics.compareExchange(HEAP32, __main_thread_futex_wait_address >> 2, mainThreadWaitAddress, 0);
  if (loadedAddr == mainThreadWaitAddress) {
   --count;
   mainThreadWoken = 1;
   if (count <= 0) return 1;
  }
 }
 var ret = Atomics.notify(HEAP32, addr >> 2, count);
 if (ret >= 0) return ret + mainThreadWoken;
 throw "Atomics.notify returned an unexpected value " + ret;
}
Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
function _emscripten_get_heap_size() {
 return HEAP8.length;
}
Module["_emscripten_get_heap_size"] = _emscripten_get_heap_size;
function _emscripten_has_threading_support() {
 return typeof SharedArrayBuffer !== "undefined";
}
Module["_emscripten_has_threading_support"] = _emscripten_has_threading_support;
function _emscripten_proxy_to_main_thread_js(index, sync) {
 var numCallArgs = arguments.length - 2;
 var stack = stackSave();
 var buffer = stackAlloc(numCallArgs * 8);
 for (var i = 0; i < numCallArgs; i++) {
  GROWABLE_HEAP_STORE_F64(((buffer >> 3) + i) * 8 | 0, arguments[2 + i]);
 }
 var ret = _emscripten_run_in_main_runtime_thread_js(index, numCallArgs, buffer, sync);
 stackRestore(stack);
 return ret;
}
Module["_emscripten_proxy_to_main_thread_js"] = _emscripten_proxy_to_main_thread_js;
function _emscripten_receive_on_main_thread_js(index, numCallArgs, buffer) {
 if (!_emscripten_receive_on_main_thread_js.callArgs) {
  _emscripten_receive_on_main_thread_js.callArgs = [];
 }
 var callArgs = _emscripten_receive_on_main_thread_js.callArgs;
 callArgs.length = numCallArgs;
 for (var i = 0; i < numCallArgs; i++) {
  callArgs[i] = GROWABLE_HEAP_LOAD_F64(((buffer >> 3) + i) * 8 | 0);
 }
 var func;
 if (index > 0) {
  func = proxiedFunctionTable[index];
 } else {
  func = ASM_CONSTS[-index - 1];
 }
 assert(func.length == numCallArgs);
 return func.apply(null, callArgs);
}
Module["_emscripten_receive_on_main_thread_js"] = _emscripten_receive_on_main_thread_js;
var JSEvents = {
 keyEvent: 0,
 mouseEvent: 0,
 wheelEvent: 0,
 uiEvent: 0,
 focusEvent: 0,
 deviceOrientationEvent: 0,
 deviceMotionEvent: 0,
 fullscreenChangeEvent: 0,
 pointerlockChangeEvent: 0,
 visibilityChangeEvent: 0,
 touchEvent: 0,
 previousFullscreenElement: null,
 previousScreenX: null,
 previousScreenY: null,
 removeEventListenersRegistered: false,
 removeAllEventListeners: (function() {
  for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
   JSEvents._removeHandler(i);
  }
  JSEvents.eventHandlers = [];
  JSEvents.deferredCalls = [];
 }),
 registerRemoveEventListeners: (function() {
  if (!JSEvents.removeEventListenersRegistered) {
   __ATEXIT__.push(JSEvents.removeAllEventListeners);
   JSEvents.removeEventListenersRegistered = true;
  }
 }),
 deferredCalls: [],
 deferCall: (function(targetFunction, precedence, argsList) {
  function arraysHaveEqualContent(arrA, arrB) {
   if (arrA.length != arrB.length) return false;
   for (var i in arrA) {
    if (arrA[i] != arrB[i]) return false;
   }
   return true;
  }
  for (var i in JSEvents.deferredCalls) {
   var call = JSEvents.deferredCalls[i];
   if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
    return;
   }
  }
  JSEvents.deferredCalls.push({
   targetFunction: targetFunction,
   precedence: precedence,
   argsList: argsList
  });
  JSEvents.deferredCalls.sort((function(x, y) {
   return x.precedence < y.precedence;
  }));
 }),
 removeDeferredCalls: (function(targetFunction) {
  for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
   if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
    JSEvents.deferredCalls.splice(i, 1);
    --i;
   }
  }
 }),
 canPerformEventHandlerRequests: (function() {
  return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
 }),
 runDeferredCalls: (function() {
  if (!JSEvents.canPerformEventHandlerRequests()) {
   return;
  }
  for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
   var call = JSEvents.deferredCalls[i];
   JSEvents.deferredCalls.splice(i, 1);
   --i;
   call.targetFunction.apply(this, call.argsList);
  }
 }),
 inEventHandler: 0,
 currentEventHandler: null,
 eventHandlers: [],
 isInternetExplorer: (function() {
  return navigator.userAgent.indexOf("MSIE") !== -1 || navigator.appVersion.indexOf("Trident/") > 0;
 }),
 removeAllHandlersOnTarget: (function(target, eventTypeString) {
  for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
   if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
    JSEvents._removeHandler(i--);
   }
  }
 }),
 _removeHandler: (function(i) {
  var h = JSEvents.eventHandlers[i];
  h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
  JSEvents.eventHandlers.splice(i, 1);
 }),
 registerOrRemoveHandler: (function(eventHandler) {
  var jsEventHandler = function jsEventHandler(event) {
   ++JSEvents.inEventHandler;
   JSEvents.currentEventHandler = eventHandler;
   JSEvents.runDeferredCalls();
   eventHandler.handlerFunc(event);
   JSEvents.runDeferredCalls();
   --JSEvents.inEventHandler;
  };
  if (eventHandler.callbackfunc) {
   eventHandler.eventListenerFunc = jsEventHandler;
   eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
   JSEvents.eventHandlers.push(eventHandler);
   JSEvents.registerRemoveEventListeners();
  } else {
   for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
    if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
     JSEvents._removeHandler(i--);
    }
   }
  }
 }),
 queueEventHandlerOnThread_iiii: (function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
  var stackTop = stackSave();
  var varargs = stackAlloc(12);
  GROWABLE_HEAP_STORE_I32(varargs | 0, eventTypeId);
  GROWABLE_HEAP_STORE_I32(varargs + 4 | 0, eventData);
  GROWABLE_HEAP_STORE_I32(varargs + 8 | 0, userData);
  _emscripten_async_queue_on_thread_(targetThread, 637534208, eventHandlerFunc, eventData, varargs);
  stackRestore(stackTop);
 }),
 getTargetThreadForEventCallback: (function(targetThread) {
  switch (targetThread) {
  case 1:
   return 0;
  case 2:
   return PThread.currentProxiedOperationCallerThread;
  default:
   return targetThread;
  }
 }),
 getBoundingClientRectOrZeros: (function(target) {
  return target.getBoundingClientRect ? target.getBoundingClientRect() : {
   left: 0,
   top: 0
  };
 }),
 pageScrollPos: (function() {
  if (pageXOffset > 0 || pageYOffset > 0) {
   return [ pageXOffset, pageYOffset ];
  }
  if (typeof document.documentElement.scrollLeft !== "undefined" || typeof document.documentElement.scrollTop !== "undefined") {
   return [ document.documentElement.scrollLeft, document.documentElement.scrollTop ];
  }
  return [ document.body.scrollLeft | 0, document.body.scrollTop | 0 ];
 }),
 getNodeNameForTarget: (function(target) {
  if (!target) return "";
  if (target == window) return "#window";
  if (target == screen) return "#screen";
  return target && target.nodeName ? target.nodeName : "";
 }),
 tick: (function() {
  if (window["performance"] && window["performance"]["now"]) return window["performance"]["now"](); else return Date.now();
 }),
 fullscreenEnabled: (function() {
  return document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled;
 })
};
Module["JSEvents"] = JSEvents;
function stringToNewUTF8(jsString) {
 var length = lengthBytesUTF8(jsString) + 1;
 var cString = _malloc(length);
 stringToUTF8(jsString, cString, length);
 return cString;
}
Module["stringToNewUTF8"] = stringToNewUTF8;
function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
 var stackTop = stackSave();
 var varargs = stackAlloc(12);
 var targetCanvasPtr = 0;
 if (targetCanvas) {
  targetCanvasPtr = stringToNewUTF8(targetCanvas);
 }
 GROWABLE_HEAP_STORE_I32(varargs | 0, targetCanvasPtr);
 GROWABLE_HEAP_STORE_I32(varargs + 4 | 0, width);
 GROWABLE_HEAP_STORE_I32(varargs + 8 | 0, height);
 _emscripten_async_queue_on_thread_(targetThread, 657457152, 0, targetCanvasPtr, varargs);
 stackRestore(stackTop);
}
Module["_emscripten_set_offscreencanvas_size_on_target_thread_js"] = _emscripten_set_offscreencanvas_size_on_target_thread_js;
function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
 targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
 _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
}
Module["_emscripten_set_offscreencanvas_size_on_target_thread"] = _emscripten_set_offscreencanvas_size_on_target_thread;
var __specialEventTargets = [ 0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0 ];
Module["__specialEventTargets"] = __specialEventTargets;
function __findEventTarget(target) {
 warnOnce("Rules for selecting event targets in HTML5 API are changing: instead of using document.getElementById() that only can refer to elements by their DOM ID, new event target selection mechanism uses the more flexible function document.querySelector() that can look up element names, classes, and complex CSS selectors. Build with -s DISABLE_DEPRECATED_FIND_EVENT_TARGET_BEHAVIOR=1 to change to the new lookup rules. See https://github.com/emscripten-core/emscripten/pull/7977 for more details.");
 try {
  if (!target) return window;
  if (typeof target === "number") target = __specialEventTargets[target] || UTF8ToString(target);
  if (target === "#window") return window; else if (target === "#document") return document; else if (target === "#screen") return screen; else if (target === "#canvas") return Module["canvas"];
  return typeof target === "string" ? document.getElementById(target) : target;
 } catch (e) {
  return null;
 }
}
Module["__findEventTarget"] = __findEventTarget;
function __findCanvasEventTarget(target) {
 if (typeof target === "number") target = UTF8ToString(target);
 if (!target || target === "#canvas") {
  if (typeof GL !== "undefined" && GL.offscreenCanvases["canvas"]) return GL.offscreenCanvases["canvas"];
  return Module["canvas"];
 }
 if (typeof GL !== "undefined" && GL.offscreenCanvases[target]) return GL.offscreenCanvases[target];
 return __findEventTarget(target);
}
Module["__findCanvasEventTarget"] = __findCanvasEventTarget;
function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
 var canvas = __findCanvasEventTarget(target);
 if (!canvas) return -4;
 if (canvas.canvasSharedPtr) {
  GROWABLE_HEAP_STORE_I32(canvas.canvasSharedPtr | 0, width);
  GROWABLE_HEAP_STORE_I32(canvas.canvasSharedPtr + 4 | 0, height);
 }
 if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
  if (canvas.offscreenCanvas) canvas = canvas.offscreenCanvas;
  var autoResizeViewport = false;
  if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
   var prevViewport = canvas.GLctxObject.GLctx.getParameter(canvas.GLctxObject.GLctx.VIEWPORT);
   autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
  }
  canvas.width = width;
  canvas.height = height;
  if (autoResizeViewport) {
   canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
  }
 } else if (canvas.canvasSharedPtr) {
  var targetThread = GROWABLE_HEAP_LOAD_I32(canvas.canvasSharedPtr + 8 | 0);
  _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
  return 1;
 } else {
  return -4;
 }
 return 0;
}
Module["_emscripten_set_canvas_element_size_calling_thread"] = _emscripten_set_canvas_element_size_calling_thread;
function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(19, 1, target, width, height);
 return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
}
Module["_emscripten_set_canvas_element_size_main_thread"] = _emscripten_set_canvas_element_size_main_thread;
function _emscripten_set_canvas_element_size(target, width, height) {
 var canvas = __findCanvasEventTarget(target);
 if (canvas) {
  return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
 } else {
  return _emscripten_set_canvas_element_size_main_thread(target, width, height);
 }
}
Module["_emscripten_set_canvas_element_size"] = _emscripten_set_canvas_element_size;
function _emscripten_set_current_thread_status_js(newStatus) {}
Module["_emscripten_set_current_thread_status_js"] = _emscripten_set_current_thread_status_js;
function ___set_network_callback(event, userData, callback) {
 function _callback(data) {
  try {
   if (event === "error") {
    var sp = stackSave();
    var msg = allocate(intArrayFromString(data[2]), "i8", ALLOC_STACK);
    dynCall_viiii(callback, data[0], data[1], msg, userData);
    stackRestore(sp);
   } else {
    dynCall_vii(callback, data, userData);
   }
  } catch (e) {
   if (e instanceof ExitStatus) {
    return;
   } else {
    if (e && typeof e === "object" && e.stack) err("exception thrown: " + [ e, e.stack ]);
    throw e;
   }
  }
 }
 Module["noExitRuntime"] = true;
 Module["websocket"]["on"](event, callback ? _callback : null);
}
Module["___set_network_callback"] = ___set_network_callback;
function _emscripten_set_socket_close_callback(userData, callback) {
 ___set_network_callback("close", userData, callback);
}
Module["_emscripten_set_socket_close_callback"] = _emscripten_set_socket_close_callback;
function _emscripten_set_socket_error_callback(userData, callback) {
 ___set_network_callback("error", userData, callback);
}
Module["_emscripten_set_socket_error_callback"] = _emscripten_set_socket_error_callback;
function _emscripten_set_socket_message_callback(userData, callback) {
 ___set_network_callback("message", userData, callback);
}
Module["_emscripten_set_socket_message_callback"] = _emscripten_set_socket_message_callback;
function _emscripten_set_socket_open_callback(userData, callback) {
 ___set_network_callback("open", userData, callback);
}
Module["_emscripten_set_socket_open_callback"] = _emscripten_set_socket_open_callback;
function _emscripten_set_thread_name_js(threadId, name) {}
Module["_emscripten_set_thread_name_js"] = _emscripten_set_thread_name_js;
var Fetch = {
 xhrs: [],
 setu64: (function(addr, val) {
  GROWABLE_HEAP_STORE_I32(addr | 0, val);
  GROWABLE_HEAP_STORE_I32(addr + 4 | 0, val / 4294967296 | 0);
 }),
 openDatabase: (function(dbname, dbversion, onsuccess, onerror) {
  try {
   var openRequest = indexedDB.open(dbname, dbversion);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = (function(event) {
   var db = event.target.result;
   if (db.objectStoreNames.contains("FILES")) {
    db.deleteObjectStore("FILES");
   }
   db.createObjectStore("FILES");
  });
  openRequest.onsuccess = (function(event) {
   onsuccess(event.target.result);
  });
  openRequest.onerror = (function(error) {
   onerror(error);
  });
 }),
 initFetchWorker: (function() {
  var stackSize = 128 * 1024;
  var stack = allocate(stackSize >> 2, "i32*", ALLOC_DYNAMIC);
  Fetch.worker.postMessage({
   cmd: "init",
   DYNAMICTOP_PTR: DYNAMICTOP_PTR,
   STACKTOP: stack,
   STACK_MAX: stack + stackSize,
   queuePtr: _fetch_work_queue,
   buffer: HEAPU8.buffer
  });
 }),
 staticInit: (function() {
  var isMainThread = typeof ENVIRONMENT_IS_FETCH_WORKER === "undefined" && !ENVIRONMENT_IS_PTHREAD;
  var onsuccess = (function(db) {
   Fetch.dbInstance = db;
   if (isMainThread) {
    Fetch.initFetchWorker();
    removeRunDependency("library_fetch_init");
   }
  });
  var onerror = (function() {
   Fetch.dbInstance = false;
   if (isMainThread) {
    Fetch.initFetchWorker();
    removeRunDependency("library_fetch_init");
   }
  });
  Fetch.openDatabase("emscripten_filesystem", 1, onsuccess, onerror);
  if (isMainThread) {
   addRunDependency("library_fetch_init");
   var fetchJs = locateFile("hsimsweb.fetch.js");
   Fetch.worker = new Worker(fetchJs);
   Fetch.worker.onmessage = (function(e) {
    out("fetch-worker sent a message: " + e.filename + ":" + e.lineno + ": " + e.message);
   });
   Fetch.worker.onerror = (function(e) {
    err("fetch-worker sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
   });
  }
 })
};
Module["Fetch"] = Fetch;
function __emscripten_fetch_xhr(fetch, onsuccess, onerror, onprogress, onreadystatechange) {
 var url = GROWABLE_HEAP_LOAD_U32(fetch + 8 | 0);
 if (!url) {
  onerror(fetch, 0, "no url specified!");
  return;
 }
 var url_ = UTF8ToString(url);
 var fetch_attr = fetch + 112;
 var requestMethod = UTF8ToString(fetch_attr);
 if (!requestMethod) requestMethod = "GET";
 var userData = GROWABLE_HEAP_LOAD_U32(fetch_attr + 32 | 0);
 var fetchAttributes = GROWABLE_HEAP_LOAD_U32(fetch_attr + 52 | 0);
 var timeoutMsecs = GROWABLE_HEAP_LOAD_U32(fetch_attr + 56 | 0);
 var withCredentials = !!GROWABLE_HEAP_LOAD_U32(fetch_attr + 60 | 0);
 var destinationPath = GROWABLE_HEAP_LOAD_U32(fetch_attr + 64 | 0);
 var userName = GROWABLE_HEAP_LOAD_U32(fetch_attr + 68 | 0);
 var password = GROWABLE_HEAP_LOAD_U32(fetch_attr + 72 | 0);
 var requestHeaders = GROWABLE_HEAP_LOAD_U32(fetch_attr + 76 | 0);
 var overriddenMimeType = GROWABLE_HEAP_LOAD_U32(fetch_attr + 80 | 0);
 var dataPtr = GROWABLE_HEAP_LOAD_U32(fetch_attr + 84 | 0);
 var dataLength = GROWABLE_HEAP_LOAD_U32(fetch_attr + 88 | 0);
 var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
 var fetchAttrStreamData = !!(fetchAttributes & 2);
 var fetchAttrPersistFile = !!(fetchAttributes & 4);
 var fetchAttrAppend = !!(fetchAttributes & 8);
 var fetchAttrReplace = !!(fetchAttributes & 16);
 var fetchAttrSynchronous = !!(fetchAttributes & 64);
 var fetchAttrWaitable = !!(fetchAttributes & 128);
 var userNameStr = userName ? UTF8ToString(userName) : undefined;
 var passwordStr = password ? UTF8ToString(password) : undefined;
 var overriddenMimeTypeStr = overriddenMimeType ? UTF8ToString(overriddenMimeType) : undefined;
 var xhr = new XMLHttpRequest;
 xhr.withCredentials = withCredentials;
 xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
 if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs;
 xhr.url_ = url_;
 assert(!fetchAttrStreamData, "streaming uses moz-chunked-arraybuffer which is no longer supported; TODO: rewrite using fetch()");
 xhr.responseType = "arraybuffer";
 if (overriddenMimeType) {
  xhr.overrideMimeType(overriddenMimeTypeStr);
 }
 if (requestHeaders) {
  for (;;) {
   var key = GROWABLE_HEAP_LOAD_U32(requestHeaders | 0);
   if (!key) break;
   var value = GROWABLE_HEAP_LOAD_U32(requestHeaders + 4 | 0);
   if (!value) break;
   requestHeaders += 8;
   var keyStr = UTF8ToString(key);
   var valueStr = UTF8ToString(value);
   xhr.setRequestHeader(keyStr, valueStr);
  }
 }
 Fetch.xhrs.push(xhr);
 var id = Fetch.xhrs.length;
 GROWABLE_HEAP_STORE_I32(fetch + 0 | 0, id);
 var data = dataPtr && dataLength ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
 xhr.onload = (function(e) {
  var len = xhr.response ? xhr.response.byteLength : 0;
  var ptr = 0;
  var ptrLen = 0;
  if (fetchAttrLoadToMemory && !fetchAttrStreamData) {
   ptrLen = len;
   ptr = _malloc(ptrLen);
   HEAPU8.set(new Uint8Array(xhr.response), ptr);
  }
  GROWABLE_HEAP_STORE_I32(fetch + 12 | 0, ptr);
  Fetch.setu64(fetch + 16, ptrLen);
  Fetch.setu64(fetch + 24, 0);
  if (len) {
   Fetch.setu64(fetch + 32, len);
  }
  GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, xhr.readyState);
  if (xhr.readyState === 4 && xhr.status === 0) {
   if (len > 0) xhr.status = 200; else xhr.status = 404;
  }
  GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, xhr.status);
  if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
  if (xhr.status >= 200 && xhr.status < 300) {
   if (onsuccess) onsuccess(fetch, xhr, e);
  } else {
   if (onerror) onerror(fetch, xhr, e);
  }
 });
 xhr.onerror = (function(e) {
  var status = xhr.status;
  if (xhr.readyState === 4 && status === 0) status = 404;
  GROWABLE_HEAP_STORE_I32(fetch + 12 | 0, 0);
  Fetch.setu64(fetch + 16, 0);
  Fetch.setu64(fetch + 24, 0);
  Fetch.setu64(fetch + 32, 0);
  GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, xhr.readyState);
  GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, status);
  if (onerror) onerror(fetch, xhr, e);
 });
 xhr.ontimeout = (function(e) {
  if (onerror) onerror(fetch, xhr, e);
 });
 xhr.onprogress = (function(e) {
  var ptrLen = fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response ? xhr.response.byteLength : 0;
  var ptr = 0;
  if (fetchAttrLoadToMemory && fetchAttrStreamData) {
   ptr = _malloc(ptrLen);
   HEAPU8.set(new Uint8Array(xhr.response), ptr);
  }
  GROWABLE_HEAP_STORE_I32(fetch + 12 | 0, ptr);
  Fetch.setu64(fetch + 16, ptrLen);
  Fetch.setu64(fetch + 24, e.loaded - ptrLen);
  Fetch.setu64(fetch + 32, e.total);
  GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, xhr.readyState);
  if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200;
  GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, xhr.status);
  if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
  if (onprogress) onprogress(fetch, xhr, e);
 });
 xhr.onreadystatechange = (function(e) {
  GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, xhr.readyState);
  if (xhr.readyState >= 2) {
   GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, xhr.status);
  }
  if (onreadystatechange) onreadystatechange(fetch, xhr, e);
 });
 try {
  xhr.send(data);
 } catch (e) {
  if (onerror) onerror(fetch, xhr, e);
 }
}
Module["__emscripten_fetch_xhr"] = __emscripten_fetch_xhr;
function __emscripten_fetch_cache_data(db, fetch, data, onsuccess, onerror) {
 if (!db) {
  onerror(fetch, 0, "IndexedDB not available!");
  return;
 }
 var fetch_attr = fetch + 112;
 var destinationPath = GROWABLE_HEAP_LOAD_U32(fetch_attr + 64 | 0);
 if (!destinationPath) destinationPath = GROWABLE_HEAP_LOAD_U32(fetch + 8 | 0);
 var destinationPathStr = UTF8ToString(destinationPath);
 try {
  var transaction = db.transaction([ "FILES" ], "readwrite");
  var packages = transaction.objectStore("FILES");
  var putRequest = packages.put(data, destinationPathStr);
  putRequest.onsuccess = (function(event) {
   GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, 4);
   GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, 200);
   stringToUTF8("OK", fetch + 44, 64);
   onsuccess(fetch, 0, destinationPathStr);
  });
  putRequest.onerror = (function(error) {
   GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, 4);
   GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, 413);
   stringToUTF8("Payload Too Large", fetch + 44, 64);
   onerror(fetch, 0, error);
  });
 } catch (e) {
  onerror(fetch, 0, e);
 }
}
Module["__emscripten_fetch_cache_data"] = __emscripten_fetch_cache_data;
function __emscripten_fetch_load_cached_data(db, fetch, onsuccess, onerror) {
 if (!db) {
  onerror(fetch, 0, "IndexedDB not available!");
  return;
 }
 var fetch_attr = fetch + 112;
 var path = GROWABLE_HEAP_LOAD_U32(fetch_attr + 64 | 0);
 if (!path) path = GROWABLE_HEAP_LOAD_U32(fetch + 8 | 0);
 var pathStr = UTF8ToString(path);
 try {
  var transaction = db.transaction([ "FILES" ], "readonly");
  var packages = transaction.objectStore("FILES");
  var getRequest = packages.get(pathStr);
  getRequest.onsuccess = (function(event) {
   if (event.target.result) {
    var value = event.target.result;
    var len = value.byteLength || value.length;
    var ptr = _malloc(len);
    HEAPU8.set(new Uint8Array(value), ptr);
    GROWABLE_HEAP_STORE_I32(fetch + 12 | 0, ptr);
    Fetch.setu64(fetch + 16, len);
    Fetch.setu64(fetch + 24, 0);
    Fetch.setu64(fetch + 32, len);
    GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, 4);
    GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, 200);
    stringToUTF8("OK", fetch + 44, 64);
    onsuccess(fetch, 0, value);
   } else {
    GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, 4);
    GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, 404);
    stringToUTF8("Not Found", fetch + 44, 64);
    onerror(fetch, 0, "no data");
   }
  });
  getRequest.onerror = (function(error) {
   GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, 4);
   GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, 404);
   stringToUTF8("Not Found", fetch + 44, 64);
   onerror(fetch, 0, error);
  });
 } catch (e) {
  onerror(fetch, 0, e);
 }
}
Module["__emscripten_fetch_load_cached_data"] = __emscripten_fetch_load_cached_data;
function __emscripten_fetch_delete_cached_data(db, fetch, onsuccess, onerror) {
 if (!db) {
  onerror(fetch, 0, "IndexedDB not available!");
  return;
 }
 var fetch_attr = fetch + 112;
 var path = GROWABLE_HEAP_LOAD_U32(fetch_attr + 64 | 0);
 if (!path) path = GROWABLE_HEAP_LOAD_U32(fetch + 8 | 0);
 var pathStr = UTF8ToString(path);
 try {
  var transaction = db.transaction([ "FILES" ], "readwrite");
  var packages = transaction.objectStore("FILES");
  var request = packages.delete(pathStr);
  request.onsuccess = (function(event) {
   var value = event.target.result;
   GROWABLE_HEAP_STORE_I32(fetch + 12 | 0, 0);
   Fetch.setu64(fetch + 16, 0);
   Fetch.setu64(fetch + 24, 0);
   Fetch.setu64(fetch + 32, 0);
   GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, 4);
   GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, 200);
   stringToUTF8("OK", fetch + 44, 64);
   onsuccess(fetch, 0, value);
  });
  request.onerror = (function(error) {
   GROWABLE_HEAP_STORE_I16(fetch + 40 | 0, 4);
   GROWABLE_HEAP_STORE_I16(fetch + 42 | 0, 404);
   stringToUTF8("Not Found", fetch + 44, 64);
   onerror(fetch, 0, error);
  });
 } catch (e) {
  onerror(fetch, 0, e);
 }
}
Module["__emscripten_fetch_delete_cached_data"] = __emscripten_fetch_delete_cached_data;
function _emscripten_start_fetch(fetch, successcb, errorcb, progresscb, readystatechangecb) {
 if (typeof Module !== "undefined") Module["noExitRuntime"] = true;
 var fetch_attr = fetch + 112;
 var requestMethod = UTF8ToString(fetch_attr);
 var onsuccess = GROWABLE_HEAP_LOAD_U32(fetch_attr + 36 | 0);
 var onerror = GROWABLE_HEAP_LOAD_U32(fetch_attr + 40 | 0);
 var onprogress = GROWABLE_HEAP_LOAD_U32(fetch_attr + 44 | 0);
 var onreadystatechange = GROWABLE_HEAP_LOAD_U32(fetch_attr + 48 | 0);
 var fetchAttributes = GROWABLE_HEAP_LOAD_U32(fetch_attr + 52 | 0);
 var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
 var fetchAttrStreamData = !!(fetchAttributes & 2);
 var fetchAttrPersistFile = !!(fetchAttributes & 4);
 var fetchAttrNoDownload = !!(fetchAttributes & 32);
 var fetchAttrAppend = !!(fetchAttributes & 8);
 var fetchAttrReplace = !!(fetchAttributes & 16);
 var reportSuccess = (function(fetch, xhr, e) {
  if (onsuccess) dynCall_vi(onsuccess, fetch); else if (successcb) successcb(fetch);
 });
 var reportProgress = (function(fetch, xhr, e) {
  if (onprogress) dynCall_vi(onprogress, fetch); else if (progresscb) progresscb(fetch);
 });
 var reportError = (function(fetch, xhr, e) {
  if (onerror) dynCall_vi(onerror, fetch); else if (errorcb) errorcb(fetch);
 });
 var reportReadyStateChange = (function(fetch, xhr, e) {
  if (onreadystatechange) dynCall_vi(onreadystatechange, fetch); else if (readystatechangecb) readystatechangecb(fetch);
 });
 var performUncachedXhr = (function(fetch, xhr, e) {
  __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress, reportReadyStateChange);
 });
 var cacheResultAndReportSuccess = (function(fetch, xhr, e) {
  var storeSuccess = (function(fetch, xhr, e) {
   if (onsuccess) dynCall_vi(onsuccess, fetch); else if (successcb) successcb(fetch);
  });
  var storeError = (function(fetch, xhr, e) {
   if (onsuccess) dynCall_vi(onsuccess, fetch); else if (successcb) successcb(fetch);
  });
  __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
 });
 var performCachedXhr = (function(fetch, xhr, e) {
  __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress, reportReadyStateChange);
 });
 var needsIndexedDbConnection = !fetchAttrReplace || requestMethod === "EM_IDB_STORE" || requestMethod === "EM_IDB_DELETE";
 if (needsIndexedDbConnection && !Fetch.dbInstance) {
  reportError(fetch, 0, "IndexedDB is not open");
  return 0;
 }
 if (requestMethod === "EM_IDB_STORE") {
  var ptr = GROWABLE_HEAP_LOAD_U32(fetch_attr + 84 | 0);
  __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, HEAPU8.slice(ptr, ptr + GROWABLE_HEAP_LOAD_U32(fetch_attr + 88 | 0)), reportSuccess, reportError);
 } else if (requestMethod === "EM_IDB_DELETE") {
  __emscripten_fetch_delete_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
 } else if (!fetchAttrReplace) {
  __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, fetchAttrNoDownload ? reportError : fetchAttrPersistFile ? performCachedXhr : performUncachedXhr);
 } else if (!fetchAttrNoDownload) {
  __emscripten_fetch_xhr(fetch, fetchAttrPersistFile ? cacheResultAndReportSuccess : reportSuccess, reportError, reportProgress, reportReadyStateChange);
 } else {
  return 0;
 }
 return fetch;
}
Module["_emscripten_start_fetch"] = _emscripten_start_fetch;
function _emscripten_syscall(which, varargs) {
 switch (which) {
 case 10:
  return ___syscall10(which, varargs);
 case 102:
  return ___syscall102(which, varargs);
 case 122:
  return ___syscall122(which, varargs);
 case 140:
  return ___syscall140(which, varargs);
 case 142:
  return ___syscall142(which, varargs);
 case 145:
  return ___syscall145(which, varargs);
 case 146:
  return ___syscall146(which, varargs);
 case 195:
  return ___syscall195(which, varargs);
 case 20:
  return ___syscall20(which, varargs);
 case 220:
  return ___syscall220(which, varargs);
 case 221:
  return ___syscall221(which, varargs);
 case 38:
  return ___syscall38(which, varargs);
 case 39:
  return ___syscall39(which, varargs);
 case 40:
  return ___syscall40(which, varargs);
 case 5:
  return ___syscall5(which, varargs);
 case 54:
  return ___syscall54(which, varargs);
 case 6:
  return ___syscall6(which, varargs);
 case 91:
  return ___syscall91(which, varargs);
 default:
  throw "surprising proxied syscall: " + which;
 }
}
Module["_emscripten_syscall"] = _emscripten_syscall;
var GL = {
 counter: 1,
 lastError: 0,
 buffers: [],
 mappedBuffers: {},
 programs: [],
 framebuffers: [],
 renderbuffers: [],
 textures: [],
 uniforms: [],
 shaders: [],
 vaos: [],
 contexts: {},
 currentContext: null,
 offscreenCanvases: {},
 timerQueriesEXT: [],
 programInfos: {},
 stringCache: {},
 unpackAlignment: 4,
 init: (function() {
  GL.miniTempBuffer = new Float32Array(GL.MINI_TEMP_BUFFER_SIZE);
  for (var i = 0; i < GL.MINI_TEMP_BUFFER_SIZE; i++) {
   GL.miniTempBufferViews[i] = GL.miniTempBuffer.subarray(0, i + 1);
  }
 }),
 recordError: function recordError(errorCode) {
  if (!GL.lastError) {
   GL.lastError = errorCode;
  }
 },
 getNewId: (function(table) {
  var ret = GL.counter++;
  for (var i = table.length; i < ret; i++) {
   table[i] = null;
  }
  return ret;
 }),
 MINI_TEMP_BUFFER_SIZE: 256,
 miniTempBuffer: null,
 miniTempBufferViews: [ 0 ],
 getSource: (function(shader, count, string, length) {
  var source = "";
  for (var i = 0; i < count; ++i) {
   var len = length ? GROWABLE_HEAP_LOAD_I32(length + i * 4 | 0) : -1;
   source += UTF8ToString(GROWABLE_HEAP_LOAD_I32(string + i * 4 | 0), len < 0 ? undefined : len);
  }
  return source;
 }),
 createContext: (function(canvas, webGLContextAttributes) {
  var ctx = canvas.getContext("webgl", webGLContextAttributes) || canvas.getContext("experimental-webgl", webGLContextAttributes);
  return ctx ? GL.registerContext(ctx, webGLContextAttributes) : 0;
 }),
 registerContext: (function(ctx, webGLContextAttributes) {
  var handle = _malloc(8);
  GROWABLE_HEAP_STORE_I32(handle + 4 | 0, _pthread_self());
  var context = {
   handle: handle,
   attributes: webGLContextAttributes,
   version: webGLContextAttributes.majorVersion,
   GLctx: ctx
  };
  if (ctx.canvas) ctx.canvas.GLctxObject = context;
  GL.contexts[handle] = context;
  if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
   GL.initExtensions(context);
  }
  return handle;
 }),
 makeContextCurrent: (function(contextHandle) {
  GL.currentContext = GL.contexts[contextHandle];
  Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
  return !(contextHandle && !GLctx);
 }),
 getContext: (function(contextHandle) {
  return GL.contexts[contextHandle];
 }),
 deleteContext: (function(contextHandle) {
  if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
  if (typeof JSEvents === "object") JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
  if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined;
  _free(GL.contexts[contextHandle]);
  GL.contexts[contextHandle] = null;
 }),
 acquireInstancedArraysExtension: (function(ctx) {
  var ext = ctx.getExtension("ANGLE_instanced_arrays");
  if (ext) {
   ctx["vertexAttribDivisor"] = (function(index, divisor) {
    ext["vertexAttribDivisorANGLE"](index, divisor);
   });
   ctx["drawArraysInstanced"] = (function(mode, first, count, primcount) {
    ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
   });
   ctx["drawElementsInstanced"] = (function(mode, count, type, indices, primcount) {
    ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
   });
  }
 }),
 acquireVertexArrayObjectExtension: (function(ctx) {
  var ext = ctx.getExtension("OES_vertex_array_object");
  if (ext) {
   ctx["createVertexArray"] = (function() {
    return ext["createVertexArrayOES"]();
   });
   ctx["deleteVertexArray"] = (function(vao) {
    ext["deleteVertexArrayOES"](vao);
   });
   ctx["bindVertexArray"] = (function(vao) {
    ext["bindVertexArrayOES"](vao);
   });
   ctx["isVertexArray"] = (function(vao) {
    return ext["isVertexArrayOES"](vao);
   });
  }
 }),
 acquireDrawBuffersExtension: (function(ctx) {
  var ext = ctx.getExtension("WEBGL_draw_buffers");
  if (ext) {
   ctx["drawBuffers"] = (function(n, bufs) {
    ext["drawBuffersWEBGL"](n, bufs);
   });
  }
 }),
 initExtensions: (function(context) {
  if (!context) context = GL.currentContext;
  if (context.initExtensionsDone) return;
  context.initExtensionsDone = true;
  var GLctx = context.GLctx;
  if (context.version < 2) {
   GL.acquireInstancedArraysExtension(GLctx);
   GL.acquireVertexArrayObjectExtension(GLctx);
   GL.acquireDrawBuffersExtension(GLctx);
  }
  GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
  var automaticallyEnabledExtensions = [ "OES_texture_float", "OES_texture_half_float", "OES_standard_derivatives", "OES_vertex_array_object", "WEBGL_compressed_texture_s3tc", "WEBGL_depth_texture", "OES_element_index_uint", "EXT_texture_filter_anisotropic", "EXT_frag_depth", "WEBGL_draw_buffers", "ANGLE_instanced_arrays", "OES_texture_float_linear", "OES_texture_half_float_linear", "EXT_blend_minmax", "EXT_shader_texture_lod", "WEBGL_compressed_texture_pvrtc", "EXT_color_buffer_half_float", "WEBGL_color_buffer_float", "EXT_sRGB", "WEBGL_compressed_texture_etc1", "EXT_disjoint_timer_query", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_astc", "EXT_color_buffer_float", "WEBGL_compressed_texture_s3tc_srgb", "EXT_disjoint_timer_query_webgl2" ];
  function shouldEnableAutomatically(extension) {
   var ret = false;
   automaticallyEnabledExtensions.forEach((function(include) {
    if (extension.indexOf(include) != -1) {
     ret = true;
    }
   }));
   return ret;
  }
  var exts = GLctx.getSupportedExtensions();
  if (exts && exts.length > 0) {
   GLctx.getSupportedExtensions().forEach((function(ext) {
    if (automaticallyEnabledExtensions.indexOf(ext) != -1) {
     GLctx.getExtension(ext);
    }
   }));
  }
 }),
 populateUniformTable: (function(program) {
  var p = GL.programs[program];
  var ptable = GL.programInfos[program] = {
   uniforms: {},
   maxUniformLength: 0,
   maxAttributeLength: -1,
   maxUniformBlockNameLength: -1
  };
  var utable = ptable.uniforms;
  var numUniforms = GLctx.getProgramParameter(p, 35718);
  for (var i = 0; i < numUniforms; ++i) {
   var u = GLctx.getActiveUniform(p, i);
   var name = u.name;
   ptable.maxUniformLength = Math.max(ptable.maxUniformLength, name.length + 1);
   if (name.slice(-1) == "]") {
    name = name.slice(0, name.lastIndexOf("["));
   }
   var loc = GLctx.getUniformLocation(p, name);
   if (loc) {
    var id = GL.getNewId(GL.uniforms);
    utable[name] = [ u.size, id ];
    GL.uniforms[id] = loc;
    for (var j = 1; j < u.size; ++j) {
     var n = name + "[" + j + "]";
     loc = GLctx.getUniformLocation(p, n);
     id = GL.getNewId(GL.uniforms);
     GL.uniforms[id] = loc;
    }
   }
  }
 })
};
Module["GL"] = GL;
var __emscripten_webgl_power_preferences = [ "default", "low-power", "high-performance" ];
Module["__emscripten_webgl_power_preferences"] = __emscripten_webgl_power_preferences;
function _emscripten_webgl_do_create_context(target, attributes) {
 assert(attributes);
 var contextAttributes = {};
 var a = attributes >> 2;
 contextAttributes["alpha"] = !!GROWABLE_HEAP_LOAD_I32((a + (0 >> 2)) * 4 | 0);
 contextAttributes["depth"] = !!GROWABLE_HEAP_LOAD_I32((a + (4 >> 2)) * 4 | 0);
 contextAttributes["stencil"] = !!GROWABLE_HEAP_LOAD_I32((a + (8 >> 2)) * 4 | 0);
 contextAttributes["antialias"] = !!GROWABLE_HEAP_LOAD_I32((a + (12 >> 2)) * 4 | 0);
 contextAttributes["premultipliedAlpha"] = !!GROWABLE_HEAP_LOAD_I32((a + (16 >> 2)) * 4 | 0);
 contextAttributes["preserveDrawingBuffer"] = !!GROWABLE_HEAP_LOAD_I32((a + (20 >> 2)) * 4 | 0);
 var powerPreference = GROWABLE_HEAP_LOAD_I32((a + (24 >> 2)) * 4 | 0);
 contextAttributes["powerPreference"] = __emscripten_webgl_power_preferences[powerPreference];
 contextAttributes["failIfMajorPerformanceCaveat"] = !!GROWABLE_HEAP_LOAD_I32((a + (28 >> 2)) * 4 | 0);
 contextAttributes.majorVersion = GROWABLE_HEAP_LOAD_I32((a + (32 >> 2)) * 4 | 0);
 contextAttributes.minorVersion = GROWABLE_HEAP_LOAD_I32((a + (36 >> 2)) * 4 | 0);
 contextAttributes.enableExtensionsByDefault = GROWABLE_HEAP_LOAD_I32((a + (40 >> 2)) * 4 | 0);
 contextAttributes.explicitSwapControl = GROWABLE_HEAP_LOAD_I32((a + (44 >> 2)) * 4 | 0);
 contextAttributes.proxyContextToMainThread = GROWABLE_HEAP_LOAD_I32((a + (48 >> 2)) * 4 | 0);
 contextAttributes.renderViaOffscreenBackBuffer = GROWABLE_HEAP_LOAD_I32((a + (52 >> 2)) * 4 | 0);
 var canvas = __findCanvasEventTarget(target);
 if (!canvas) {
  return 0;
 }
 if (contextAttributes.explicitSwapControl) {
  return 0;
 }
 var contextHandle = GL.createContext(canvas, contextAttributes);
 return contextHandle;
}
Module["_emscripten_webgl_do_create_context"] = _emscripten_webgl_do_create_context;
function _emscripten_webgl_create_context(a0, a1) {
 return _emscripten_webgl_do_create_context(a0, a1);
}
Module["_emscripten_webgl_create_context"] = _emscripten_webgl_create_context;
function _exit(status) {
 exit(status);
}
Module["_exit"] = _exit;
var GAI_ERRNO_MESSAGES = {};
Module["GAI_ERRNO_MESSAGES"] = GAI_ERRNO_MESSAGES;
function _gai_strerror(val) {
 var buflen = 256;
 if (!_gai_strerror.buffer) {
  _gai_strerror.buffer = _malloc(buflen);
  GAI_ERRNO_MESSAGES["0"] = "Success";
  GAI_ERRNO_MESSAGES["" + -1] = "Invalid value for 'ai_flags' field";
  GAI_ERRNO_MESSAGES["" + -2] = "NAME or SERVICE is unknown";
  GAI_ERRNO_MESSAGES["" + -3] = "Temporary failure in name resolution";
  GAI_ERRNO_MESSAGES["" + -4] = "Non-recoverable failure in name res";
  GAI_ERRNO_MESSAGES["" + -6] = "'ai_family' not supported";
  GAI_ERRNO_MESSAGES["" + -7] = "'ai_socktype' not supported";
  GAI_ERRNO_MESSAGES["" + -8] = "SERVICE not supported for 'ai_socktype'";
  GAI_ERRNO_MESSAGES["" + -10] = "Memory allocation failure";
  GAI_ERRNO_MESSAGES["" + -11] = "System error returned in 'errno'";
  GAI_ERRNO_MESSAGES["" + -12] = "Argument buffer overflow";
 }
 var msg = "Unknown error";
 if (val in GAI_ERRNO_MESSAGES) {
  if (GAI_ERRNO_MESSAGES[val].length > buflen - 1) {
   msg = "Message too long";
  } else {
   msg = GAI_ERRNO_MESSAGES[val];
  }
 }
 writeAsciiToMemory(msg, _gai_strerror.buffer);
 return _gai_strerror.buffer;
}
Module["_gai_strerror"] = _gai_strerror;
function _getaddrinfo(node, service, hint, out) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(20, 1, node, service, hint, out);
 var addrs = [];
 var canon = null;
 var addr = 0;
 var port = 0;
 var flags = 0;
 var family = 0;
 var type = 0;
 var proto = 0;
 var ai, last;
 function allocaddrinfo(family, type, proto, canon, addr, port) {
  var sa, salen, ai;
  var res;
  salen = family === 10 ? 28 : 16;
  addr = family === 10 ? __inet_ntop6_raw(addr) : __inet_ntop4_raw(addr);
  sa = _malloc(salen);
  res = __write_sockaddr(sa, family, addr, port);
  assert(!res.errno);
  ai = _malloc(32);
  GROWABLE_HEAP_STORE_I32(ai + 4 | 0, family);
  GROWABLE_HEAP_STORE_I32(ai + 8 | 0, type);
  GROWABLE_HEAP_STORE_I32(ai + 12 | 0, proto);
  GROWABLE_HEAP_STORE_I32(ai + 24 | 0, canon);
  GROWABLE_HEAP_STORE_I32(ai + 20 | 0, sa);
  if (family === 10) {
   GROWABLE_HEAP_STORE_I32(ai + 16 | 0, 28);
  } else {
   GROWABLE_HEAP_STORE_I32(ai + 16 | 0, 16);
  }
  GROWABLE_HEAP_STORE_I32(ai + 28 | 0, 0);
  return ai;
 }
 if (hint) {
  flags = GROWABLE_HEAP_LOAD_I32(hint | 0);
  family = GROWABLE_HEAP_LOAD_I32(hint + 4 | 0);
  type = GROWABLE_HEAP_LOAD_I32(hint + 8 | 0);
  proto = GROWABLE_HEAP_LOAD_I32(hint + 12 | 0);
 }
 if (type && !proto) {
  proto = type === 2 ? 17 : 6;
 }
 if (!type && proto) {
  type = proto === 17 ? 2 : 1;
 }
 if (proto === 0) {
  proto = 6;
 }
 if (type === 0) {
  type = 1;
 }
 if (!node && !service) {
  return -2;
 }
 if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
  return -1;
 }
 if (hint !== 0 && GROWABLE_HEAP_LOAD_I32(hint | 0) & 2 && !node) {
  return -1;
 }
 if (flags & 32) {
  return -2;
 }
 if (type !== 0 && type !== 1 && type !== 2) {
  return -7;
 }
 if (family !== 0 && family !== 2 && family !== 10) {
  return -6;
 }
 if (service) {
  service = UTF8ToString(service);
  port = parseInt(service, 10);
  if (isNaN(port)) {
   if (flags & 1024) {
    return -2;
   }
   return -8;
  }
 }
 if (!node) {
  if (family === 0) {
   family = 2;
  }
  if ((flags & 1) === 0) {
   if (family === 2) {
    addr = _htonl(2130706433);
   } else {
    addr = [ 0, 0, 0, 1 ];
   }
  }
  ai = allocaddrinfo(family, type, proto, null, addr, port);
  GROWABLE_HEAP_STORE_I32(out | 0, ai);
  return 0;
 }
 node = UTF8ToString(node);
 addr = __inet_pton4_raw(node);
 if (addr !== null) {
  if (family === 0 || family === 2) {
   family = 2;
  } else if (family === 10 && flags & 8) {
   addr = [ 0, 0, _htonl(65535), addr ];
   family = 10;
  } else {
   return -2;
  }
 } else {
  addr = __inet_pton6_raw(node);
  if (addr !== null) {
   if (family === 0 || family === 10) {
    family = 10;
   } else {
    return -2;
   }
  }
 }
 if (addr != null) {
  ai = allocaddrinfo(family, type, proto, node, addr, port);
  GROWABLE_HEAP_STORE_I32(out | 0, ai);
  return 0;
 }
 if (flags & 4) {
  return -2;
 }
 node = DNS.lookup_name(node);
 addr = __inet_pton4_raw(node);
 if (family === 0) {
  family = 2;
 } else if (family === 10) {
  addr = [ 0, 0, _htonl(65535), addr ];
 }
 ai = allocaddrinfo(family, type, proto, null, addr, port);
 GROWABLE_HEAP_STORE_I32(out | 0, ai);
 return 0;
}
Module["_getaddrinfo"] = _getaddrinfo;
function _getenv(name) {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(21, 1, name);
 if (name === 0) return 0;
 name = UTF8ToString(name);
 if (!ENV.hasOwnProperty(name)) return 0;
 if (_getenv.ret) _free(_getenv.ret);
 _getenv.ret = allocateUTF8(ENV[name]);
 return _getenv.ret;
}
Module["_getenv"] = _getenv;
function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
 var info = __read_sockaddr(sa, salen);
 if (info.errno) {
  return -6;
 }
 var port = info.port;
 var addr = info.addr;
 var overflowed = false;
 if (node && nodelen) {
  var lookup;
  if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
   if (flags & 8) {
    return -2;
   }
  } else {
   addr = lookup;
  }
  var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
  if (numBytesWrittenExclNull + 1 >= nodelen) {
   overflowed = true;
  }
 }
 if (serv && servlen) {
  port = "" + port;
  var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
  if (numBytesWrittenExclNull + 1 >= servlen) {
   overflowed = true;
  }
 }
 if (overflowed) {
  return -12;
 }
 return 0;
}
Module["_getnameinfo"] = _getnameinfo;
function _gettimeofday(ptr) {
 var now = Date.now();
 GROWABLE_HEAP_STORE_I32(ptr | 0, now / 1e3 | 0);
 GROWABLE_HEAP_STORE_I32(ptr + 4 | 0, now % 1e3 * 1e3 | 0);
 return 0;
}
Module["_gettimeofday"] = _gettimeofday;
var ___tm_timezone;
if (ENVIRONMENT_IS_PTHREAD) ___tm_timezone = PthreadWorkerInit.___tm_timezone; else PthreadWorkerInit.___tm_timezone = ___tm_timezone = (stringToUTF8("GMT", 662208, 4), 662208);
Module["___tm_timezone"] = ___tm_timezone;
function _gmtime_r(time, tmPtr) {
 var date = new Date(GROWABLE_HEAP_LOAD_I32(time | 0) * 1e3);
 GROWABLE_HEAP_STORE_I32(tmPtr | 0, date.getUTCSeconds());
 GROWABLE_HEAP_STORE_I32(tmPtr + 4 | 0, date.getUTCMinutes());
 GROWABLE_HEAP_STORE_I32(tmPtr + 8 | 0, date.getUTCHours());
 GROWABLE_HEAP_STORE_I32(tmPtr + 12 | 0, date.getUTCDate());
 GROWABLE_HEAP_STORE_I32(tmPtr + 16 | 0, date.getUTCMonth());
 GROWABLE_HEAP_STORE_I32(tmPtr + 20 | 0, date.getUTCFullYear() - 1900);
 GROWABLE_HEAP_STORE_I32(tmPtr + 24 | 0, date.getUTCDay());
 GROWABLE_HEAP_STORE_I32(tmPtr + 36 | 0, 0);
 GROWABLE_HEAP_STORE_I32(tmPtr + 32 | 0, 0);
 var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
 var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
 GROWABLE_HEAP_STORE_I32(tmPtr + 28 | 0, yday);
 GROWABLE_HEAP_STORE_I32(tmPtr + 40 | 0, ___tm_timezone);
 return tmPtr;
}
Module["_gmtime_r"] = _gmtime_r;
function _inet_addr(ptr) {
 var addr = __inet_pton4_raw(UTF8ToString(ptr));
 if (addr === null) {
  return -1;
 }
 return addr;
}
Module["_inet_addr"] = _inet_addr;
function _llvm_stackrestore(p) {
 var self = _llvm_stacksave;
 var ret = self.LLVM_SAVEDSTACKS[p];
 self.LLVM_SAVEDSTACKS.splice(p, 1);
 stackRestore(ret);
}
Module["_llvm_stackrestore"] = _llvm_stackrestore;
function _llvm_stacksave() {
 var self = _llvm_stacksave;
 if (!self.LLVM_SAVEDSTACKS) {
  self.LLVM_SAVEDSTACKS = [];
 }
 self.LLVM_SAVEDSTACKS.push(stackSave());
 return self.LLVM_SAVEDSTACKS.length - 1;
}
Module["_llvm_stacksave"] = _llvm_stacksave;
function _llvm_trap() {
 abort("trap!");
}
Module["_llvm_trap"] = _llvm_trap;
var ___tm_current;
if (ENVIRONMENT_IS_PTHREAD) ___tm_current = PthreadWorkerInit.___tm_current; else PthreadWorkerInit.___tm_current = ___tm_current = 662160;
Module["___tm_current"] = ___tm_current;
function _tzset() {
 if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(22, 1);
 if (_tzset.called) return;
 _tzset.called = true;
 GROWABLE_HEAP_STORE_I32(__get_timezone() | 0, (new Date).getTimezoneOffset() * 60);
 var winter = new Date(2e3, 0, 1);
 var summer = new Date(2e3, 6, 1);
 GROWABLE_HEAP_STORE_I32(__get_daylight() | 0, Number(winter.getTimezoneOffset() != summer.getTimezoneOffset()));
 function extractZone(date) {
  var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
  return match ? match[1] : "GMT";
 }
 var winterName = extractZone(winter);
 var summerName = extractZone(summer);
 var winterNamePtr = allocate(intArrayFromString(winterName), "i8", ALLOC_NORMAL);
 var summerNamePtr = allocate(intArrayFromString(summerName), "i8", ALLOC_NORMAL);
 if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
  GROWABLE_HEAP_STORE_I32(__get_tzname() | 0, winterNamePtr);
  GROWABLE_HEAP_STORE_I32(__get_tzname() + 4 | 0, summerNamePtr);
 } else {
  GROWABLE_HEAP_STORE_I32(__get_tzname() | 0, summerNamePtr);
  GROWABLE_HEAP_STORE_I32(__get_tzname() + 4 | 0, winterNamePtr);
 }
}
Module["_tzset"] = _tzset;
function _localtime_r(time, tmPtr) {
 _tzset();
 var date = new Date(GROWABLE_HEAP_LOAD_I32(time | 0) * 1e3);
 GROWABLE_HEAP_STORE_I32(tmPtr | 0, date.getSeconds());
 GROWABLE_HEAP_STORE_I32(tmPtr + 4 | 0, date.getMinutes());
 GROWABLE_HEAP_STORE_I32(tmPtr + 8 | 0, date.getHours());
 GROWABLE_HEAP_STORE_I32(tmPtr + 12 | 0, date.getDate());
 GROWABLE_HEAP_STORE_I32(tmPtr + 16 | 0, date.getMonth());
 GROWABLE_HEAP_STORE_I32(tmPtr + 20 | 0, date.getFullYear() - 1900);
 GROWABLE_HEAP_STORE_I32(tmPtr + 24 | 0, date.getDay());
 var start = new Date(date.getFullYear(), 0, 1);
 var yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0;
 GROWABLE_HEAP_STORE_I32(tmPtr + 28 | 0, yday);
 GROWABLE_HEAP_STORE_I32(tmPtr + 36 | 0, -(date.getTimezoneOffset() * 60));
 var summerOffset = (new Date(2e3, 6, 1)).getTimezoneOffset();
 var winterOffset = start.getTimezoneOffset();
 var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
 GROWABLE_HEAP_STORE_I32(tmPtr + 32 | 0, dst);
 var zonePtr = GROWABLE_HEAP_LOAD_I32(__get_tzname() + (dst ? 4 : 0) | 0);
 GROWABLE_HEAP_STORE_I32(tmPtr + 40 | 0, zonePtr);
 return tmPtr;
}
Module["_localtime_r"] = _localtime_r;
function _localtime(time) {
 return _localtime_r(time, ___tm_current);
}
Module["_localtime"] = _localtime;
function _emscripten_memcpy_big(dest, src, num) {
 HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
}
Module["_emscripten_memcpy_big"] = _emscripten_memcpy_big;
function _mktime(tmPtr) {
 _tzset();
 var date = new Date(GROWABLE_HEAP_LOAD_I32(tmPtr + 20 | 0) + 1900, GROWABLE_HEAP_LOAD_I32(tmPtr + 16 | 0), GROWABLE_HEAP_LOAD_I32(tmPtr + 12 | 0), GROWABLE_HEAP_LOAD_I32(tmPtr + 8 | 0), GROWABLE_HEAP_LOAD_I32(tmPtr + 4 | 0), GROWABLE_HEAP_LOAD_I32(tmPtr | 0), 0);
 var dst = GROWABLE_HEAP_LOAD_I32(tmPtr + 32 | 0);
 var guessedOffset = date.getTimezoneOffset();
 var start = new Date(date.getFullYear(), 0, 1);
 var summerOffset = (new Date(2e3, 6, 1)).getTimezoneOffset();
 var winterOffset = start.getTimezoneOffset();
 var dstOffset = Math.min(winterOffset, summerOffset);
 if (dst < 0) {
  GROWABLE_HEAP_STORE_I32(tmPtr + 32 | 0, Number(summerOffset != winterOffset && dstOffset == guessedOffset));
 } else if (dst > 0 != (dstOffset == guessedOffset)) {
  var nonDstOffset = Math.max(winterOffset, summerOffset);
  var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
  date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
 }
 GROWABLE_HEAP_STORE_I32(tmPtr + 24 | 0, date.getDay());
 var yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0;
 GROWABLE_HEAP_STORE_I32(tmPtr + 28 | 0, yday);
 return date.getTime() / 1e3 | 0;
}
Module["_mktime"] = _mktime;
function _pthread_cleanup_pop(execute) {
 var routine = PThread.exitHandlers.pop();
 if (execute) routine();
}
Module["_pthread_cleanup_pop"] = _pthread_cleanup_pop;
function _pthread_cleanup_push(routine, arg) {
 if (PThread.exitHandlers === null) {
  PThread.exitHandlers = [];
  if (!ENVIRONMENT_IS_PTHREAD) {
   __ATEXIT__.push((function() {
    PThread.runExitHandlers();
   }));
  }
 }
 PThread.exitHandlers.push((function() {
  dynCall_vi(routine, arg);
 }));
}
Module["_pthread_cleanup_push"] = _pthread_cleanup_push;
function __spawn_thread(threadParams) {
 if (ENVIRONMENT_IS_PTHREAD) throw "Internal Error! _spawn_thread() can only ever be called from main application thread!";
 var worker = PThread.getNewWorker();
 if (worker.pthread !== undefined) throw "Internal error!";
 if (!threadParams.pthread_ptr) throw "Internal error, no pthread ptr!";
 PThread.runningWorkers.push(worker);
 var tlsMemory = _malloc(128 * 4);
 for (var i = 0; i < 128; ++i) {
  GROWABLE_HEAP_STORE_I32(tlsMemory + i * 4 | 0, 0);
 }
 var stackHigh = threadParams.stackBase + threadParams.stackSize;
 var pthread = PThread.pthreads[threadParams.pthread_ptr] = {
  worker: worker,
  stackBase: threadParams.stackBase,
  stackSize: threadParams.stackSize,
  allocatedOwnStack: threadParams.allocatedOwnStack,
  thread: threadParams.pthread_ptr,
  threadInfoStruct: threadParams.pthread_ptr
 };
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 0 >> 2, 0);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 4 >> 2, 0);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 20 >> 2, 0);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 80 >> 2, threadParams.detached);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 116 >> 2, tlsMemory);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 60 >> 2, 0);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 52 >> 2, pthread.threadInfoStruct);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 56 >> 2, PROCINFO.pid);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 120 >> 2, threadParams.stackSize);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 96 >> 2, threadParams.stackSize);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 92 >> 2, stackHigh);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 120 + 8 >> 2, stackHigh);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 120 + 12 >> 2, threadParams.detached);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 120 + 20 >> 2, threadParams.schedPolicy);
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 120 + 24 >> 2, threadParams.schedPrio);
 var global_libc = _emscripten_get_global_libc();
 var global_locale = global_libc + 40;
 Atomics.store(HEAPU32, pthread.threadInfoStruct + 188 >> 2, global_locale);
 worker.pthread = pthread;
 var msg = {
  cmd: "run",
  start_routine: threadParams.startRoutine,
  arg: threadParams.arg,
  threadInfoStruct: threadParams.pthread_ptr,
  selfThreadId: threadParams.pthread_ptr,
  parentThreadId: threadParams.parent_pthread_ptr,
  stackBase: threadParams.stackBase,
  stackSize: threadParams.stackSize
 };
 worker.runPthread = (function() {
  msg.time = performance.now();
  worker.postMessage(msg, threadParams.transferList);
 });
 if (worker.loaded) {
  worker.runPthread();
  delete worker.runPthread;
 }
}
Module["__spawn_thread"] = __spawn_thread;
function _pthread_getschedparam(thread, policy, schedparam) {
 if (!policy && !schedparam) return ERRNO_CODES.EINVAL;
 if (!thread) {
  err("pthread_getschedparam called with a null thread pointer!");
  return ERRNO_CODES.ESRCH;
 }
 var self = GROWABLE_HEAP_LOAD_I32(thread + 24 | 0);
 if (self !== thread) {
  err("pthread_getschedparam attempted on thread " + thread + ", which does not point to a valid thread, or does not exist anymore!");
  return ERRNO_CODES.ESRCH;
 }
 var schedPolicy = Atomics.load(HEAPU32, thread + 120 + 20 >> 2);
 var schedPrio = Atomics.load(HEAPU32, thread + 120 + 24 >> 2);
 if (policy) GROWABLE_HEAP_STORE_I32(policy | 0, schedPolicy);
 if (schedparam) GROWABLE_HEAP_STORE_I32(schedparam | 0, schedPrio);
 return 0;
}
Module["_pthread_getschedparam"] = _pthread_getschedparam;
function _pthread_create(pthread_ptr, attr, start_routine, arg) {
 if (typeof SharedArrayBuffer === "undefined") {
  err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
  return 11;
 }
 if (!pthread_ptr) {
  err("pthread_create called with a null thread pointer!");
  return 22;
 }
 var transferList = [];
 var error = 0;
 if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
  return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
 }
 if (error) return error;
 var stackSize = 0;
 var stackBase = 0;
 var detached = 0;
 var schedPolicy = 0;
 var schedPrio = 0;
 if (attr) {
  stackSize = GROWABLE_HEAP_LOAD_I32(attr | 0);
  stackSize += 81920;
  stackBase = GROWABLE_HEAP_LOAD_I32(attr + 8 | 0);
  detached = GROWABLE_HEAP_LOAD_I32(attr + 12 | 0) !== 0;
  var inheritSched = GROWABLE_HEAP_LOAD_I32(attr + 16 | 0) === 0;
  if (inheritSched) {
   var prevSchedPolicy = GROWABLE_HEAP_LOAD_I32(attr + 20 | 0);
   var prevSchedPrio = GROWABLE_HEAP_LOAD_I32(attr + 24 | 0);
   var parentThreadPtr = PThread.currentProxiedOperationCallerThread ? PThread.currentProxiedOperationCallerThread : _pthread_self();
   _pthread_getschedparam(parentThreadPtr, attr + 20, attr + 24);
   schedPolicy = GROWABLE_HEAP_LOAD_I32(attr + 20 | 0);
   schedPrio = GROWABLE_HEAP_LOAD_I32(attr + 24 | 0);
   GROWABLE_HEAP_STORE_I32(attr + 20 | 0, prevSchedPolicy);
   GROWABLE_HEAP_STORE_I32(attr + 24 | 0, prevSchedPrio);
  } else {
   schedPolicy = GROWABLE_HEAP_LOAD_I32(attr + 20 | 0);
   schedPrio = GROWABLE_HEAP_LOAD_I32(attr + 24 | 0);
  }
 } else {
  stackSize = 2097152;
 }
 var allocatedOwnStack = stackBase == 0;
 if (allocatedOwnStack) {
  stackBase = _memalign(16, stackSize);
 } else {
  stackBase -= stackSize;
  assert(stackBase > 0);
 }
 var threadInfoStruct = _malloc(244);
 for (var i = 0; i < 244 >> 2; ++i) GROWABLE_HEAP_STORE_I32(((threadInfoStruct >> 2) + i) * 4 | 0, 0);
 GROWABLE_HEAP_STORE_I32(pthread_ptr | 0, threadInfoStruct);
 GROWABLE_HEAP_STORE_I32(threadInfoStruct + 24 | 0, threadInfoStruct);
 var headPtr = threadInfoStruct + 168;
 GROWABLE_HEAP_STORE_I32(headPtr | 0, headPtr);
 var threadParams = {
  stackBase: stackBase,
  stackSize: stackSize,
  allocatedOwnStack: allocatedOwnStack,
  schedPolicy: schedPolicy,
  schedPrio: schedPrio,
  detached: detached,
  startRoutine: start_routine,
  pthread_ptr: threadInfoStruct,
  parent_pthread_ptr: _pthread_self(),
  arg: arg,
  transferList: transferList
 };
 if (ENVIRONMENT_IS_PTHREAD) {
  threadParams.cmd = "spawnThread";
  postMessage(threadParams, transferList);
 } else {
  __spawn_thread(threadParams);
 }
 return 0;
}
Module["_pthread_create"] = _pthread_create;
function _pthread_exit(status) {
 if (!ENVIRONMENT_IS_PTHREAD) _exit(status); else PThread.threadExit(status);
}
Module["_pthread_exit"] = _pthread_exit;
function __cleanup_thread(pthread_ptr) {
 if (ENVIRONMENT_IS_PTHREAD) throw "Internal Error! _cleanup_thread() can only ever be called from main application thread!";
 if (!pthread_ptr) throw "Internal Error! Null pthread_ptr in _cleanup_thread!";
 GROWABLE_HEAP_STORE_I32(pthread_ptr + 24 | 0, 0);
 var pthread = PThread.pthreads[pthread_ptr];
 if (pthread) {
  var worker = pthread.worker;
  PThread.returnWorkerToPool(worker);
 }
}
Module["__cleanup_thread"] = __cleanup_thread;
function __pthread_testcancel_js() {
 if (!ENVIRONMENT_IS_PTHREAD) return;
 if (!threadInfoStruct) return;
 var cancelDisabled = Atomics.load(HEAPU32, threadInfoStruct + 72 >> 2);
 if (cancelDisabled) return;
 var canceled = Atomics.load(HEAPU32, threadInfoStruct + 0 >> 2);
 if (canceled == 2) throw "Canceled!";
}
Module["__pthread_testcancel_js"] = __pthread_testcancel_js;
function _pthread_join(thread, status) {
 if (!thread) {
  err("pthread_join attempted on a null thread pointer!");
  return ERRNO_CODES.ESRCH;
 }
 if (ENVIRONMENT_IS_PTHREAD && selfThreadId == thread) {
  err("PThread " + thread + " is attempting to join to itself!");
  return ERRNO_CODES.EDEADLK;
 } else if (!ENVIRONMENT_IS_PTHREAD && PThread.mainThreadBlock == thread) {
  err("Main thread " + thread + " is attempting to join to itself!");
  return ERRNO_CODES.EDEADLK;
 }
 var self = GROWABLE_HEAP_LOAD_I32(thread + 24 | 0);
 if (self !== thread) {
  err("pthread_join attempted on thread " + thread + ", which does not point to a valid thread, or does not exist anymore!");
  return ERRNO_CODES.ESRCH;
 }
 var detached = Atomics.load(HEAPU32, thread + 80 >> 2);
 if (detached) {
  err("Attempted to join thread " + thread + ", which was already detached!");
  return ERRNO_CODES.EINVAL;
 }
 for (;;) {
  var threadStatus = Atomics.load(HEAPU32, thread + 0 >> 2);
  if (threadStatus == 1) {
   var threadExitCode = Atomics.load(HEAPU32, thread + 4 >> 2);
   if (status) GROWABLE_HEAP_STORE_I32(status | 0, threadExitCode);
   Atomics.store(HEAPU32, thread + 80 >> 2, 1);
   if (!ENVIRONMENT_IS_PTHREAD) __cleanup_thread(thread); else postMessage({
    cmd: "cleanupThread",
    thread: thread
   });
   return 0;
  }
  __pthread_testcancel_js();
  if (!ENVIRONMENT_IS_PTHREAD) _emscripten_main_thread_process_queued_calls();
  _emscripten_futex_wait(thread + 0, threadStatus, ENVIRONMENT_IS_PTHREAD ? 100 : 1);
 }
}
Module["_pthread_join"] = _pthread_join;
function _raise(sig) {
 err("Calling stub instead of raise()");
 ___setErrNo(ERRNO_CODES.ENOSYS);
 warnOnce("raise() returning an error as we do not support it");
 return -1;
}
Module["_raise"] = _raise;
function abortOnCannotGrowMemory(requestedSize) {
 abort("Cannot enlarge memory arrays to size " + requestedSize + " bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + HEAP8.length + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
}
Module["abortOnCannotGrowMemory"] = abortOnCannotGrowMemory;
function emscripten_realloc_buffer(size) {
 var PAGE_MULTIPLE = 65536;
 size = alignUp(size, PAGE_MULTIPLE);
 var oldSize = buffer.byteLength;
 try {
  var result = wasmMemory.grow((size - oldSize) / 65536);
  if (result !== (-1 | 0)) {
   buffer = wasmMemory.buffer;
   return true;
  } else {
   return false;
  }
 } catch (e) {
  console.error("emscripten_realloc_buffer: Attempted to grow from " + oldSize + " bytes to " + size + " bytes, but got error: " + e);
  return false;
 }
}
Module["emscripten_realloc_buffer"] = emscripten_realloc_buffer;
function _emscripten_resize_heap(requestedSize) {
 var oldSize = _emscripten_get_heap_size();
 if (requestedSize <= oldSize) {
  return false;
 }
 var PAGE_MULTIPLE = 65536;
 var LIMIT = 2147483648 - PAGE_MULTIPLE;
 if (requestedSize > LIMIT) {
  err("Cannot enlarge memory, asked to go up to " + requestedSize + " bytes, but the limit is " + LIMIT + " bytes!");
  return false;
 }
 var MIN_TOTAL_MEMORY = 16777216;
 var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
 while (newSize < requestedSize) {
  if (newSize <= 536870912) {
   newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
  } else {
   newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
  }
  if (newSize === oldSize) {
   warnOnce("Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only " + HEAP8.length);
  }
 }
 newSize = Math.min(newSize, 1048576e3);
 if (newSize == oldSize) {
  err("Failed to grow the heap from " + oldSize + ", as we reached the WASM_MEM_MAX limit (" + 1048576e3 + ") set during compilation");
  return false;
 }
 var start = Date.now();
 if (!emscripten_realloc_buffer(newSize)) {
  err("Failed to grow the heap from " + oldSize + " bytes to " + newSize + " bytes, not enough memory!");
  return false;
 }
 updateGlobalBufferViews();
 return true;
}
Module["_emscripten_resize_heap"] = _emscripten_resize_heap;
function _sigaction(signum, act, oldact) {
 err("Calling stub instead of sigaction()");
 return 0;
}
Module["_sigaction"] = _sigaction;
function _sigaddset(set, signum) {
 GROWABLE_HEAP_STORE_I32(set | 0, GROWABLE_HEAP_LOAD_I32(set | 0) | 1 << signum - 1);
 return 0;
}
Module["_sigaddset"] = _sigaddset;
function _sigemptyset(set) {
 GROWABLE_HEAP_STORE_I32(set | 0, 0);
 return 0;
}
Module["_sigemptyset"] = _sigemptyset;
function _sigprocmask() {
 err("Calling stub instead of sigprocmask()");
 return 0;
}
Module["_sigprocmask"] = _sigprocmask;
function __isLeapYear(year) {
 return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
Module["__isLeapYear"] = __isLeapYear;
function __arraySum(array, index) {
 var sum = 0;
 for (var i = 0; i <= index; sum += array[i++]) ;
 return sum;
}
Module["__arraySum"] = __arraySum;
var __MONTH_DAYS_LEAP = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
Module["__MONTH_DAYS_LEAP"] = __MONTH_DAYS_LEAP;
var __MONTH_DAYS_REGULAR = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
Module["__MONTH_DAYS_REGULAR"] = __MONTH_DAYS_REGULAR;
function __addDays(date, days) {
 var newDate = new Date(date.getTime());
 while (days > 0) {
  var leap = __isLeapYear(newDate.getFullYear());
  var currentMonth = newDate.getMonth();
  var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
  if (days > daysInCurrentMonth - newDate.getDate()) {
   days -= daysInCurrentMonth - newDate.getDate() + 1;
   newDate.setDate(1);
   if (currentMonth < 11) {
    newDate.setMonth(currentMonth + 1);
   } else {
    newDate.setMonth(0);
    newDate.setFullYear(newDate.getFullYear() + 1);
   }
  } else {
   newDate.setDate(newDate.getDate() + days);
   return newDate;
  }
 }
 return newDate;
}
Module["__addDays"] = __addDays;
function _strftime(s, maxsize, format, tm) {
 var tm_zone = GROWABLE_HEAP_LOAD_I32(tm + 40 | 0);
 var date = {
  tm_sec: GROWABLE_HEAP_LOAD_I32(tm | 0),
  tm_min: GROWABLE_HEAP_LOAD_I32(tm + 4 | 0),
  tm_hour: GROWABLE_HEAP_LOAD_I32(tm + 8 | 0),
  tm_mday: GROWABLE_HEAP_LOAD_I32(tm + 12 | 0),
  tm_mon: GROWABLE_HEAP_LOAD_I32(tm + 16 | 0),
  tm_year: GROWABLE_HEAP_LOAD_I32(tm + 20 | 0),
  tm_wday: GROWABLE_HEAP_LOAD_I32(tm + 24 | 0),
  tm_yday: GROWABLE_HEAP_LOAD_I32(tm + 28 | 0),
  tm_isdst: GROWABLE_HEAP_LOAD_I32(tm + 32 | 0),
  tm_gmtoff: GROWABLE_HEAP_LOAD_I32(tm + 36 | 0),
  tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
 };
 var pattern = UTF8ToString(format);
 var EXPANSION_RULES_1 = {
  "%c": "%a %b %d %H:%M:%S %Y",
  "%D": "%m/%d/%y",
  "%F": "%Y-%m-%d",
  "%h": "%b",
  "%r": "%I:%M:%S %p",
  "%R": "%H:%M",
  "%T": "%H:%M:%S",
  "%x": "%m/%d/%y",
  "%X": "%H:%M:%S",
  "%Ec": "%c",
  "%EC": "%C",
  "%Ex": "%m/%d/%y",
  "%EX": "%H:%M:%S",
  "%Ey": "%y",
  "%EY": "%Y",
  "%Od": "%d",
  "%Oe": "%e",
  "%OH": "%H",
  "%OI": "%I",
  "%Om": "%m",
  "%OM": "%M",
  "%OS": "%S",
  "%Ou": "%u",
  "%OU": "%U",
  "%OV": "%V",
  "%Ow": "%w",
  "%OW": "%W",
  "%Oy": "%y"
 };
 for (var rule in EXPANSION_RULES_1) {
  pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
 }
 var WEEKDAYS = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
 var MONTHS = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ];
 function leadingSomething(value, digits, character) {
  var str = typeof value === "number" ? value.toString() : value || "";
  while (str.length < digits) {
   str = character[0] + str;
  }
  return str;
 }
 function leadingNulls(value, digits) {
  return leadingSomething(value, digits, "0");
 }
 function compareByDay(date1, date2) {
  function sgn(value) {
   return value < 0 ? -1 : value > 0 ? 1 : 0;
  }
  var compare;
  if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
   if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
    compare = sgn(date1.getDate() - date2.getDate());
   }
  }
  return compare;
 }
 function getFirstWeekStartDate(janFourth) {
  switch (janFourth.getDay()) {
  case 0:
   return new Date(janFourth.getFullYear() - 1, 11, 29);
  case 1:
   return janFourth;
  case 2:
   return new Date(janFourth.getFullYear(), 0, 3);
  case 3:
   return new Date(janFourth.getFullYear(), 0, 2);
  case 4:
   return new Date(janFourth.getFullYear(), 0, 1);
  case 5:
   return new Date(janFourth.getFullYear() - 1, 11, 31);
  case 6:
   return new Date(janFourth.getFullYear() - 1, 11, 30);
  }
 }
 function getWeekBasedYear(date) {
  var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);
  var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
  var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
  var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
  var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
   if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
    return thisDate.getFullYear() + 1;
   } else {
    return thisDate.getFullYear();
   }
  } else {
   return thisDate.getFullYear() - 1;
  }
 }
 var EXPANSION_RULES_2 = {
  "%a": (function(date) {
   return WEEKDAYS[date.tm_wday].substring(0, 3);
  }),
  "%A": (function(date) {
   return WEEKDAYS[date.tm_wday];
  }),
  "%b": (function(date) {
   return MONTHS[date.tm_mon].substring(0, 3);
  }),
  "%B": (function(date) {
   return MONTHS[date.tm_mon];
  }),
  "%C": (function(date) {
   var year = date.tm_year + 1900;
   return leadingNulls(year / 100 | 0, 2);
  }),
  "%d": (function(date) {
   return leadingNulls(date.tm_mday, 2);
  }),
  "%e": (function(date) {
   return leadingSomething(date.tm_mday, 2, " ");
  }),
  "%g": (function(date) {
   return getWeekBasedYear(date).toString().substring(2);
  }),
  "%G": (function(date) {
   return getWeekBasedYear(date);
  }),
  "%H": (function(date) {
   return leadingNulls(date.tm_hour, 2);
  }),
  "%I": (function(date) {
   var twelveHour = date.tm_hour;
   if (twelveHour == 0) twelveHour = 12; else if (twelveHour > 12) twelveHour -= 12;
   return leadingNulls(twelveHour, 2);
  }),
  "%j": (function(date) {
   return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);
  }),
  "%m": (function(date) {
   return leadingNulls(date.tm_mon + 1, 2);
  }),
  "%M": (function(date) {
   return leadingNulls(date.tm_min, 2);
  }),
  "%n": (function() {
   return "\n";
  }),
  "%p": (function(date) {
   if (date.tm_hour >= 0 && date.tm_hour < 12) {
    return "AM";
   } else {
    return "PM";
   }
  }),
  "%S": (function(date) {
   return leadingNulls(date.tm_sec, 2);
  }),
  "%t": (function() {
   return "\t";
  }),
  "%u": (function(date) {
   return date.tm_wday || 7;
  }),
  "%U": (function(date) {
   var janFirst = new Date(date.tm_year + 1900, 0, 1);
   var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
   var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);
   if (compareByDay(firstSunday, endDate) < 0) {
    var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
    var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
    var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
    return leadingNulls(Math.ceil(days / 7), 2);
   }
   return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
  }),
  "%V": (function(date) {
   var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);
   var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);
   var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
   var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
   var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);
   if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
    return "53";
   }
   if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
    return "01";
   }
   var daysDifference;
   if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {
    daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();
   } else {
    daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();
   }
   return leadingNulls(Math.ceil(daysDifference / 7), 2);
  }),
  "%w": (function(date) {
   return date.tm_wday;
  }),
  "%W": (function(date) {
   var janFirst = new Date(date.tm_year, 0, 1);
   var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
   var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);
   if (compareByDay(firstMonday, endDate) < 0) {
    var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
    var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
    var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
    return leadingNulls(Math.ceil(days / 7), 2);
   }
   return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
  }),
  "%y": (function(date) {
   return (date.tm_year + 1900).toString().substring(2);
  }),
  "%Y": (function(date) {
   return date.tm_year + 1900;
  }),
  "%z": (function(date) {
   var off = date.tm_gmtoff;
   var ahead = off >= 0;
   off = Math.abs(off) / 60;
   off = off / 60 * 100 + off % 60;
   return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
  }),
  "%Z": (function(date) {
   return date.tm_zone;
  }),
  "%%": (function() {
   return "%";
  })
 };
 for (var rule in EXPANSION_RULES_2) {
  if (pattern.indexOf(rule) >= 0) {
   pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
  }
 }
 var bytes = intArrayFromString(pattern, false);
 if (bytes.length > maxsize) {
  return 0;
 }
 writeArrayToMemory(bytes, s);
 return bytes.length - 1;
}
Module["_strftime"] = _strftime;
function _strftime_l(s, maxsize, format, tm) {
 return _strftime(s, maxsize, format, tm);
}
Module["_strftime_l"] = _strftime_l;
function _time(ptr) {
 var ret = Date.now() / 1e3 | 0;
 if (ptr) {
  GROWABLE_HEAP_STORE_I32(ptr | 0, ret);
 }
 return ret;
}
Module["_time"] = _time;
if (!ENVIRONMENT_IS_PTHREAD) PThread.initMainThreadBlock();
if (ENVIRONMENT_IS_NODE) {
 _emscripten_get_now = function _emscripten_get_now_actual() {
  var t = process["hrtime"]();
  return t[0] * 1e3 + t[1] / 1e6;
 };
} else if (ENVIRONMENT_IS_PTHREAD) {
 _emscripten_get_now = (function() {
  return performance["now"]() - __performance_now_clock_drift;
 });
} else if (typeof dateNow !== "undefined") {
 _emscripten_get_now = dateNow;
} else if (typeof performance === "object" && performance && typeof performance["now"] === "function") {
 _emscripten_get_now = (function() {
  return performance["now"]();
 });
} else {
 _emscripten_get_now = Date.now;
}
FS.staticInit();
Module["FS_createFolder"] = FS.createFolder;
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
Module["FS_createLazyFile"] = FS.createLazyFile;
Module["FS_createLink"] = FS.createLink;
Module["FS_createDevice"] = FS.createDevice;
Module["FS_unlink"] = FS.unlink;
if (ENVIRONMENT_HAS_NODE) {
 var fs = require("fs");
 var NODEJS_PATH = require("path");
 NODEFS.staticInit();
}
embind_init_charCodes();
BindingError = Module["BindingError"] = extendError(Error, "BindingError");
InternalError = Module["InternalError"] = extendError(Error, "InternalError");
init_ClassHandle();
init_RegisteredPointer();
init_embind();
UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
init_emval();
if (!ENVIRONMENT_IS_PTHREAD) Fetch.staticInit();
var GLctx;
GL.init();
var proxiedFunctionTable = [ null, ___syscall10, ___syscall102, ___syscall122, ___syscall140, ___syscall142, ___syscall145, ___syscall146, ___syscall195, ___syscall20, ___syscall220, ___syscall221, ___syscall38, ___syscall39, ___syscall40, ___syscall5, ___syscall54, ___syscall6, ___syscall91, _emscripten_set_canvas_element_size_main_thread, _getaddrinfo, _getenv, _tzset ];
var ASSERTIONS = true;
function intArrayFromString(stringy, dontAddNull, length) {
 var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
 var u8array = new Array(len);
 var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
 if (dontAddNull) u8array.length = numBytesWritten;
 return u8array;
}
function intArrayToString(array) {
 var ret = [];
 for (var i = 0; i < array.length; i++) {
  var chr = array[i];
  if (chr > 255) {
   if (ASSERTIONS) {
    assert(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.");
   }
   chr &= 255;
  }
  ret.push(String.fromCharCode(chr));
 }
 return ret.join("");
}
var debug_table_i = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN10emscripten8internal12operator_newI17HsCommonSdkWasmIfJEEEPT_DpOT0_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_rp_get_evtdisp", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_ii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "___stdio_close", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt9bad_alloc4whatEv", 0, 0, "__ZNKSt11logic_error4whatEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE4syncEv", "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9showmanycEv", 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9underflowEv", "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5uflowEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE4syncEv", "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9showmanycEv", 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9underflowEv", "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5uflowEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIwE4syncEv", 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIcE4syncEv", 0, 0, 0, 0, "__ZNSt3__210__stdinbufIwE9underflowEv", "__ZNSt3__210__stdinbufIwE5uflowEv", 0, 0, 0, "__ZNSt3__210__stdinbufIcE9underflowEv", "__ZNSt3__210__stdinbufIcE5uflowEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13do_date_orderEv", 0, 0, 0, 0, 0, 0, "__ZNKSt3__220__time_get_c_storageIcE7__weeksEv", "__ZNKSt3__220__time_get_c_storageIcE8__monthsEv", "__ZNKSt3__220__time_get_c_storageIcE7__am_pmEv", "__ZNKSt3__220__time_get_c_storageIcE3__cEv", "__ZNKSt3__220__time_get_c_storageIcE3__rEv", "__ZNKSt3__220__time_get_c_storageIcE3__xEv", "__ZNKSt3__220__time_get_c_storageIcE3__XEv", 0, 0, "__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13do_date_orderEv", 0, 0, 0, 0, 0, 0, "__ZNKSt3__220__time_get_c_storageIwE7__weeksEv", "__ZNKSt3__220__time_get_c_storageIwE8__monthsEv", "__ZNKSt3__220__time_get_c_storageIwE7__am_pmEv", "__ZNKSt3__220__time_get_c_storageIwE3__cEv", "__ZNKSt3__220__time_get_c_storageIwE3__rEv", "__ZNKSt3__220__time_get_c_storageIwE3__xEv", "__ZNKSt3__220__time_get_c_storageIwE3__XEv", 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__210moneypunctIcLb0EE16do_decimal_pointEv", "__ZNKSt3__210moneypunctIcLb0EE16do_thousands_sepEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIcLb0EE14do_frac_digitsEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIcLb1EE16do_decimal_pointEv", "__ZNKSt3__210moneypunctIcLb1EE16do_thousands_sepEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIcLb1EE14do_frac_digitsEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIwLb0EE16do_decimal_pointEv", "__ZNKSt3__210moneypunctIwLb0EE16do_thousands_sepEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIwLb0EE14do_frac_digitsEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIwLb1EE16do_decimal_pointEv", "__ZNKSt3__210moneypunctIwLb1EE16do_thousands_sepEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIwLb1EE14do_frac_digitsEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIDic11__mbstate_tE11do_encodingEv", "__ZNKSt3__27codecvtIDic11__mbstate_tE16do_always_noconvEv", 0, "__ZNKSt3__27codecvtIDic11__mbstate_tE13do_max_lengthEv", 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIwc11__mbstate_tE11do_encodingEv", "__ZNKSt3__27codecvtIwc11__mbstate_tE16do_always_noconvEv", 0, "__ZNKSt3__27codecvtIwc11__mbstate_tE13do_max_lengthEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28numpunctIcE16do_decimal_pointEv", "__ZNKSt3__28numpunctIcE16do_thousands_sepEv", 0, 0, 0, 0, 0, "__ZNKSt3__28numpunctIwE16do_decimal_pointEv", "__ZNKSt3__28numpunctIwE16do_thousands_sepEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIcc11__mbstate_tE11do_encodingEv", "__ZNKSt3__27codecvtIcc11__mbstate_tE16do_always_noconvEv", 0, "__ZNKSt3__27codecvtIcc11__mbstate_tE13do_max_lengthEv", 0, 0, 0, 0, "__ZNKSt3__27codecvtIDsc11__mbstate_tE11do_encodingEv", "__ZNKSt3__27codecvtIDsc11__mbstate_tE16do_always_noconvEv", 0, "__ZNKSt3__27codecvtIDsc11__mbstate_tE13do_max_lengthEv", 0, "_msmCallback", "__Z19hs_sdk_thread_startPv", "__Z16hs_sdk_app_startPv", "__ZN10emscripten8internal13getActualTypeI17HsCommonSdkWasmIfEEPKvPT_", 0, "__ZN10emscripten8internal7InvokerIP17HsCommonSdkWasmIfJEE6invokeEPFS3_vE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_dtm_thrd", 0, "_hs_fwk_generic_param_create_copy", "_hs_fwk_logger_thread", 0, "_th_wrapper_common_entry", 0, 0, 0, "_hs_fwk_str_create_copy", 0, 0, 0, 0, "_hs_hoff_mngr_thread", "_hs_ncm_adpt_ipaddr_copy_create", 0, 0, 0, 0, "_hs_ncm_core_thead_entry", 0, 0, "_hs_ncm_nwk_netlink_dispatch", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_msm_timer_cb", "_hs_msm_handle_ecb_mode_complete", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_sip326x_ua_controller", 0, "_hs_sip_address_hdr_create_copy", "_hs_sip_via_hdr_create_copy", 0, 0, "_hs_sip326x_tpah_dtm_calback", 0, 0, "_hs_ims_sipext_hdrcpy", "_hs_sip_string_hdr_create_copy", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_sip_authrz_hdr_create_copy", "_hs_sip_www_authn_hdr_create_copy", "_hs_sip_auth_info_hdr_create_copy", "_hs_sip_contact_hdr_create_copy", "_hs_sip_histinfo_hdr_create_copy", "_hs_sip_reason_hdr_create_copy", "_hs_sip_generic_hdr_create_copy", 0, "_hs_voip_ccm_hist_cpy_create", 0, 0, "_hs_voip_ccm_callobj_timer_cb", 0, "_hs_voip_ccm_dispatcher", 0, "_hs_voip_ccm_subscpt_callbk", 0, 0, 0, "_hs_fwk_event_dispatcher", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_timer_thread", 0, 0, "_hs_sig_notify_dispatcher", 0, 0, "_hs_voip_ccm_notifications_from_mc", 0, 0, "_hs_ims_reg_dispatcher", 0, 0, 0, 0, 0, 0, "_hs_imsreg_ccm_callback", 0, 0, "_hs_voip_mc_webrtc_disp", 0, "_hs_ims_oam_prov_timer_cb", "_hs_ims_identity_create_copy", 0, "_hs_ims_suppserv_cdivrule_create_copy", "_hs_ims_suppserv_cbrule_create_copy", 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_voip_sdp_ice_cand_create_copy", "_hs_content_type_create_copy", 0, 0, 0, 0, 0, "_hs_contcap_type_create_copy", "_hs_contcap_lang_create_copy", "_hs_contcap_enc_create_copy", 0, 0, "_hs_subscpt_dispatcher", 0, 0, 0, "_hs_http_dtm_callbkfn", 0, "_hs_http_thrd", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_oam_http_cb", 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_conf_copy_endpoint", 0, "_hs_ims_conf_copy_media", 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_conf_copy_avb_media", "_hs_ims_conf_copy_user", 0, 0, 0, 0, 0, 0, "___emscripten_thread_main", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iidiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_fmt_fp", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle4Node19hasRHSComponentSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle4Node12hasArraySlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle4Node15hasFunctionSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle4Node13getSyntaxNodeERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType19hasRHSComponentSlowERNS_12OutputStreamE", 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle11PointerType19hasRHSComponentSlowERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack19hasRHSComponentSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack12hasArraySlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack15hasFunctionSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack13getSyntaxNodeERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference19hasRHSComponentSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference12hasArraySlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference15hasFunctionSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference13getSyntaxNodeERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType19hasRHSComponentSlowERNS_12OutputStreamE", 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType19hasRHSComponentSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType12hasArraySlowERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle8QualType19hasRHSComponentSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle8QualType12hasArraySlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle8QualType15hasFunctionSlowERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType19hasRHSComponentSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType15hasFunctionSlowERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding19hasRHSComponentSlowERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding15hasFunctionSlowERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9pbackfailEi", 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE8overflowEi", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9pbackfailEj", 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE8overflowEj", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIwE8overflowEj", 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIcE8overflowEi", 0, 0, 0, 0, "__ZNSt3__210__stdinbufIwE9pbackfailEj", 0, 0, 0, 0, "__ZNSt3__210__stdinbufIcE9pbackfailEi", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIcE10do_toupperEc", 0, "__ZNKSt3__25ctypeIcE10do_tolowerEc", 0, "__ZNKSt3__25ctypeIcE8do_widenEc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIwE10do_toupperEw", 0, "__ZNKSt3__25ctypeIwE10do_tolowerEw", 0, "__ZNKSt3__25ctypeIwE8do_widenEc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN17HsCommonSdkWasmIf18manualProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE", 0, 0, 0, 0, 0, 0, 0, "__ZN17HsCommonSdkWasmIf7endCallEj", 0, "__ZN17HsCommonSdkWasmIf8holdCallEj", "__ZN17HsCommonSdkWasmIf10unholdCallEj", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ncm_adpt_ipaddr_is_equal", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_generic_param_compare", 0, 0, 0, "_hs_fwk_generic_param_match", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_sm_docstart", "_sm_docend", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_suppserv_cmp_xactid", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_str_is_equal", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_CB_sip_reginfo_doc_end", "_hs_CB_sip_reginfo_doc_start", 0, 0, 0, "_hs_fwk_dyn_array_copy", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_conf_doc_end", "_hs_ims_conf_doc_start", 0, 0, 0, 0, 0, 0, 0, 0, 0, "_netlink_msg_to_ifaddr", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "___stdio_write", 0, "___stdout_write", "___stdio_read", "_sn_write", 0, 0, 0, 0, 0, "__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv", 0, "__ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv", 0, "__ZNK10__cxxabiv116__enum_type_info9can_catchEPKNS_16__shim_type_infoERPv", 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6setbufEPcl", 0, 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsgetnEPcl", 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsputnEPKcl", 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6setbufEPwl", 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsgetnEPwl", 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsputnEPKwl", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIwE6xsputnEPKwl", 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIcE6xsputnEPKcl", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27collateIcE7do_hashEPKcS3_", 0, 0, 0, 0, "__ZNKSt3__27collateIwE7do_hashEPKwS3_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28messagesIcE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE", 0, 0, 0, 0, "__ZNKSt3__28messagesIwE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIcE10do_toupperEPcPKc", 0, "__ZNKSt3__25ctypeIcE10do_tolowerEPcPKc", 0, 0, "__ZNKSt3__25ctypeIcE9do_narrowEcc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIwE5do_isEtw", 0, 0, 0, 0, "__ZNKSt3__25ctypeIwE10do_toupperEPwPKw", 0, "__ZNKSt3__25ctypeIwE10do_tolowerEPwPKw", 0, 0, "__ZNKSt3__25ctypeIwE9do_narrowEwc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEES3_PS2_JSA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_E", 0, 0, "__ZN17HsCommonSdkWasmIf9startCallENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEi", 0, "__ZN17HsCommonSdkWasmIf10answerCallEji", 0, 0, "__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijEiPS2_JjEE6invokeERKS4_S5_j", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_rp_getevt_data", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_sm_tagend", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_suppserv_tag_end", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_CB_sip_reginfo_tag_end", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_conf_tag_end", 0, 0, 0, 0, 0, 0, "_do_read", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIcE8do_widenEPKcS3_Pc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIwE5do_isEPKwS3_Pt", "__ZNKSt3__25ctypeIwE10do_scan_isEtPKwS3_", "__ZNKSt3__25ctypeIwE11do_scan_notEtPKwS3_", 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIwE8do_widenEPKcS3_Pw", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN17HsCommonSdkWasmIf19startRegistrationIfENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_", 0, 0, "__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFjNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEiEjPS2_JS9_iEE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_Ei", 0, "__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijiEiPS2_JjiEE6invokeERKS4_S5_ji", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ncm_cb_tag_start", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_sm_exec", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_sm_skipnode", 0, 0, "_sm_tagstart", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_suppserv_tag_start", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_CB_sip_reginfo_tag_start", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_conf_tag_start", 0, 0, "_hs_ims_conf_skip_node_data", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiiid = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcd", "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEce", 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwd", "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwe", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27collateIcE10do_compareEPKcS3_S3_S3_", 0, 0, 0, 0, "__ZNKSt3__27collateIwE10do_compareEPKwS3_S3_S3_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcb", "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcl", 0, "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcm", 0, 0, 0, "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPKv", 0, 0, "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwb", "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwl", 0, "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwm", 0, 0, 0, "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPKv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIDic11__mbstate_tE10do_unshiftERS1_PcS4_RS4_", 0, 0, "__ZNKSt3__27codecvtIDic11__mbstate_tE9do_lengthERS1_PKcS5_m", 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIwc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_", 0, 0, "__ZNKSt3__27codecvtIwc11__mbstate_tE9do_lengthERS1_PKcS5_m", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIcE9do_narrowEPKcS3_cPc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__25ctypeIwE9do_narrowEPKwS3_cPc", 0, 0, 0, "__ZNKSt3__27codecvtIcc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_", 0, 0, "__ZNKSt3__27codecvtIcc11__mbstate_tE9do_lengthERS1_PKcS5_m", 0, 0, 0, 0, "__ZNKSt3__27codecvtIDsc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_", 0, 0, "__ZNKSt3__27codecvtIDsc11__mbstate_tE9do_lengthERS1_PKcS5_m", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN17HsCommonSdkWasmIf17startProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_S6_", 0, 0, 0, 0, "__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_ES3_PS2_JSA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ncm_cb_tag_data", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_sm_tagdata", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_suppserv_tag_data", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_CB_sip_reginfo_tag_data", 0, 0, "_doc_start_handler", "_conf_info_handler", "_conf_desc_handler", "_users_handler", "_avb_media_handler", 0, "_user_handler", 0, "_ep_handler", 0, "_media_handler", 0, 0, 0, 0, 0, 0, 0, "_hs_ims_conf_tag_data", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiiiid = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEce", 0, 0, 0, "__ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwe", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRb", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRl", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRx", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRt", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRm", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRy", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRf", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRd", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRe", "__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv", 0, 0, "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRb", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRl", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRx", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRt", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRm", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRy", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRf", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRd", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRe", "__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm", "__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEcRKNS_12basic_stringIcS3_NS_9allocatorIcEEEE", 0, 0, 0, "__ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwRKNS_12basic_stringIwS3_NS_9allocatorIwEEEE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_SA_ES3_PS2_JSA_SA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_SK_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_cdivrule_hndlr", "_cbrule_hndlr", "_conds_hndlr", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiiiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPK2tmcc", 0, 0, "__ZNKSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPK2tmcc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe", "__ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIcS3_NS_9allocatorIcEEEE", 0, 0, "__ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe", "__ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIwS3_NS_9allocatorIwEEEE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiiiiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIDic11__mbstate_tE6do_outERS1_PKDiS5_RS5_PcS7_RS7_", "__ZNKSt3__27codecvtIDic11__mbstate_tE5do_inERS1_PKcS5_RS5_PDiS7_RS7_", 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIwc11__mbstate_tE6do_outERS1_PKwS5_RS5_PcS7_RS7_", "__ZNKSt3__27codecvtIwc11__mbstate_tE5do_inERS1_PKcS5_RS5_PwS7_RS7_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIcc11__mbstate_tE6do_outERS1_PKcS5_RS5_PcS7_RS7_", "__ZNKSt3__27codecvtIcc11__mbstate_tE5do_inERS1_PKcS5_RS5_PcS7_RS7_", 0, 0, 0, 0, 0, 0, "__ZNKSt3__27codecvtIDsc11__mbstate_tE6do_outERS1_PKDsS5_RS5_PcS7_RS7_", "__ZNKSt3__27codecvtIDsc11__mbstate_tE5do_inERS1_PKcS5_RS5_PDsS7_RS7_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_iiiiiiiiii = [ 0 ];
var debug_table_iiiiij = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcx", 0, "__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcy", 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwx", 0, "__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwy", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_jiji = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "___stdio_seek", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_v = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZL28demangling_terminate_handlerv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "___cxa_pure_virtual", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN10__cxxabiv112_GLOBAL__N_110construct_Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_vf = [ 0 ];
var debug_table_vff = [ 0 ];
var debug_table_vfff = [ 0 ];
var debug_table_vffff = [ 0 ];
var debug_table_vi = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN24CallSessionNotifyHandler21onCallTransferSuccessEv", 0, 0, 0, "__ZN24CallSessionNotifyHandler20onCallReplaceFailureEv", 0, 0, 0, 0, "__ZN24CallManagerNotifyHandler19onSwitchCallSuccessEv", 0, 0, 0, "__ZN24CallManagerNotifyHandler22onConferenceIndicationEv", 0, 0, 0, "__ZN16SdkNotifyHandler24onDeIntializationSuccessEv", "__ZN16SdkNotifyHandler9onOtpSentEv", 0, 0, 0, "__ZN16SdkNotifyHandler21onRegistrationSuccessEv", 0, "__ZN16SdkNotifyHandler23onDeregistrationSuccessEv", 0, 0, "__ZN16SdkNotifyHandler21onNetworkDisconnectedEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN10__cxxabiv116__shim_type_infoD2Ev", "__ZN10__cxxabiv117__class_type_infoD0Ev", "__ZNK10__cxxabiv116__shim_type_info5noop1Ev", "__ZNK10__cxxabiv116__shim_type_info5noop2Ev", 0, 0, 0, 0, "__ZN10__cxxabiv120__si_class_type_infoD0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle4NodeD2Ev", "__ZN12_GLOBAL__N_116itanium_demangle10AbiTagAttrD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle4NodeD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle19SpecialSubstitutionD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle20PostfixQualifiedTypeD0Ev", 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle13ReferenceTypeD0Ev", 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle11PointerTypeD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgsD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle12TemplateArgsD0Ev", 0, 0, 0, 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle13ParameterPackD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle15IntegerCastExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeED0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdED0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfED0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle8BoolExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle14IntegerLiteralD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle20TemplateArgumentPackD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle9ThrowExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle12InitListExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle13NodeArrayNodeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle13EnclosingExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle19SizeofParamPackExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle22ParameterPackExpansionD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle8CastExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle15ConditionalExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle7NewExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle11PostfixExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle15BracedRangeExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle10BracedExprD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle8NameTypeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle18ArraySubscriptExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle10MemberExprD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle19GlobalQualifiedNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle15LiteralOperatorD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle22ConversionOperatorTypeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle8DtorNameD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle13QualifiedNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle10DeleteExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle14ConversionExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle8CallExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle10PrefixExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle10BinaryExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle8FoldExprD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle13FunctionParamD0Ev", 0, 0, 0, 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle24ForwardTemplateReferenceD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefTypeD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle16StdQualifiedNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle21StructuredBindingNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle15ClosureTypeNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle15UnnamedTypeNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle9LocalNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle12CtorDtorNameD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitutionD0Ev", 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle10NestedNameD0Ev", 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle19PointerToMemberTypeD0Ev", 0, 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle9ArrayTypeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle10VectorTypeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle15PixelVectorTypeD0Ev", 0, 0, 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle8QualTypeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle17VendorExtQualTypeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle13ObjCProtoNameD0Ev", 0, 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle12FunctionTypeD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpecD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle12NoexceptSpecD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle11SpecialNameD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle9DotSuffixD0Ev", 0, 0, 0, 0, "__ZN12_GLOBAL__N_116itanium_demangle16FunctionEncodingD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle12EnableIfAttrD0Ev", 0, "__ZN12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialNameD0Ev", "__ZNSt9exceptionD2Ev", "__ZNSt9bad_allocD0Ev", 0, "__ZNSt11logic_errorD2Ev", "__ZNSt11logic_errorD0Ev", 0, "__ZNSt12length_errorD0Ev", "__ZN10__cxxabiv123__fundamental_type_infoD0Ev", 0, "__ZN10__cxxabiv119__pointer_type_infoD0Ev", 0, "__ZN10__cxxabiv116__enum_type_infoD0Ev", 0, "__ZN10__cxxabiv121__vmi_class_type_infoD0Ev", 0, 0, 0, "__ZNSt3__28ios_baseD2Ev", "__ZNSt3__28ios_baseD0Ev", "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED2Ev", "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED2Ev", "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev", "__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev", "__ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev", "__ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev", "__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev", "__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev", "__ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev", "__ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev", "__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev", "__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev", "__ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev", "__ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev", "__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev", "__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev", "__ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev", "__ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev", "__ZNSt3__211__stdoutbufIwED0Ev", 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIcED0Ev", 0, 0, 0, 0, "__ZNSt3__210__stdinbufIwED0Ev", 0, 0, 0, 0, "__ZNSt3__210__stdinbufIcED0Ev", 0, 0, 0, 0, "__ZNSt3__27collateIcED2Ev", "__ZNSt3__27collateIcED0Ev", "__ZNSt3__26locale5facet16__on_zero_sharedEv", 0, 0, 0, "__ZNSt3__27collateIwED2Ev", "__ZNSt3__27collateIwED0Ev", 0, 0, 0, "__ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev", "__ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev", "__ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev", "__ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev", "__ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev", "__ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev", "__ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev", "__ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev", 0, "__ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev", "__ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev", 0, "__ZNSt3__210moneypunctIcLb0EED2Ev", "__ZNSt3__210moneypunctIcLb0EED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__210moneypunctIcLb1EED2Ev", "__ZNSt3__210moneypunctIcLb1EED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__210moneypunctIwLb0EED2Ev", "__ZNSt3__210moneypunctIwLb0EED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__210moneypunctIwLb1EED2Ev", "__ZNSt3__210moneypunctIwLb1EED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev", "__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev", 0, 0, "__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev", "__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev", 0, 0, "__ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev", "__ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev", 0, 0, "__ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev", "__ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev", 0, 0, "__ZNSt3__28messagesIcED2Ev", "__ZNSt3__28messagesIcED0Ev", 0, 0, 0, "__ZNSt3__28messagesIwED2Ev", "__ZNSt3__28messagesIwED0Ev", 0, 0, 0, "__ZNSt3__26locale5facetD2Ev", "__ZNSt3__216__narrow_to_utf8ILm32EED0Ev", 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__217__widen_from_utf8ILm32EED0Ev", "__ZNSt3__27codecvtIwc11__mbstate_tED2Ev", "__ZNSt3__27codecvtIwc11__mbstate_tED0Ev", 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__26locale5__impD2Ev", "__ZNSt3__26locale5__impD0Ev", "__ZNSt3__25ctypeIcED2Ev", "__ZNSt3__25ctypeIcED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__28numpunctIcED2Ev", "__ZNSt3__28numpunctIcED0Ev", 0, 0, 0, 0, 0, "__ZNSt3__28numpunctIwED2Ev", "__ZNSt3__28numpunctIwED0Ev", 0, 0, 0, 0, 0, "__ZNSt3__26locale5facetD0Ev", "__ZNSt3__25ctypeIwED0Ev", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__27codecvtIcc11__mbstate_tED0Ev", 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__27codecvtIDsc11__mbstate_tED0Ev", 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__27codecvtIDic11__mbstate_tED0Ev", 0, 0, 0, 0, "__ZN10emscripten8internal14raw_destructorI17HsCommonSdkWasmIfEEvPT_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_dtm_free_data", "_hs_fwk_dtm_wasm_change_txproto", "_hs_fwk_dtm_free_sockinfo", 0, "_hs_fwk_generic_param_free", 0, 0, "_free", 0, "_hs_ims_sipext_mthd_free", "_hs_content_type_free", "_hs_voip_cm_free_otherparam", 0, "_hs_eam_free_stats_db", "_hs_fwk_dns_clear_head_entry", "_hs_fwk_dns_trans_info_free", "_hs_hoff_mngr_ncm_ind_callback", 0, 0, "_hs_hoff_raise_viability_event", 0, 0, 0, 0, "_hs_ncm_core_post_route_change_event_to_app", "_hs_ncm_statobs_adpt_ev_callback", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_rp_ncm_ind_callback", 0, "_hs_rp_evt_free", 0, "_hs_rp_sm_rootctx_destroy", 0, 0, 0, "_hs_msm_reg_event_cb", "_hs_msm_app_ctx_destroy", "_hs_msm_call_ctx_destroy", "_hs_msm_sms_ctx_destroy", "_hs_msm_vs_ctx_destroy", "_hs_msm_subscpt_ctx_destroy", "_hs_msm_handle_eam_event", "_hs_msm_voip_ev_handler", "_hs_msm_prof_ctx_destroy", "_hs_fwk_mem_null_free", 0, "_hs_sip326x_tl_free_xaction", 0, 0, "_hs_sip326x_tpah_release_conn", "_hs_sip326x_tpah_release_maddr", 0, 0, "_hs_sip_string_hdr_free", 0, 0, 0, "_hs_sip_contact_hdr_free", "_hs_sip_generic_hdr_free", "_hs_sip_via_hdr_free", "_hs_sip_address_hdr_free", "_hs_sip_www_authn_hdr_free", "_hs_sip_authrz_hdr_free", "_hs_sip_auth_info_hdr_free", "_hs_sip_histinfo_hdr_free", "_hs_sip_reason_hdr_free", 0, 0, 0, 0, 0, 0, 0, "_hs_ims_sipext_hdr_free", 0, "_hs_voip_ccm_redirect_node_free", "_hs_voip_ccm_forkctx_free", 0, "_hs_voip_ccm_ep_subscpt_free", 0, "_hs_voip_ccm_sip_cb", 0, "_hs_voip_ccm_histinfo_free", "_hs_fwk_evtdisp_free", "_hs_fwk_evtdisp_mod_free", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_sm_param_free", "_hs_fwk_smstate_free", "_hs_fwk_smaction_free", "_hs_fwk_smtrans_free", 0, "_hs_fwk_timer_wrap_ctxt_free", "_hs_fwk_signal_handler", 0, "_hs_xml_elmt_free", "_hs_voip_sys_nwkevent_cb", 0, "_hs_ims_reg_free_callback", "_hs_ims_free_reg", 0, "_hs_ims_reg_sip_cb", "_hs_ims_identity_free", "_hs_ims_reg_free_binding", "_hs_ims_regapp_nwevent_cb", "_hs_ims_regapp_status_cb", "_hs_ims_regapp_event_cb", 0, "_hs_ims_regapp_free_tx", "_hs_ims_regapp_free_cb", 0, "_hs_ims_prov_node_free", 0, 0, "_hs_ims_suppserv_node_free", 0, 0, 0, "_hs_ims_suppserv_cdivrule_free", "_hs_ims_suppserv_cbrule_free", 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_mime_destroy_children", "_hs_fwk_mime_filterlist_node_destroy", "_hs_contcap_type_free", "_hs_contcap_lang_free", "_hs_contcap_enc_free", 0, 0, 0, 0, "_hs_subscpt_free_subscpt", 0, "_hs_subscpt_sip_cb", "_hs_ims_capab_ctxt_free", "_hs_ims_capab_sip_cb", 0, "_hs_http_ctxt_info_free", 0, "_hs_http_wasm_success_cb", "_hs_http_wasm_failure_cb", "_hs_http_wasm_progress_cb", "_hs_http_digest_challenge_free", "_hs_http_digest_response_free", "_hs_sip326x_nhm_free_binding", "_hs_sip326x_tu_free_reg", "_hs_sip326x_tu_free_regtable_entry", "_hs_sip326x_tu_free_dlg", "_hs_sip_xml_reginfo_contact_free", "_hs_sip_xml_reginfo_reg_free", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_conf_ep_free", 0, "_hs_ims_conf_media_free", 0, 0, 0, 0, "_hs_ims_conf_avb_media_free", "_hs_ims_conf_user_free", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv", 0, "_undo", "_nodtor", "_cleanup_14569", "__ZNSt3__26locale2id6__initEv", "__ZNSt3__217__call_once_proxyINS_5tupleIJONS_12_GLOBAL__N_111__fake_bindEEEEEEvPv", "__ZNSt3__212__do_nothingEPv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_vif = [ 0 ];
var debug_table_viff = [ 0 ];
var debug_table_vifff = [ 0 ];
var debug_table_viffff = [ 0 ];
var debug_table_vii = [ 0, "__ZN24CallSessionNotifyHandler24onCallProgressIndicationE12eCallState_t", "__ZN24CallSessionNotifyHandler26onAnswerCallFailIndicationE17eCallReasonCode_t", "__ZN24CallSessionNotifyHandler23onEndCallFailIndicationE17eCallReasonCode_t", "__ZN24CallSessionNotifyHandler11onCallEndedE17eCallReasonCode_t", "__ZN24CallSessionNotifyHandler22onRemoteHoldIndicationEb", 0, 0, 0, 0, "__ZN24CallSessionNotifyHandler21onCallTransferFailureE17eCallReasonCode_t", "__ZN24CallSessionNotifyHandler17onCallTransferredE14UserIdentity_t", 0, 0, 0, 0, 0, 0, 0, "__ZN24CallManagerNotifyHandler18onSwitchCallFailedE17eCallReasonCode_t", 0, 0, 0, "__ZN24CallManagerNotifyHandler28onVoiceMessageWaitIndicationEi", "__ZN16SdkNotifyHandler23onInitializationSuccessE19eSystemReasonCode_t", "__ZN16SdkNotifyHandler22onInitializationFailedE19eSystemReasonCode_t", 0, 0, "__ZN16SdkNotifyHandler15onOtpSendFailedE25eProvisioningReasonCode_t", 0, "__ZN16SdkNotifyHandler23onOtpVerificationFailedE25eProvisioningReasonCode_t", 0, "__ZN16SdkNotifyHandler20onRegistrationFailedE21eRegisterReasonCode_t", 0, "__ZN16SdkNotifyHandler22onDeregistrationFailedE21eRegisterReasonCode_t", "__ZN16SdkNotifyHandler18onNetworkConnectedE17eConnectionType_t", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_voip_ccm_c002_null", "_hs_voip_ccm_c002_offhook", "_hs_voip_ccm_c002_rsrcinit", "_hs_voip_ccm_c002_conntd_rsrcwait", "_hs_voip_ccm_c002_callinitiated", "_hs_voip_ccm_c002_incoming", "_hs_voip_ccm_oc_proceeding_c002", "_hs_voip_ccm_ic_proceeding_c002", "_hs_voip_ccm_c002_alert", "_hs_voip_ccm_c002_conn_ack", "_hs_voip_ccm_c002_connected", "_hs_voip_ccm_c002_release", "_hs_voip_ccm_c002_error", "_hs_voip_ccm_c002_held_initiated", "_hs_voip_ccm_c002_held_wait", "_hs_voip_ccm_c002_held_ack", "_hs_voip_ccm_c002_held", "_hs_voip_ccm_c002_ctheld", "_hs_voip_ccm_c002_ct_initiated", "_hs_voip_ccm_c002_ct_wait", "_hs_voip_ccm_c002_change_codec", "_hs_voip_ccm_c002_update_initiated", "_hs_voip_ccm_c002_update_rcvd", "_hs_voip_ccm_c002_callwaiting", "_hs_voip_ccm_c002_connected_ring", "_hs_voip_ccm_c002_fxo_dialtone", "_hs_voip_ccm_c002_fxo_ringback_tone", "_hs_voip_ccm_c002_user_resp", "_hs_voip_ccm_mc_incoming", "_hs_voip_ccm_mc_rsrcinit", "_hs_voip_ccm_mc_conntd_rsrcwait", "_hs_voip_ccm_mc_connected", "_hs_voip_ccm_mc_update_rcvd", "_hs_voip_ccm_mc_held_wait", "_hs_subscpt_notifier_app_init", "_hs_subscpt_notifier_app_active", "_hs_subscpt_notifier_sip_states", "_hs_subscpt_notifier_sip_expired", "_hs_subscpt_subscb_app_states", "_hs_subscpt_subscb_app_deactive", "_hs_subscpt_subscb_sip_init", "_hs_subscpt_subscb_sip_active", "_hs_subscpt_subscb_sip_deactive", "_hs_subscpt_subscb_sip_toexpire", "_hs_subscpt_subscb_sip_unsuscbinit", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle10AbiTagAttr9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle4Node10printRightERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle4Node11getBaseNameEv", 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution11getBaseNameEv", 0, "__ZNK12_GLOBAL__N_116itanium_demangle20PostfixQualifiedType9printLeftERNS_12OutputStreamE", 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType10printRightERNS_12OutputStreamE", 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle11PointerType9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle11PointerType10printRightERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs11getBaseNameEv", 0, "__ZNK12_GLOBAL__N_116itanium_demangle12TemplateArgs9printLeftERNS_12OutputStreamE", 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack10printRightERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle15IntegerCastExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeE9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdE9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfE9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle8BoolExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle14IntegerLiteral9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle20TemplateArgumentPack9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle9ThrowExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle12InitListExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle13NodeArrayNode9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle13EnclosingExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle19SizeofParamPackExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle22ParameterPackExpansion9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle8CastExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle15ConditionalExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle7NewExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle11PostfixExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle15BracedRangeExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle10BracedExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle8NameType9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle8NameType11getBaseNameEv", 0, "__ZNK12_GLOBAL__N_116itanium_demangle18ArraySubscriptExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle10MemberExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName11getBaseNameEv", 0, "__ZNK12_GLOBAL__N_116itanium_demangle15LiteralOperator9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle22ConversionOperatorType9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle8DtorName9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName11getBaseNameEv", 0, "__ZNK12_GLOBAL__N_116itanium_demangle10DeleteExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle14ConversionExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle8CallExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle10PrefixExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle10BinaryExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle8FoldExpr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle13FunctionParam9printLeftERNS_12OutputStreamE", 0, 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference10printRightERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefType9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName11getBaseNameEv", 0, "__ZNK12_GLOBAL__N_116itanium_demangle21StructuredBindingName9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle15ClosureTypeName9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle15UnnamedTypeName9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle9LocalName9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle12CtorDtorName9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution11getBaseNameEv", 0, "__ZNK12_GLOBAL__N_116itanium_demangle10NestedName9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle10NestedName11getBaseNameEv", 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType10printRightERNS_12OutputStreamE", 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType10printRightERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle10VectorType9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle15PixelVectorType9printLeftERNS_12OutputStreamE", 0, 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle8QualType9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle8QualType10printRightERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle17VendorExtQualType9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle13ObjCProtoName9printLeftERNS_12OutputStreamE", 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType10printRightERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpec9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle12NoexceptSpec9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle11SpecialName9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle9DotSuffix9printLeftERNS_12OutputStreamE", 0, 0, 0, "__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding9printLeftERNS_12OutputStreamE", "__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding10printRightERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle12EnableIfAttr9printLeftERNS_12OutputStreamE", 0, "__ZNK12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialName9printLeftERNS_12OutputStreamE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5imbueERKNS_6localeE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5imbueERKNS_6localeE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIwE5imbueERKNS_6localeE", 0, 0, 0, 0, "__ZNSt3__211__stdoutbufIcE5imbueERKNS_6localeE", 0, 0, 0, 0, "__ZNSt3__210__stdinbufIwE5imbueERKNS_6localeE", 0, 0, 0, 0, "__ZNSt3__210__stdinbufIcE5imbueERKNS_6localeE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__210moneypunctIcLb0EE11do_groupingEv", "__ZNKSt3__210moneypunctIcLb0EE14do_curr_symbolEv", "__ZNKSt3__210moneypunctIcLb0EE16do_positive_signEv", "__ZNKSt3__210moneypunctIcLb0EE16do_negative_signEv", 0, "__ZNKSt3__210moneypunctIcLb0EE13do_pos_formatEv", "__ZNKSt3__210moneypunctIcLb0EE13do_neg_formatEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIcLb1EE11do_groupingEv", "__ZNKSt3__210moneypunctIcLb1EE14do_curr_symbolEv", "__ZNKSt3__210moneypunctIcLb1EE16do_positive_signEv", "__ZNKSt3__210moneypunctIcLb1EE16do_negative_signEv", 0, "__ZNKSt3__210moneypunctIcLb1EE13do_pos_formatEv", "__ZNKSt3__210moneypunctIcLb1EE13do_neg_formatEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIwLb0EE11do_groupingEv", "__ZNKSt3__210moneypunctIwLb0EE14do_curr_symbolEv", "__ZNKSt3__210moneypunctIwLb0EE16do_positive_signEv", "__ZNKSt3__210moneypunctIwLb0EE16do_negative_signEv", 0, "__ZNKSt3__210moneypunctIwLb0EE13do_pos_formatEv", "__ZNKSt3__210moneypunctIwLb0EE13do_neg_formatEv", 0, 0, 0, 0, "__ZNKSt3__210moneypunctIwLb1EE11do_groupingEv", "__ZNKSt3__210moneypunctIwLb1EE14do_curr_symbolEv", "__ZNKSt3__210moneypunctIwLb1EE16do_positive_signEv", "__ZNKSt3__210moneypunctIwLb1EE16do_negative_signEv", 0, "__ZNKSt3__210moneypunctIwLb1EE13do_pos_formatEv", "__ZNKSt3__210moneypunctIwLb1EE13do_neg_formatEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28messagesIcE8do_closeEl", 0, 0, 0, 0, "__ZNKSt3__28messagesIwE8do_closeEl", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28numpunctIcE11do_groupingEv", "__ZNKSt3__28numpunctIcE11do_truenameEv", "__ZNKSt3__28numpunctIcE12do_falsenameEv", 0, 0, 0, 0, "__ZNKSt3__28numpunctIwE11do_groupingEv", "__ZNKSt3__28numpunctIwE11do_truenameEv", "__ZNKSt3__28numpunctIwE12do_falsenameEv", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_async_open_cbk", "_async_message_cb", "_async_close_cb", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_pop_arg_long_double", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_viif = [ 0 ];
var debug_table_viifi = [ 0 ];
var debug_table_viii = [ 0, 0, 0, 0, 0, 0, "__ZN24CallSessionNotifyHandler21onLocalHoldIndicationEb17eCallReasonCode_t", "__ZN24CallSessionNotifyHandler16onMuteIndicationEb17eCallReasonCode_t", "__ZN24CallSessionNotifyHandler21onCallTransferRequestE14UserIdentity_t17eCallReasonCode_t", 0, 0, 0, "__ZN24CallSessionNotifyHandler14onCallReplacedE14UserIdentity_tS0_", 0, "__ZN24CallSessionNotifyHandler20onCallForwardRequestE14UserIdentity_t17eCallReasonCode_t", "__ZN24CallSessionNotifyHandler15onCallForwardedE14UserIdentity_t17eCallReasonCode_t", 0, "__ZN24CallManagerNotifyHandler11onCallEndedEj17eCallReasonCode_t", 0, 0, "__ZN24CallManagerNotifyHandler24onIncomingCallRedirectedE14UserIdentity_t17eCallReasonCode_t", "__ZN24CallManagerNotifyHandler22onIncomingCallRejectedE14UserIdentity_t17eCallReasonCode_t", 0, 0, 0, 0, 0, 0, 0, "__ZN16SdkNotifyHandler24onOtpVerificationSuccessENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE14UserIdentity_t", 0, 0, 0, 0, 0, 0, 0, "_hs_voip_ccm_dim_app_null", "_hs_voip_ccm_dim_app_offhook", "_hs_voip_ccm_dim_app_rsrcinit", "_hs_voip_ccm_dim_app_conntd_rsrcwait", "_hs_voip_ccm_dim_app_callinitiated", "_hs_voip_ccm_dim_app_incoming", "_hs_voip_ccm_oc_proceeding_dim_app", "_hs_voip_ccm_ic_proceeding_dim_app", "_hs_voip_ccm_dim_app_alert", "_hs_voip_ccm_dim_app_conn_ack", "_hs_voip_ccm_dim_app_connected", "_hs_voip_ccm_dim_app_release", "_hs_voip_ccm_dim_app_error", "_hs_voip_ccm_dim_app_held_initiated", "_hs_voip_ccm_dim_app_held_wait", "_hs_voip_ccm_dim_app_held_ack", "_hs_voip_ccm_dim_app_held", "_hs_voip_ccm_dim_app_ctheld", "_hs_voip_ccm_dim_app_ct_initiated", "_hs_voip_ccm_dim_app_ct_wait", "_hs_voip_ccm_dim_app_change_codec", "_hs_voip_ccm_dim_app_callwaiting", "_hs_voip_ccm_dim_app_connected_ring", "_hs_voip_ccm_dim_app_fxo_dialtone", "_hs_voip_ccm_dim_app_fxo_ringback_tone", "_hs_voip_ccm_dim_app_user_resp", "_hs_voip_ccm_dim_app_provisioning", "_hs_voip_ccm_dim_app_update_init", "_hs_voip_ccm_dim_app_update_rcvd", "_hs_voip_ccm_dim_app_call_pickup", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_ims_httpprov_dec_param_vers", "_hs_ims_httpprov_dec_param_application", "_hs_ims_httpprov_dec_param_pubid", "_hs_ims_httpprov_dec_param_pcscfaddr", "_hs_ims_httpprov_dec_param_appauth", "_hs_ims_httpprov_dec_param_flowtalk", "_hs_ims_httpprov_dec_param_stunaddress", "_hs_ims_httpprov_dec_param_turnaddress", "_hs_ims_httpprov_dec_param_msrprelay_addr", "_hs_ims_httpprov_dec_param_services", "_hs_ims_httpprov_dec_param_presence", "_hs_ims_httpprov_dec_param_standalone", "_hs_ims_httpprov_dec_param_chat", "_hs_ims_httpprov_dec_param_ft", "_hs_ims_httpprov_dec_param_chatbot", "_hs_ims_httpprov_dec_param_msgstore", "_hs_ims_httpprov_dec_param_capdiscovery", "_hs_ims_httpprov_dec_param_usrmsg", "_hs_ims_httpprov_dec_param_others", "_hs_ims_httpprov_dec_param_xport", "_hs_ims_httpprov_dec_param_apn", "_hs_ims_httpprov_dec_param_suppl", "_hs_ims_httpprov_dec_param_xdms", "_hs_ims_httpprov_dec_param_location", "_hs_ims_httpprov_dec_param_vipcontacts", "_hs_ims_httpprov_dec_param_links", "_hs_ims_httpprov_dec_param_favlink", "_hs_ims_httpprov_dec_param_confref", "_hs_ims_httpprov_dec_param_ext", "_hs_ims_httpprov_dec_param_secondarydevice", "_hs_ims_httpprov_dec_param_icsi", "_hs_ims_httpprov_dec_param_phnctxt", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN17HsCommonSdkWasmIf4initENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_viiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi", 0, 0, 0, "__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi", 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekposENS_4fposI11__mbstate_tEEj", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekposENS_4fposI11__mbstate_tEEj", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__27collateIcE12do_transformEPKcS3_", 0, 0, 0, 0, "__ZNKSt3__27collateIwE12do_transformEPKwS3_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFvNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_EvPS2_JS9_S9_EE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_ESJ_", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_error_callback", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_rp_radio_on", "_hs_rp_radio_off", "_hs_rp_conn_nw", "_hs_rp_disconn_nw", "_hs_rp_timer_init", "_hs_rp_timer_start", "_hs_rp_timer_fired", "_hs_rp_timer_stop", "_hs_rp_timer_reset", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "_hs_fwk_sm_send_action", "_hs_fwk_sm_assign_action", "_hs_fwk_sm_if_action", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_viiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZN24CallManagerNotifyHandler14onIncomingCallE14UserIdentity_t11eCallMode_tjb", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib", 0, 0, 0, "__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_viiiiii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib", 0, 0, 0, "__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNKSt3__28messagesIcE6do_getEliiRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE", 0, 0, 0, 0, "__ZNKSt3__28messagesIwE6do_getEliiRKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEE", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_table_viiiiiii = [ 0 ];
var debug_table_viiiiiiii = [ 0 ];
var debug_table_viiiiiiiii = [ 0 ];
var debug_table_viiiiiiiiii = [ 0 ];
var debug_table_viiiiiiiiiii = [ 0 ];
var debug_table_viijii = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekoffExNS_8ios_base7seekdirEj", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekoffExNS_8ios_base7seekdirEj", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
var debug_tables = {
 "i": debug_table_i,
 "ii": debug_table_ii,
 "iidiiii": debug_table_iidiiii,
 "iii": debug_table_iii,
 "iiii": debug_table_iiii,
 "iiiii": debug_table_iiiii,
 "iiiiid": debug_table_iiiiid,
 "iiiiii": debug_table_iiiiii,
 "iiiiiid": debug_table_iiiiiid,
 "iiiiiii": debug_table_iiiiiii,
 "iiiiiiii": debug_table_iiiiiiii,
 "iiiiiiiii": debug_table_iiiiiiiii,
 "iiiiiiiiii": debug_table_iiiiiiiiii,
 "iiiiij": debug_table_iiiiij,
 "jiji": debug_table_jiji,
 "v": debug_table_v,
 "vf": debug_table_vf,
 "vff": debug_table_vff,
 "vfff": debug_table_vfff,
 "vffff": debug_table_vffff,
 "vi": debug_table_vi,
 "vif": debug_table_vif,
 "viff": debug_table_viff,
 "vifff": debug_table_vifff,
 "viffff": debug_table_viffff,
 "vii": debug_table_vii,
 "viif": debug_table_viif,
 "viifi": debug_table_viifi,
 "viii": debug_table_viii,
 "viiii": debug_table_viiii,
 "viiiii": debug_table_viiiii,
 "viiiiii": debug_table_viiiiii,
 "viiiiiii": debug_table_viiiiiii,
 "viiiiiiii": debug_table_viiiiiiii,
 "viiiiiiiii": debug_table_viiiiiiiii,
 "viiiiiiiiii": debug_table_viiiiiiiiii,
 "viiiiiiiiiii": debug_table_viiiiiiiiiii,
 "viijii": debug_table_viijii
};
function nullFunc_i(x) {
 abortFnPtrError(x, "i");
}
function nullFunc_ii(x) {
 abortFnPtrError(x, "ii");
}
function nullFunc_iidiiii(x) {
 abortFnPtrError(x, "iidiiii");
}
function nullFunc_iii(x) {
 abortFnPtrError(x, "iii");
}
function nullFunc_iiii(x) {
 abortFnPtrError(x, "iiii");
}
function nullFunc_iiiii(x) {
 abortFnPtrError(x, "iiiii");
}
function nullFunc_iiiiid(x) {
 abortFnPtrError(x, "iiiiid");
}
function nullFunc_iiiiii(x) {
 abortFnPtrError(x, "iiiiii");
}
function nullFunc_iiiiiid(x) {
 abortFnPtrError(x, "iiiiiid");
}
function nullFunc_iiiiiii(x) {
 abortFnPtrError(x, "iiiiiii");
}
function nullFunc_iiiiiiii(x) {
 abortFnPtrError(x, "iiiiiiii");
}
function nullFunc_iiiiiiiii(x) {
 abortFnPtrError(x, "iiiiiiiii");
}
function nullFunc_iiiiiiiiii(x) {
 abortFnPtrError(x, "iiiiiiiiii");
}
function nullFunc_iiiiij(x) {
 abortFnPtrError(x, "iiiiij");
}
function nullFunc_jiji(x) {
 abortFnPtrError(x, "jiji");
}
function nullFunc_v(x) {
 abortFnPtrError(x, "v");
}
function nullFunc_vf(x) {
 abortFnPtrError(x, "vf");
}
function nullFunc_vff(x) {
 abortFnPtrError(x, "vff");
}
function nullFunc_vfff(x) {
 abortFnPtrError(x, "vfff");
}
function nullFunc_vffff(x) {
 abortFnPtrError(x, "vffff");
}
function nullFunc_vi(x) {
 abortFnPtrError(x, "vi");
}
function nullFunc_vif(x) {
 abortFnPtrError(x, "vif");
}
function nullFunc_viff(x) {
 abortFnPtrError(x, "viff");
}
function nullFunc_vifff(x) {
 abortFnPtrError(x, "vifff");
}
function nullFunc_viffff(x) {
 abortFnPtrError(x, "viffff");
}
function nullFunc_vii(x) {
 abortFnPtrError(x, "vii");
}
function nullFunc_viif(x) {
 abortFnPtrError(x, "viif");
}
function nullFunc_viifi(x) {
 abortFnPtrError(x, "viifi");
}
function nullFunc_viii(x) {
 abortFnPtrError(x, "viii");
}
function nullFunc_viiii(x) {
 abortFnPtrError(x, "viiii");
}
function nullFunc_viiiii(x) {
 abortFnPtrError(x, "viiiii");
}
function nullFunc_viiiiii(x) {
 abortFnPtrError(x, "viiiiii");
}
function nullFunc_viiiiiii(x) {
 abortFnPtrError(x, "viiiiiii");
}
function nullFunc_viiiiiiii(x) {
 abortFnPtrError(x, "viiiiiiii");
}
function nullFunc_viiiiiiiii(x) {
 abortFnPtrError(x, "viiiiiiiii");
}
function nullFunc_viiiiiiiiii(x) {
 abortFnPtrError(x, "viiiiiiiiii");
}
function nullFunc_viiiiiiiiiii(x) {
 abortFnPtrError(x, "viiiiiiiiiii");
}
function nullFunc_viijii(x) {
 abortFnPtrError(x, "viijii");
}
var asmGlobalArg = {};
var asmLibraryArg = {
 "abort": abort,
 "setTempRet0": setTempRet0,
 "getTempRet0": getTempRet0,
 "abortStackOverflow": abortStackOverflow,
 "nullFunc_i": nullFunc_i,
 "nullFunc_ii": nullFunc_ii,
 "nullFunc_iidiiii": nullFunc_iidiiii,
 "nullFunc_iii": nullFunc_iii,
 "nullFunc_iiii": nullFunc_iiii,
 "nullFunc_iiiii": nullFunc_iiiii,
 "nullFunc_iiiiid": nullFunc_iiiiid,
 "nullFunc_iiiiii": nullFunc_iiiiii,
 "nullFunc_iiiiiid": nullFunc_iiiiiid,
 "nullFunc_iiiiiii": nullFunc_iiiiiii,
 "nullFunc_iiiiiiii": nullFunc_iiiiiiii,
 "nullFunc_iiiiiiiii": nullFunc_iiiiiiiii,
 "nullFunc_iiiiiiiiii": nullFunc_iiiiiiiiii,
 "nullFunc_iiiiij": nullFunc_iiiiij,
 "nullFunc_jiji": nullFunc_jiji,
 "nullFunc_v": nullFunc_v,
 "nullFunc_vf": nullFunc_vf,
 "nullFunc_vff": nullFunc_vff,
 "nullFunc_vfff": nullFunc_vfff,
 "nullFunc_vffff": nullFunc_vffff,
 "nullFunc_vi": nullFunc_vi,
 "nullFunc_vif": nullFunc_vif,
 "nullFunc_viff": nullFunc_viff,
 "nullFunc_vifff": nullFunc_vifff,
 "nullFunc_viffff": nullFunc_viffff,
 "nullFunc_vii": nullFunc_vii,
 "nullFunc_viif": nullFunc_viif,
 "nullFunc_viifi": nullFunc_viifi,
 "nullFunc_viii": nullFunc_viii,
 "nullFunc_viiii": nullFunc_viiii,
 "nullFunc_viiiii": nullFunc_viiiii,
 "nullFunc_viiiiii": nullFunc_viiiiii,
 "nullFunc_viiiiiii": nullFunc_viiiiiii,
 "nullFunc_viiiiiiii": nullFunc_viiiiiiii,
 "nullFunc_viiiiiiiii": nullFunc_viiiiiiiii,
 "nullFunc_viiiiiiiiii": nullFunc_viiiiiiiiii,
 "nullFunc_viiiiiiiiiii": nullFunc_viiiiiiiiiii,
 "nullFunc_viijii": nullFunc_viijii,
 "ClassHandle": ClassHandle,
 "ClassHandle_clone": ClassHandle_clone,
 "ClassHandle_delete": ClassHandle_delete,
 "ClassHandle_deleteLater": ClassHandle_deleteLater,
 "ClassHandle_isAliasOf": ClassHandle_isAliasOf,
 "ClassHandle_isDeleted": ClassHandle_isDeleted,
 "RegisteredClass": RegisteredClass,
 "RegisteredPointer": RegisteredPointer,
 "RegisteredPointer_deleteObject": RegisteredPointer_deleteObject,
 "RegisteredPointer_destructor": RegisteredPointer_destructor,
 "RegisteredPointer_fromWireType": RegisteredPointer_fromWireType,
 "RegisteredPointer_getPointee": RegisteredPointer_getPointee,
 "_CallManagerNotificationHandlerWrapper": _CallManagerNotificationHandlerWrapper,
 "_CallSessionNotifyHandlerWrapper": _CallSessionNotifyHandlerWrapper,
 "_CallSessionNotifyHandlerWrapper1": _CallSessionNotifyHandlerWrapper1,
 "_CallSessionNotifyHandlerWrapperWasm": _CallSessionNotifyHandlerWrapperWasm,
 "_SystemManagerNotificationHandlerWrapper": _SystemManagerNotificationHandlerWrapper,
 "___assert_fail": ___assert_fail,
 "___buildEnvironment": ___buildEnvironment,
 "___call_main": ___call_main,
 "___clock_gettime": ___clock_gettime,
 "___cxa_allocate_exception": ___cxa_allocate_exception,
 "___cxa_begin_catch": ___cxa_begin_catch,
 "___cxa_pure_virtual": ___cxa_pure_virtual,
 "___cxa_throw": ___cxa_throw,
 "___cxa_uncaught_exceptions": ___cxa_uncaught_exceptions,
 "___exception_addRef": ___exception_addRef,
 "___exception_deAdjust": ___exception_deAdjust,
 "___gxx_personality_v0": ___gxx_personality_v0,
 "___lock": ___lock,
 "___map_file": ___map_file,
 "___setErrNo": ___setErrNo,
 "___set_network_callback": ___set_network_callback,
 "___syscall10": ___syscall10,
 "___syscall102": ___syscall102,
 "___syscall122": ___syscall122,
 "___syscall140": ___syscall140,
 "___syscall142": ___syscall142,
 "___syscall145": ___syscall145,
 "___syscall146": ___syscall146,
 "___syscall195": ___syscall195,
 "___syscall20": ___syscall20,
 "___syscall220": ___syscall220,
 "___syscall221": ___syscall221,
 "___syscall38": ___syscall38,
 "___syscall39": ___syscall39,
 "___syscall40": ___syscall40,
 "___syscall5": ___syscall5,
 "___syscall54": ___syscall54,
 "___syscall6": ___syscall6,
 "___syscall91": ___syscall91,
 "___unlock": ___unlock,
 "__addDays": __addDays,
 "__arraySum": __arraySum,
 "__cleanup_thread": __cleanup_thread,
 "__embind_register_bool": __embind_register_bool,
 "__embind_register_class": __embind_register_class,
 "__embind_register_class_constructor": __embind_register_class_constructor,
 "__embind_register_class_function": __embind_register_class_function,
 "__embind_register_emval": __embind_register_emval,
 "__embind_register_enum": __embind_register_enum,
 "__embind_register_enum_value": __embind_register_enum_value,
 "__embind_register_float": __embind_register_float,
 "__embind_register_integer": __embind_register_integer,
 "__embind_register_memory_view": __embind_register_memory_view,
 "__embind_register_std_string": __embind_register_std_string,
 "__embind_register_std_wstring": __embind_register_std_wstring,
 "__embind_register_void": __embind_register_void,
 "__emscripten_fetch_cache_data": __emscripten_fetch_cache_data,
 "__emscripten_fetch_delete_cached_data": __emscripten_fetch_delete_cached_data,
 "__emscripten_fetch_free": __emscripten_fetch_free,
 "__emscripten_fetch_load_cached_data": __emscripten_fetch_load_cached_data,
 "__emscripten_fetch_xhr": __emscripten_fetch_xhr,
 "__emscripten_get_fetch_work_queue": __emscripten_get_fetch_work_queue,
 "__emscripten_syscall_munmap": __emscripten_syscall_munmap,
 "__emval_decref": __emval_decref,
 "__emval_register": __emval_register,
 "__findCanvasEventTarget": __findCanvasEventTarget,
 "__findEventTarget": __findEventTarget,
 "__inet_ntop4_raw": __inet_ntop4_raw,
 "__inet_ntop6_raw": __inet_ntop6_raw,
 "__inet_pton4_raw": __inet_pton4_raw,
 "__inet_pton6_raw": __inet_pton6_raw,
 "__isLeapYear": __isLeapYear,
 "__pthread_testcancel_js": __pthread_testcancel_js,
 "__read_sockaddr": __read_sockaddr,
 "__spawn_thread": __spawn_thread,
 "__write_sockaddr": __write_sockaddr,
 "_abort": _abort,
 "_clock_gettime": _clock_gettime,
 "_closePeerConnectionWrapper": _closePeerConnectionWrapper,
 "_createPeerConnectionWrapper": _createPeerConnectionWrapper,
 "_difftime": _difftime,
 "_embind_repr": _embind_repr,
 "_emscripten_asm_const_i": _emscripten_asm_const_i,
 "_emscripten_asm_const_ii": _emscripten_asm_const_ii,
 "_emscripten_asm_const_sync_on_main_thread_ii": _emscripten_asm_const_sync_on_main_thread_ii,
 "_emscripten_asm_const_sync_on_main_thread_iii": _emscripten_asm_const_sync_on_main_thread_iii,
 "_emscripten_asm_const_sync_on_main_thread_iiii": _emscripten_asm_const_sync_on_main_thread_iiii,
 "_emscripten_asm_const_sync_on_main_thread_iiiii": _emscripten_asm_const_sync_on_main_thread_iiiii,
 "_emscripten_asm_const_sync_on_main_thread_iiiiii": _emscripten_asm_const_sync_on_main_thread_iiiiii,
 "_emscripten_asm_const_sync_on_main_thread_iiiiiiiiiii": _emscripten_asm_const_sync_on_main_thread_iiiiiiiiiii,
 "_emscripten_conditional_set_current_thread_status_js": _emscripten_conditional_set_current_thread_status_js,
 "_emscripten_futex_wait": _emscripten_futex_wait,
 "_emscripten_futex_wake": _emscripten_futex_wake,
 "_emscripten_get_heap_size": _emscripten_get_heap_size,
 "_emscripten_get_now": _emscripten_get_now,
 "_emscripten_get_now_is_monotonic": _emscripten_get_now_is_monotonic,
 "_emscripten_has_threading_support": _emscripten_has_threading_support,
 "_emscripten_memcpy_big": _emscripten_memcpy_big,
 "_emscripten_proxy_to_main_thread_js": _emscripten_proxy_to_main_thread_js,
 "_emscripten_receive_on_main_thread_js": _emscripten_receive_on_main_thread_js,
 "_emscripten_resize_heap": _emscripten_resize_heap,
 "_emscripten_set_canvas_element_size": _emscripten_set_canvas_element_size,
 "_emscripten_set_canvas_element_size_calling_thread": _emscripten_set_canvas_element_size_calling_thread,
 "_emscripten_set_canvas_element_size_main_thread": _emscripten_set_canvas_element_size_main_thread,
 "_emscripten_set_current_thread_status_js": _emscripten_set_current_thread_status_js,
 "_emscripten_set_offscreencanvas_size_on_target_thread": _emscripten_set_offscreencanvas_size_on_target_thread,
 "_emscripten_set_offscreencanvas_size_on_target_thread_js": _emscripten_set_offscreencanvas_size_on_target_thread_js,
 "_emscripten_set_socket_close_callback": _emscripten_set_socket_close_callback,
 "_emscripten_set_socket_error_callback": _emscripten_set_socket_error_callback,
 "_emscripten_set_socket_message_callback": _emscripten_set_socket_message_callback,
 "_emscripten_set_socket_open_callback": _emscripten_set_socket_open_callback,
 "_emscripten_set_thread_name_js": _emscripten_set_thread_name_js,
 "_emscripten_start_fetch": _emscripten_start_fetch,
 "_emscripten_syscall": _emscripten_syscall,
 "_emscripten_webgl_create_context": _emscripten_webgl_create_context,
 "_emscripten_webgl_do_create_context": _emscripten_webgl_do_create_context,
 "_exit": _exit,
 "_gai_strerror": _gai_strerror,
 "_getaddrinfo": _getaddrinfo,
 "_getenv": _getenv,
 "_getnameinfo": _getnameinfo,
 "_gettimeofday": _gettimeofday,
 "_gmtime_r": _gmtime_r,
 "_inet_addr": _inet_addr,
 "_initPthreadsJS": _initPthreadsJS,
 "_llvm_stackrestore": _llvm_stackrestore,
 "_llvm_stacksave": _llvm_stacksave,
 "_llvm_trap": _llvm_trap,
 "_localtime": _localtime,
 "_localtime_r": _localtime_r,
 "_mktime": _mktime,
 "_modifyMediaStreamWrapper": _modifyMediaStreamWrapper,
 "_pthread_cleanup_pop": _pthread_cleanup_pop,
 "_pthread_cleanup_push": _pthread_cleanup_push,
 "_pthread_create": _pthread_create,
 "_pthread_exit": _pthread_exit,
 "_pthread_getschedparam": _pthread_getschedparam,
 "_pthread_join": _pthread_join,
 "_raise": _raise,
 "_receivingRemoteIceWrapper": _receivingRemoteIceWrapper,
 "_setRemoteDescriptionWrapper": _setRemoteDescriptionWrapper,
 "_sigaction": _sigaction,
 "_sigaddset": _sigaddset,
 "_sigemptyset": _sigemptyset,
 "_sigprocmask": _sigprocmask,
 "_strftime": _strftime,
 "_strftime_l": _strftime_l,
 "_time": _time,
 "_tzset": _tzset,
 "abortOnCannotGrowMemory": abortOnCannotGrowMemory,
 "attachFinalizer": attachFinalizer,
 "constNoSmartPtrRawPointerToWireType": constNoSmartPtrRawPointerToWireType,
 "count_emval_handles": count_emval_handles,
 "craftInvokerFunction": craftInvokerFunction,
 "createNamedFunction": createNamedFunction,
 "demangle": demangle,
 "demangleAll": demangleAll,
 "detachFinalizer": detachFinalizer,
 "downcastPointer": downcastPointer,
 "embind__requireFunction": embind__requireFunction,
 "embind_init_charCodes": embind_init_charCodes,
 "emscripten_realloc_buffer": emscripten_realloc_buffer,
 "ensureOverloadTable": ensureOverloadTable,
 "enumReadValueFromPointer": enumReadValueFromPointer,
 "exposePublicSymbol": exposePublicSymbol,
 "extendError": extendError,
 "floatReadValueFromPointer": floatReadValueFromPointer,
 "flushPendingDeletes": flushPendingDeletes,
 "genericPointerToWireType": genericPointerToWireType,
 "getBasestPointer": getBasestPointer,
 "getInheritedInstance": getInheritedInstance,
 "getInheritedInstanceCount": getInheritedInstanceCount,
 "getLiveInheritedInstances": getLiveInheritedInstances,
 "getShiftFromSize": getShiftFromSize,
 "getTypeName": getTypeName,
 "get_first_emval": get_first_emval,
 "heap32VectorToArray": heap32VectorToArray,
 "init_ClassHandle": init_ClassHandle,
 "init_RegisteredPointer": init_RegisteredPointer,
 "init_embind": init_embind,
 "init_emval": init_emval,
 "integerReadValueFromPointer": integerReadValueFromPointer,
 "jsStackTrace": jsStackTrace,
 "makeClassHandle": makeClassHandle,
 "makeLegalFunctionName": makeLegalFunctionName,
 "new_": new_,
 "nonConstNoSmartPtrRawPointerToWireType": nonConstNoSmartPtrRawPointerToWireType,
 "readLatin1String": readLatin1String,
 "registerType": registerType,
 "releaseClassHandle": releaseClassHandle,
 "replacePublicSymbol": replacePublicSymbol,
 "requireRegisteredType": requireRegisteredType,
 "runDestructor": runDestructor,
 "runDestructors": runDestructors,
 "setDelayFunction": setDelayFunction,
 "shallowCopyInternalPointer": shallowCopyInternalPointer,
 "simpleReadValueFromPointer": simpleReadValueFromPointer,
 "stackTrace": stackTrace,
 "stringToNewUTF8": stringToNewUTF8,
 "throwBindingError": throwBindingError,
 "throwInstanceAlreadyDeleted": throwInstanceAlreadyDeleted,
 "throwInternalError": throwInternalError,
 "throwUnboundTypeError": throwUnboundTypeError,
 "upcastPointer": upcastPointer,
 "whenDependentTypesAreResolved": whenDependentTypesAreResolved,
 "tempDoublePtr": tempDoublePtr,
 "DYNAMICTOP_PTR": DYNAMICTOP_PTR
};
var asm = Module["asm"](asmGlobalArg, asmLibraryArg, buffer);
Module["asm"] = asm;
var _ComputeOPc = Module["_ComputeOPc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ComputeOPc"].apply(null, arguments);
});
var _DigestCalcHA1 = Module["_DigestCalcHA1"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_DigestCalcHA1"].apply(null, arguments);
});
var _DigestCalcResponse = Module["_DigestCalcResponse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_DigestCalcResponse"].apply(null, arguments);
});
var _MD5Final = Module["_MD5Final"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_MD5Final"].apply(null, arguments);
});
var _MD5Init = Module["_MD5Init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_MD5Init"].apply(null, arguments);
});
var _MD5Transform = Module["_MD5Transform"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_MD5Transform"].apply(null, arguments);
});
var _MD5Update = Module["_MD5Update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_MD5Update"].apply(null, arguments);
});
var _MixColumn = Module["_MixColumn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_MixColumn"].apply(null, arguments);
});
var _RijndaelEncrypt = Module["_RijndaelEncrypt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_RijndaelEncrypt"].apply(null, arguments);
});
var _RijndaelKeySchedule = Module["_RijndaelKeySchedule"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_RijndaelKeySchedule"].apply(null, arguments);
});
var __GLOBAL__I_000101 = Module["__GLOBAL__I_000101"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__GLOBAL__I_000101"].apply(null, arguments);
});
var __GLOBAL__sub_I_HsSystemManager_cpp = Module["__GLOBAL__sub_I_HsSystemManager_cpp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__GLOBAL__sub_I_HsSystemManager_cpp"].apply(null, arguments);
});
var __GLOBAL__sub_I_bind_cpp = Module["__GLOBAL__sub_I_bind_cpp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__GLOBAL__sub_I_bind_cpp"].apply(null, arguments);
});
var __GLOBAL__sub_I_hs_ims_wasm_if_cpp = Module["__GLOBAL__sub_I_hs_ims_wasm_if_cpp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__GLOBAL__sub_I_hs_ims_wasm_if_cpp"].apply(null, arguments);
});
var __GLOBAL__sub_I_iostream_cpp = Module["__GLOBAL__sub_I_iostream_cpp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__GLOBAL__sub_I_iostream_cpp"].apply(null, arguments);
});
var __Z11getUserNameNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = Module["__Z11getUserNameNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__Z11getUserNameNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"].apply(null, arguments);
});
var __Z16hs_sdk_app_startPv = Module["__Z16hs_sdk_app_startPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__Z16hs_sdk_app_startPv"].apply(null, arguments);
});
var __Z17getCallReasonCodei = Module["__Z17getCallReasonCodei"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__Z17getCallReasonCodei"].apply(null, arguments);
});
var __Z19hs_sdk_thread_startPv = Module["__Z19hs_sdk_thread_startPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__Z19hs_sdk_thread_startPv"].apply(null, arguments);
});
var __Z9decodeUriPcS_RiS_S_ = Module["__Z9decodeUriPcS_RiS_S_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__Z9decodeUriPcS_RiS_S_"].apply(null, arguments);
});
var __ZL10fetch_freeP18emscripten_fetch_t = Module["__ZL10fetch_freeP18emscripten_fetch_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZL10fetch_freeP18emscripten_fetch_t"].apply(null, arguments);
});
var __ZL28demangling_terminate_handlerv = Module["__ZL28demangling_terminate_handlerv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZL28demangling_terminate_handlerv"].apply(null, arguments);
});
var __ZL8is_equalPKSt9type_infoS1_b = Module["__ZL8is_equalPKSt9type_infoS1_b"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZL8is_equalPKSt9type_infoS1_b"].apply(null, arguments);
});
var __ZN10HsSdkUtils14getReturnValueE14hs_msm_retcode = Module["__ZN10HsSdkUtils14getReturnValueE14hs_msm_retcode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10HsSdkUtils14getReturnValueE14hs_msm_retcode"].apply(null, arguments);
});
var __ZN10HsSettings16getConferenceUriERNSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE = Module["__ZN10HsSettings16getConferenceUriERNSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10HsSettings16getConferenceUriERNSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"].apply(null, arguments);
});
var __ZN10HsSettings16setApplicationIdEj14UserIdentity_t = Module["__ZN10HsSettings16setApplicationIdEj14UserIdentity_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10HsSettings16setApplicationIdEj14UserIdentity_t"].apply(null, arguments);
});
var __ZN10HsSettingsC2Ev = Module["__ZN10HsSettingsC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10HsSettingsC2Ev"].apply(null, arguments);
});
var __ZN10HsSettingsD2Ev = Module["__ZN10HsSettingsD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10HsSettingsD2Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv112_GLOBAL__N_110construct_Ev = Module["__ZN10__cxxabiv112_GLOBAL__N_110construct_Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv112_GLOBAL__N_110construct_Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv112_GLOBAL__N_115set_initializedEPj = Module["__ZN10__cxxabiv112_GLOBAL__N_115set_initializedEPj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv112_GLOBAL__N_115set_initializedEPj"].apply(null, arguments);
});
var __ZN10__cxxabiv112_GLOBAL__N_18get_lockEj = Module["__ZN10__cxxabiv112_GLOBAL__N_18get_lockEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv112_GLOBAL__N_18get_lockEj"].apply(null, arguments);
});
var __ZN10__cxxabiv112_GLOBAL__N_18set_lockERjb = Module["__ZN10__cxxabiv112_GLOBAL__N_18set_lockERjb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv112_GLOBAL__N_18set_lockERjb"].apply(null, arguments);
});
var __ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv = Module["__ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv"].apply(null, arguments);
});
var __ZN10__cxxabiv116__enum_type_infoD0Ev = Module["__ZN10__cxxabiv116__enum_type_infoD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv116__enum_type_infoD0Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv116__shim_type_infoD2Ev = Module["__ZN10__cxxabiv116__shim_type_infoD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv116__shim_type_infoD2Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv117__class_type_infoD0Ev = Module["__ZN10__cxxabiv117__class_type_infoD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv117__class_type_infoD0Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv119__getExceptionClassEPK17_Unwind_Exception = Module["__ZN10__cxxabiv119__getExceptionClassEPK17_Unwind_Exception"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv119__getExceptionClassEPK17_Unwind_Exception"].apply(null, arguments);
});
var __ZN10__cxxabiv119__pointer_type_infoD0Ev = Module["__ZN10__cxxabiv119__pointer_type_infoD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv119__pointer_type_infoD0Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv120__free_with_fallbackEPv = Module["__ZN10__cxxabiv120__free_with_fallbackEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv120__free_with_fallbackEPv"].apply(null, arguments);
});
var __ZN10__cxxabiv120__si_class_type_infoD0Ev = Module["__ZN10__cxxabiv120__si_class_type_infoD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv120__si_class_type_infoD0Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv121__isOurExceptionClassEPK17_Unwind_Exception = Module["__ZN10__cxxabiv121__isOurExceptionClassEPK17_Unwind_Exception"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv121__isOurExceptionClassEPK17_Unwind_Exception"].apply(null, arguments);
});
var __ZN10__cxxabiv121__vmi_class_type_infoD0Ev = Module["__ZN10__cxxabiv121__vmi_class_type_infoD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv121__vmi_class_type_infoD0Ev"].apply(null, arguments);
});
var __ZN10__cxxabiv123__fundamental_type_infoD0Ev = Module["__ZN10__cxxabiv123__fundamental_type_infoD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10__cxxabiv123__fundamental_type_infoD0Ev"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIaEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIaEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIaEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIcEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIcEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIcEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIdEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIdEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIdEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIeEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIeEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIeEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIfEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIfEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIfEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIhEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIhEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIhEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIiEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIiEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIiEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIjEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIjEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIjEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIlEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIlEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIlEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewImEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewImEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewImEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIsEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIsEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIsEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_11memory_viewItEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewItEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_11memory_viewItEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINS_3valEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINS_3valEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINS_3valEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv = Module["__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIaE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIaE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIaE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIbE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIbE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIbE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIcE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIcE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIcE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIdE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIdE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIdE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIfE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIfE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIfE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIhE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIhE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIhE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIiE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIiE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIiE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIjE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIjE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIjE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIlE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIlE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIlE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDImE3getEv = Module["__ZN10emscripten8internal11LightTypeIDImE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDImE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIsE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIsE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIsE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDItE3getEv = Module["__ZN10emscripten8internal11LightTypeIDItE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDItE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal11LightTypeIDIvE3getEv = Module["__ZN10emscripten8internal11LightTypeIDIvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal11LightTypeIDIvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal12operator_newI17HsCommonSdkWasmIfJEEEPT_DpOT0_ = Module["__ZN10emscripten8internal12operator_newI17HsCommonSdkWasmIfJEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal12operator_newI17HsCommonSdkWasmIfJEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEES3_PS2_JSA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_E = Module["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEES3_PS2_JSA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_E"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEES3_PS2_JSA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_E"].apply(null, arguments);
});
var __ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_ES3_PS2_JSA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_ = Module["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_ES3_PS2_JSA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_ES3_PS2_JSA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_"].apply(null, arguments);
});
var __ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_SA_ES3_PS2_JSA_SA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_SK_ = Module["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_SA_ES3_PS2_JSA_SA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_SK_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfF14eReturnValue_tNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESA_SA_SA_ES3_PS2_JSA_SA_SA_SA_EE6invokeERKSC_SD_PNS0_11BindingTypeISA_vEUt_ESK_SK_SK_"].apply(null, arguments);
});
var __ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijEiPS2_JjEE6invokeERKS4_S5_j = Module["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijEiPS2_JjEE6invokeERKS4_S5_j"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijEiPS2_JjEE6invokeERKS4_S5_j"].apply(null, arguments);
});
var __ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijiEiPS2_JjiEE6invokeERKS4_S5_ji = Module["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijiEiPS2_JjiEE6invokeERKS4_S5_ji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFijiEiPS2_JjiEE6invokeERKS4_S5_ji"].apply(null, arguments);
});
var __ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFjNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEiEjPS2_JS9_iEE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_Ei = Module["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFjNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEiEjPS2_JS9_iEE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_Ei"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFjNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEiEjPS2_JS9_iEE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_Ei"].apply(null, arguments);
});
var __ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFvNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_EvPS2_JS9_S9_EE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_ESJ_ = Module["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFvNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_EvPS2_JS9_S9_EE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_ESJ_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13MethodInvokerIM17HsCommonSdkWasmIfFvNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_EvPS2_JS9_S9_EE6invokeERKSB_SC_PNS0_11BindingTypeIS9_vEUt_ESJ_"].apply(null, arguments);
});
var __ZN10emscripten8internal13getActualTypeI17HsCommonSdkWasmIfEEPKvPT_ = Module["__ZN10emscripten8internal13getActualTypeI17HsCommonSdkWasmIfEEPKvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal13getActualTypeI17HsCommonSdkWasmIfEEPKvPT_"].apply(null, arguments);
});
var __ZN10emscripten8internal14raw_destructorI17HsCommonSdkWasmIfEEvPT_ = Module["__ZN10emscripten8internal14raw_destructorI17HsCommonSdkWasmIfEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal14raw_destructorI17HsCommonSdkWasmIfEEvPT_"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIaEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIaEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIaEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIcEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIcEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIcEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIdEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIdEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIdEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIeEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIeEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIeEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIfEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIfEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIfEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIhEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIhEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIhEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIiEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIiEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIiEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIjEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIjEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIjEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIlEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIlEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIlEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewImEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewImEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewImEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewIsEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewIsEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewIsEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_11memory_viewItEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_11memory_viewItEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_11memory_viewItEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINS_3valEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINS_3valEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINS_3valEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEvE3getEv = Module["__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIavE3getEv = Module["__ZN10emscripten8internal6TypeIDIavE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIavE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIbvE3getEv = Module["__ZN10emscripten8internal6TypeIDIbvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIbvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIcvE3getEv = Module["__ZN10emscripten8internal6TypeIDIcvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIcvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIdvE3getEv = Module["__ZN10emscripten8internal6TypeIDIdvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIdvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIfvE3getEv = Module["__ZN10emscripten8internal6TypeIDIfvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIfvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIhvE3getEv = Module["__ZN10emscripten8internal6TypeIDIhvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIhvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIivE3getEv = Module["__ZN10emscripten8internal6TypeIDIivE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIivE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIjvE3getEv = Module["__ZN10emscripten8internal6TypeIDIjvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIjvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIlvE3getEv = Module["__ZN10emscripten8internal6TypeIDIlvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIlvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDImvE3getEv = Module["__ZN10emscripten8internal6TypeIDImvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDImvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIsvE3getEv = Module["__ZN10emscripten8internal6TypeIDIsvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIsvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDItvE3getEv = Module["__ZN10emscripten8internal6TypeIDItvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDItvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal6TypeIDIvvE3getEv = Module["__ZN10emscripten8internal6TypeIDIvvE3getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal6TypeIDIvvE3getEv"].apply(null, arguments);
});
var __ZN10emscripten8internal7InvokerIP17HsCommonSdkWasmIfJEE6invokeEPFS3_vE = Module["__ZN10emscripten8internal7InvokerIP17HsCommonSdkWasmIfJEE6invokeEPFS3_vE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN10emscripten8internal7InvokerIP17HsCommonSdkWasmIfJEE6invokeEPFS3_vE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_110StringViewC2EPKc = Module["__ZN12_GLOBAL__N_110StringViewC2EPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_110StringViewC2EPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_110StringViewC2EPKcS2_ = Module["__ZN12_GLOBAL__N_110StringViewC2EPKcS2_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_110StringViewC2EPKcS2_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_110StringViewC2Ev = Module["__ZN12_GLOBAL__N_110StringViewC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_110StringViewC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_112OutputStream18setCurrentPositionEm = Module["__ZN12_GLOBAL__N_112OutputStream18setCurrentPositionEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_112OutputStream18setCurrentPositionEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_112OutputStream4growEm = Module["__ZN12_GLOBAL__N_112OutputStream4growEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_112OutputStream4growEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_112OutputStream5resetEPcm = Module["__ZN12_GLOBAL__N_112OutputStream5resetEPcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_112OutputStream5resetEPcm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_112OutputStream9getBufferEv = Module["__ZN12_GLOBAL__N_112OutputStream9getBufferEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_112OutputStream9getBufferEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_112OutputStreamC2Ev = Module["__ZN12_GLOBAL__N_112OutputStreamC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_112OutputStreamC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_112OutputStreampLENS_10StringViewE = Module["__ZN12_GLOBAL__N_112OutputStreampLENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_112OutputStreampLENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_112OutputStreampLEc = Module["__ZN12_GLOBAL__N_112OutputStreampLEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_112OutputStreampLEc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_113fallback_freeEPv = Module["__ZN12_GLOBAL__N_113fallback_freeEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_113fallback_freeEPv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114SwapAndRestoreIPKcEC2ERS2_S2_ = Module["__ZN12_GLOBAL__N_114SwapAndRestoreIPKcEC2ERS2_S2_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114SwapAndRestoreIPKcEC2ERS2_S2_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114SwapAndRestoreIPKcED2Ev = Module["__ZN12_GLOBAL__N_114SwapAndRestoreIPKcED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114SwapAndRestoreIPKcED2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114SwapAndRestoreIbEC2ERbb = Module["__ZN12_GLOBAL__N_114SwapAndRestoreIbEC2ERbb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114SwapAndRestoreIbEC2ERbb"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114SwapAndRestoreIbED2Ev = Module["__ZN12_GLOBAL__N_114SwapAndRestoreIbED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114SwapAndRestoreIbED2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114SwapAndRestoreIjEC2ERjj = Module["__ZN12_GLOBAL__N_114SwapAndRestoreIjEC2ERjj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114SwapAndRestoreIjEC2ERjj"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114SwapAndRestoreIjED2Ev = Module["__ZN12_GLOBAL__N_114SwapAndRestoreIjED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114SwapAndRestoreIjED2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114register_floatIdEEvPKc = Module["__ZN12_GLOBAL__N_114register_floatIdEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114register_floatIdEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_114register_floatIfEEvPKc = Module["__ZN12_GLOBAL__N_114register_floatIfEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_114register_floatIfEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_115is_fallback_ptrEPv = Module["__ZN12_GLOBAL__N_115is_fallback_ptrEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_115is_fallback_ptrEPv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator17allocateNodeArrayEm = Module["__ZN12_GLOBAL__N_116DefaultAllocator17allocateNodeArrayEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator17allocateNodeArrayEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10AbiTagAttrEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10AbiTagAttrEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10AbiTagAttrEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10BinaryExprEJRPNS2_4NodeERNS_10StringViewES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10BinaryExprEJRPNS2_4NodeERNS_10StringViewES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10BinaryExprEJRPNS2_4NodeERNS_10StringViewES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10BracedExprEJRPNS2_4NodeES6_bEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10BracedExprEJRPNS2_4NodeES6_bEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10BracedExprEJRPNS2_4NodeES6_bEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10DeleteExprEJRPNS2_4NodeERbbEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10DeleteExprEJRPNS2_4NodeERbbEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10DeleteExprEJRPNS2_4NodeERbbEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10MemberExprEJRPNS2_4NodeERA2_KcS6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10MemberExprEJRPNS2_4NodeERA2_KcS6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10MemberExprEJRPNS2_4NodeERA2_KcS6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10MemberExprEJRPNS2_4NodeERA3_KcS6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10MemberExprEJRPNS2_4NodeERA3_KcS6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10MemberExprEJRPNS2_4NodeERA3_KcS6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10NestedNameEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10NestedNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10NestedNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10PrefixExprEJRNS_10StringViewERPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10PrefixExprEJRNS_10StringViewERPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10PrefixExprEJRNS_10StringViewERPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeENS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeENS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeENS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle10VectorTypeEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11PointerTypeEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11PointerTypeEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11PointerTypeEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11PostfixExprEJRPNS2_4NodeERA3_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11PostfixExprEJRPNS2_4NodeERA3_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11PostfixExprEJRPNS2_4NodeERA3_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA12_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA12_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA12_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA14_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA14_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA14_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA18_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA18_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA18_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA19_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA19_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA19_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA20_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA20_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA20_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA22_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA22_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA22_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA25_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA25_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA25_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA27_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA27_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA27_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA34_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA34_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA34_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA41_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA41_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA41_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA9_KcRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA9_KcRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle11SpecialNameEJRA9_KcRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12CtorDtorNameEJRPNS2_4NodeEbRiEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12CtorDtorNameEJRPNS2_4NodeEbRiEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12CtorDtorNameEJRPNS2_4NodeEbRiEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12EnableIfAttrEJNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12EnableIfAttrEJNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12EnableIfAttrEJNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12FunctionTypeEJRPNS2_4NodeERNS2_9NodeArrayERNS2_10QualifiersERNS2_15FunctionRefQualES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12FunctionTypeEJRPNS2_4NodeERNS2_9NodeArrayERNS2_10QualifiersERNS2_15FunctionRefQualES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12FunctionTypeEJRPNS2_4NodeERNS2_9NodeArrayERNS2_10QualifiersERNS2_15FunctionRefQualES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12InitListExprEJDnNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12InitListExprEJDnNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12InitListExprEJDnNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12InitListExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12InitListExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12InitListExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12NoexceptSpecEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12NoexceptSpecEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12NoexceptSpecEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12TemplateArgsEJNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12TemplateArgsEJNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle12TemplateArgsEJNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA10_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA10_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA10_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA11_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA11_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA11_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA12_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA12_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA12_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA9_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA9_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13EnclosingExprEJRA9_KcRPNS2_4NodeERA2_S4_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13FunctionParamEJRNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13FunctionParamEJRNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13FunctionParamEJRNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13NodeArrayNodeEJNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13NodeArrayNodeEJNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13NodeArrayNodeEJNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ObjCProtoNameEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ObjCProtoNameEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ObjCProtoNameEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ParameterPackEJNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ParameterPackEJNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ParameterPackEJNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13QualifiedNameEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13QualifiedNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13QualifiedNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ReferenceTypeEJRPNS2_4NodeENS2_13ReferenceKindEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ReferenceTypeEJRPNS2_4NodeENS2_13ReferenceKindEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle13ReferenceTypeEJRPNS2_4NodeENS2_13ReferenceKindEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14ConversionExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14ConversionExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14ConversionExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14ConversionExprEJRPNS2_4NodeERNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14ConversionExprEJRPNS2_4NodeERNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14ConversionExprEJRPNS2_4NodeERNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14IntegerLiteralEJRNS_10StringViewES5_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14IntegerLiteralEJRNS_10StringViewES5_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle14IntegerLiteralEJRNS_10StringViewES5_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15BracedRangeExprEJRPNS2_4NodeES6_S6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15BracedRangeExprEJRPNS2_4NodeES6_S6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15BracedRangeExprEJRPNS2_4NodeES6_S6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15ClosureTypeNameEJRNS2_9NodeArrayERNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15ClosureTypeNameEJRNS2_9NodeArrayERNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15ClosureTypeNameEJRNS2_9NodeArrayERNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15ConditionalExprEJRPNS2_4NodeES6_S6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15ConditionalExprEJRPNS2_4NodeES6_S6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15ConditionalExprEJRPNS2_4NodeES6_S6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15IntegerCastExprEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15IntegerCastExprEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15IntegerCastExprEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15LiteralOperatorEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15LiteralOperatorEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15LiteralOperatorEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15PixelVectorTypeEJRNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15PixelVectorTypeEJRNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15PixelVectorTypeEJRNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15UnnamedTypeNameEJRNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15UnnamedTypeNameEJRNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle15UnnamedTypeNameEJRNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIdEEJRNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIdEEJRNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIdEEJRNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIeEEJRNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIeEEJRNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIeEEJRNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIfEEJRNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIfEEJRNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FloatLiteralImplIfEEJRNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FunctionEncodingEJRPNS2_4NodeES6_NS2_9NodeArrayES6_RNS2_10QualifiersERNS2_15FunctionRefQualEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FunctionEncodingEJRPNS2_4NodeES6_NS2_9NodeArrayES6_RNS2_10QualifiersERNS2_15FunctionRefQualEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16FunctionEncodingEJRPNS2_4NodeES6_NS2_9NodeArrayES6_RNS2_10QualifiersERNS2_15FunctionRefQualEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16StdQualifiedNameEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16StdQualifiedNameEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle16StdQualifiedNameEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle17VendorExtQualTypeEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle17VendorExtQualTypeEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle17VendorExtQualTypeEJRPNS2_4NodeERNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle18ArraySubscriptExprEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle18ArraySubscriptExprEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle18ArraySubscriptExprEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19GlobalQualifiedNameEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19GlobalQualifiedNameEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19GlobalQualifiedNameEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19PointerToMemberTypeEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19PointerToMemberTypeEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19PointerToMemberTypeEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19SizeofParamPackExprEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19SizeofParamPackExprEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19SizeofParamPackExprEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19SpecialSubstitutionEJNS2_14SpecialSubKindEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19SpecialSubstitutionEJNS2_14SpecialSubKindEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle19SpecialSubstitutionEJNS2_14SpecialSubKindEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20DynamicExceptionSpecEJNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20DynamicExceptionSpecEJNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20DynamicExceptionSpecEJNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20NameWithTemplateArgsEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20NameWithTemplateArgsEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20NameWithTemplateArgsEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20PostfixQualifiedTypeEJRPNS2_4NodeERA11_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20PostfixQualifiedTypeEJRPNS2_4NodeERA11_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20PostfixQualifiedTypeEJRPNS2_4NodeERA11_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20PostfixQualifiedTypeEJRPNS2_4NodeERA9_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20PostfixQualifiedTypeEJRPNS2_4NodeERA9_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20PostfixQualifiedTypeEJRPNS2_4NodeERA9_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20TemplateArgumentPackEJRNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20TemplateArgumentPackEJRNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle20TemplateArgumentPackEJRNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle21CtorVtableSpecialNameEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle21CtorVtableSpecialNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle21CtorVtableSpecialNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle21StructuredBindingNameEJNS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle21StructuredBindingNameEJNS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle21StructuredBindingNameEJNS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ConversionOperatorTypeEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ConversionOperatorTypeEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ConversionOperatorTypeEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ElaboratedTypeSpefTypeEJRNS_10StringViewERPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ElaboratedTypeSpefTypeEJRNS_10StringViewERPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ElaboratedTypeSpefTypeEJRNS_10StringViewERPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ParameterPackExpansionEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ParameterPackExpansionEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle22ParameterPackExpansionEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle24ForwardTemplateReferenceEJRmEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle24ForwardTemplateReferenceEJRmEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle24ForwardTemplateReferenceEJRmEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle27ExpandedSpecialSubstitutionEJRNS2_14SpecialSubKindEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle27ExpandedSpecialSubstitutionEJRNS2_14SpecialSubKindEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle27ExpandedSpecialSubstitutionEJRNS2_14SpecialSubKindEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle7NewExprEJRNS2_9NodeArrayERPNS2_4NodeES4_RbS9_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle7NewExprEJRNS2_9NodeArrayERPNS2_4NodeES4_RbS9_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle7NewExprEJRNS2_9NodeArrayERPNS2_4NodeES4_RbS9_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle7NewExprEJRNS2_9NodeArrayERPNS2_4NodeES5_RbS9_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle7NewExprEJRNS2_9NodeArrayERPNS2_4NodeES5_RbS9_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle7NewExprEJRNS2_9NodeArrayERPNS2_4NodeES5_RbS9_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8BoolExprEJiEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8BoolExprEJiEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8BoolExprEJiEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CallExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CallExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CallExprEJRPNS2_4NodeENS2_9NodeArrayEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA11_KcRPNS2_4NodeES9_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA11_KcRPNS2_4NodeES9_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA11_KcRPNS2_4NodeES9_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA12_KcRPNS2_4NodeES9_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA12_KcRPNS2_4NodeES9_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA12_KcRPNS2_4NodeES9_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA13_KcRPNS2_4NodeES9_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA13_KcRPNS2_4NodeES9_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA13_KcRPNS2_4NodeES9_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA17_KcRPNS2_4NodeES9_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA17_KcRPNS2_4NodeES9_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8CastExprEJRA17_KcRPNS2_4NodeES9_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8DtorNameEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8DtorNameEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8DtorNameEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8FoldExprEJRbRNS_10StringViewERPNS2_4NodeES9_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8FoldExprEJRbRNS_10StringViewERPNS2_4NodeES9_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8FoldExprEJRbRNS_10StringViewERPNS2_4NodeES9_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA10_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA10_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA10_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA11_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA11_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA11_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA12_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA12_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA12_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA13_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA13_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA13_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA14_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA14_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA14_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA15_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA15_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA15_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA16_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA16_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA16_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA18_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA18_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA18_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA19_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA19_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA19_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA22_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA22_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA22_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA4_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA4_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA4_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA5_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA5_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA5_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA6_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA6_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA6_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA7_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA7_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA7_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA8_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA8_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA8_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA9_KcEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA9_KcEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRA9_KcEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRNS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRNS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8NameTypeEJRNS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8QualTypeEJRPNS2_4NodeERNS2_10QualifiersEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8QualTypeEJRPNS2_4NodeERNS2_10QualifiersEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle8QualTypeEJRPNS2_4NodeERNS2_10QualifiersEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9ArrayTypeEJRPNS2_4NodeERNS2_12NodeOrStringEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9ArrayTypeEJRPNS2_4NodeERNS2_12NodeOrStringEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9ArrayTypeEJRPNS2_4NodeERNS2_12NodeOrStringEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9DotSuffixEJRPNS2_4NodeENS_10StringViewEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9DotSuffixEJRPNS2_4NodeENS_10StringViewEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9DotSuffixEJRPNS2_4NodeENS_10StringViewEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9LocalNameEJRPNS2_4NodeES6_EEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9LocalNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9LocalNameEJRPNS2_4NodeES6_EEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9ThrowExprEJRPNS2_4NodeEEEEPT_DpOT0_ = Module["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9ThrowExprEJRPNS2_4NodeEEEEPT_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocator8makeNodeINS_16itanium_demangle9ThrowExprEJRPNS2_4NodeEEEEPT_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocatorC2Ev = Module["__ZN12_GLOBAL__N_116DefaultAllocatorC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocatorC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116DefaultAllocatorD2Ev = Module["__ZN12_GLOBAL__N_116DefaultAllocatorD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116DefaultAllocatorD2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10AbiTagAttrC2EPNS0_4NodeENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle10AbiTagAttrC2EPNS0_4NodeENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10AbiTagAttrC2EPNS0_4NodeENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10AbiTagAttrD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10AbiTagAttrD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10AbiTagAttrD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10BinaryExprC2EPKNS0_4NodeENS_10StringViewES4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle10BinaryExprC2EPKNS0_4NodeENS_10StringViewES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10BinaryExprC2EPKNS0_4NodeENS_10StringViewES4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10BinaryExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10BinaryExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10BinaryExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10BracedExprC2EPKNS0_4NodeES4_b = Module["__ZN12_GLOBAL__N_116itanium_demangle10BracedExprC2EPKNS0_4NodeES4_b"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10BracedExprC2EPKNS0_4NodeES4_b"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10BracedExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10BracedExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10BracedExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10DeleteExprC2EPNS0_4NodeEbb = Module["__ZN12_GLOBAL__N_116itanium_demangle10DeleteExprC2EPNS0_4NodeEbb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10DeleteExprC2EPNS0_4NodeEbb"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10DeleteExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10DeleteExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10DeleteExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10MemberExprC2EPKNS0_4NodeENS_10StringViewES4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle10MemberExprC2EPKNS0_4NodeENS_10StringViewES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10MemberExprC2EPKNS0_4NodeENS_10StringViewES4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10MemberExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10MemberExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10MemberExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10NestedNameC2EPNS0_4NodeES3_ = Module["__ZN12_GLOBAL__N_116itanium_demangle10NestedNameC2EPNS0_4NodeES3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10NestedNameC2EPNS0_4NodeES3_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10NestedNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10NestedNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10NestedNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10PrefixExprC2ENS_10StringViewEPNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle10PrefixExprC2ENS_10StringViewEPNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10PrefixExprC2ENS_10StringViewEPNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10PrefixExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10PrefixExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10PrefixExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10VectorTypeC2EPKNS0_4NodeENS0_12NodeOrStringE = Module["__ZN12_GLOBAL__N_116itanium_demangle10VectorTypeC2EPKNS0_4NodeENS0_12NodeOrStringE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10VectorTypeC2EPKNS0_4NodeENS0_12NodeOrStringE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle10VectorTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle10VectorTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle10VectorTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle11PointerTypeC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle11PointerTypeC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle11PointerTypeC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle11PointerTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle11PointerTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle11PointerTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle11PostfixExprC2EPKNS0_4NodeENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle11PostfixExprC2EPKNS0_4NodeENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle11PostfixExprC2EPKNS0_4NodeENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle11PostfixExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle11PostfixExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle11PostfixExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle11SpecialNameC2ENS_10StringViewEPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle11SpecialNameC2ENS_10StringViewEPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle11SpecialNameC2ENS_10StringViewEPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle11SpecialNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle11SpecialNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle11SpecialNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12CtorDtorNameC2EPKNS0_4NodeEbi = Module["__ZN12_GLOBAL__N_116itanium_demangle12CtorDtorNameC2EPKNS0_4NodeEbi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12CtorDtorNameC2EPKNS0_4NodeEbi"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12CtorDtorNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle12CtorDtorNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12CtorDtorNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12EnableIfAttrC2ENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle12EnableIfAttrC2ENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12EnableIfAttrC2ENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12EnableIfAttrD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle12EnableIfAttrD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12EnableIfAttrD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12FunctionTypeC2EPKNS0_4NodeENS0_9NodeArrayENS0_10QualifiersENS0_15FunctionRefQualES4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle12FunctionTypeC2EPKNS0_4NodeENS0_9NodeArrayENS0_10QualifiersENS0_15FunctionRefQualES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12FunctionTypeC2EPKNS0_4NodeENS0_9NodeArrayENS0_10QualifiersENS0_15FunctionRefQualES4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12FunctionTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle12FunctionTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12FunctionTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12InitListExprC2EPKNS0_4NodeENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle12InitListExprC2EPKNS0_4NodeENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12InitListExprC2EPKNS0_4NodeENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12InitListExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle12InitListExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12InitListExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2ENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2ENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2ENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2EPNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2EPNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2EPNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12NodeOrStringC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12NoexceptSpecC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle12NoexceptSpecC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12NoexceptSpecC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12NoexceptSpecD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle12NoexceptSpecD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12NoexceptSpecD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12TemplateArgsC2ENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle12TemplateArgsC2ENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12TemplateArgsC2ENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle12TemplateArgsD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle12TemplateArgsD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle12TemplateArgsD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13EnclosingExprC2ENS_10StringViewEPNS0_4NodeES2_ = Module["__ZN12_GLOBAL__N_116itanium_demangle13EnclosingExprC2ENS_10StringViewEPNS0_4NodeES2_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13EnclosingExprC2ENS_10StringViewEPNS0_4NodeES2_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13EnclosingExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle13EnclosingExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13EnclosingExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13FunctionParamC2ENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle13FunctionParamC2ENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13FunctionParamC2ENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13FunctionParamD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle13FunctionParamD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13FunctionParamD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13NodeArrayNodeC2ENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle13NodeArrayNodeC2ENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13NodeArrayNodeC2ENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13NodeArrayNodeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle13NodeArrayNodeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13NodeArrayNodeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13ObjCProtoNameC2EPKNS0_4NodeENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle13ObjCProtoNameC2EPKNS0_4NodeENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13ObjCProtoNameC2EPKNS0_4NodeENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13ObjCProtoNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle13ObjCProtoNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13ObjCProtoNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13ParameterPackC2ENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle13ParameterPackC2ENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13ParameterPackC2ENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13ParameterPackD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle13ParameterPackD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13ParameterPackD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13QualifiedNameC2EPKNS0_4NodeES4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle13QualifiedNameC2EPKNS0_4NodeES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13QualifiedNameC2EPKNS0_4NodeES4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13QualifiedNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle13QualifiedNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13QualifiedNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13ReferenceTypeC2EPKNS0_4NodeENS0_13ReferenceKindE = Module["__ZN12_GLOBAL__N_116itanium_demangle13ReferenceTypeC2EPKNS0_4NodeENS0_13ReferenceKindE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13ReferenceTypeC2EPKNS0_4NodeENS0_13ReferenceKindE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle13ReferenceTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle13ReferenceTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle13ReferenceTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14ConversionExprC2EPKNS0_4NodeENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle14ConversionExprC2EPKNS0_4NodeENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14ConversionExprC2EPKNS0_4NodeENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14ConversionExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14ConversionExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14ConversionExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14IntegerLiteralC2ENS_10StringViewES2_ = Module["__ZN12_GLOBAL__N_116itanium_demangle14IntegerLiteralC2ENS_10StringViewES2_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14IntegerLiteralC2ENS_10StringViewES2_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14IntegerLiteralD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14IntegerLiteralD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14IntegerLiteralD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14ManglingParserINS_16DefaultAllocatorEECI2NS0_22AbstractManglingParserIS3_S2_EEEPKcS6_ = Module["__ZN12_GLOBAL__N_116itanium_demangle14ManglingParserINS_16DefaultAllocatorEECI2NS0_22AbstractManglingParserIS3_S2_EEEPKcS6_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14ManglingParserINS_16DefaultAllocatorEECI2NS0_22AbstractManglingParserIS3_S2_EEEPKcS6_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE5beginEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE5beginEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE5beginEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE7reserveEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE7reserveEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE7reserveEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE8dropBackEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE8dropBackEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE8dropBackEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE9push_backERKS3_ = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE9push_backERKS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE9push_backERKS3_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EEC2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EEC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EEC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EED2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EED2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EEixEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EEixEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EEixEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE3endEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE3endEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE3endEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE5beginEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE5beginEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE5beginEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE7reserveEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE7reserveEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE7reserveEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8dropBackEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8dropBackEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8dropBackEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8pop_backEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8pop_backEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8pop_backEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE9push_backERKS3_ = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE9push_backERKS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE9push_backERKS3_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EEC2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EEC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EEC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EED2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EED2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EEixEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EEixEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EEixEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE11clearInlineEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE11clearInlineEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE11clearInlineEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE3endEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE3endEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE3endEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE5beginEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE5beginEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE5beginEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE5clearEv = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE5clearEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE5clearEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE7reserveEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE7reserveEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE7reserveEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE9push_backERKS3_ = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE9push_backERKS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE9push_backERKS3_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEC2EOS4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEC2EOS4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEC2EOS4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEC2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EED2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EED2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEaSEOS4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEaSEOS4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEaSEOS4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEixEm = Module["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEixEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EEixEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15BracedRangeExprC2EPKNS0_4NodeES4_S4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle15BracedRangeExprC2EPKNS0_4NodeES4_S4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15BracedRangeExprC2EPKNS0_4NodeES4_S4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15BracedRangeExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle15BracedRangeExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15BracedRangeExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15ClosureTypeNameC2ENS0_9NodeArrayENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle15ClosureTypeNameC2ENS0_9NodeArrayENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15ClosureTypeNameC2ENS0_9NodeArrayENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15ClosureTypeNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle15ClosureTypeNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15ClosureTypeNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15ConditionalExprC2EPKNS0_4NodeES4_S4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle15ConditionalExprC2EPKNS0_4NodeES4_S4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15ConditionalExprC2EPKNS0_4NodeES4_S4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15ConditionalExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle15ConditionalExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15ConditionalExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15IntegerCastExprC2EPKNS0_4NodeENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle15IntegerCastExprC2EPKNS0_4NodeENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15IntegerCastExprC2EPKNS0_4NodeENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15IntegerCastExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle15IntegerCastExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15IntegerCastExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15LiteralOperatorC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle15LiteralOperatorC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15LiteralOperatorC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15LiteralOperatorD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle15LiteralOperatorD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15LiteralOperatorD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15PixelVectorTypeC2ENS0_12NodeOrStringE = Module["__ZN12_GLOBAL__N_116itanium_demangle15PixelVectorTypeC2ENS0_12NodeOrStringE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15PixelVectorTypeC2ENS0_12NodeOrStringE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15PixelVectorTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle15PixelVectorTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15PixelVectorTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15UnnamedTypeNameC2ENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle15UnnamedTypeNameC2ENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15UnnamedTypeNameC2ENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle15UnnamedTypeNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle15UnnamedTypeNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle15UnnamedTypeNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdEC2ENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdEC2ENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdEC2ENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdED0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdED0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeEC2ENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeEC2ENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeEC2ENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeED0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeED0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfEC2ENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfEC2ENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfEC2ENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfED0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfED0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FunctionEncodingC2EPKNS0_4NodeES4_NS0_9NodeArrayES4_NS0_10QualifiersENS0_15FunctionRefQualE = Module["__ZN12_GLOBAL__N_116itanium_demangle16FunctionEncodingC2EPKNS0_4NodeES4_NS0_9NodeArrayES4_NS0_10QualifiersENS0_15FunctionRefQualE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FunctionEncodingC2EPKNS0_4NodeES4_NS0_9NodeArrayES4_NS0_10QualifiersENS0_15FunctionRefQualE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16FunctionEncodingD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle16FunctionEncodingD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16FunctionEncodingD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16StdQualifiedNameC2EPNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle16StdQualifiedNameC2EPNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16StdQualifiedNameC2EPNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle16StdQualifiedNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle16StdQualifiedNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle16StdQualifiedNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle17VendorExtQualTypeC2EPKNS0_4NodeENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle17VendorExtQualTypeC2EPKNS0_4NodeENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle17VendorExtQualTypeC2EPKNS0_4NodeENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle17VendorExtQualTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle17VendorExtQualTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle17VendorExtQualTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle18ArraySubscriptExprC2EPKNS0_4NodeES4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle18ArraySubscriptExprC2EPKNS0_4NodeES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle18ArraySubscriptExprC2EPKNS0_4NodeES4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle18ArraySubscriptExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle18ArraySubscriptExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle18ArraySubscriptExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19GlobalQualifiedNameC2EPNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle19GlobalQualifiedNameC2EPNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19GlobalQualifiedNameC2EPNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19GlobalQualifiedNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle19GlobalQualifiedNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19GlobalQualifiedNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19PointerToMemberTypeC2EPKNS0_4NodeES4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle19PointerToMemberTypeC2EPKNS0_4NodeES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19PointerToMemberTypeC2EPKNS0_4NodeES4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19PointerToMemberTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle19PointerToMemberTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19PointerToMemberTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19SizeofParamPackExprC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle19SizeofParamPackExprC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19SizeofParamPackExprC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19SizeofParamPackExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle19SizeofParamPackExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19SizeofParamPackExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19SpecialSubstitutionC2ENS0_14SpecialSubKindE = Module["__ZN12_GLOBAL__N_116itanium_demangle19SpecialSubstitutionC2ENS0_14SpecialSubKindE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19SpecialSubstitutionC2ENS0_14SpecialSubKindE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19SpecialSubstitutionD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle19SpecialSubstitutionD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19SpecialSubstitutionD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle19parse_discriminatorEPKcS2_ = Module["__ZN12_GLOBAL__N_116itanium_demangle19parse_discriminatorEPKcS2_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle19parse_discriminatorEPKcS2_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpecC2ENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpecC2ENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpecC2ENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpecD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpecD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpecD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgsC2EPNS0_4NodeES3_ = Module["__ZN12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgsC2EPNS0_4NodeES3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgsC2EPNS0_4NodeES3_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgsD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgsD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgsD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20PostfixQualifiedTypeC2EPNS0_4NodeENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle20PostfixQualifiedTypeC2EPNS0_4NodeENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20PostfixQualifiedTypeC2EPNS0_4NodeENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20PostfixQualifiedTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle20PostfixQualifiedTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20PostfixQualifiedTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20TemplateArgumentPackC2ENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle20TemplateArgumentPackC2ENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20TemplateArgumentPackC2ENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle20TemplateArgumentPackD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle20TemplateArgumentPackD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle20TemplateArgumentPackD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialNameC2EPKNS0_4NodeES4_ = Module["__ZN12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialNameC2EPKNS0_4NodeES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialNameC2EPKNS0_4NodeES4_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle21StructuredBindingNameC2ENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle21StructuredBindingNameC2ENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle21StructuredBindingNameC2ENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle21StructuredBindingNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle21StructuredBindingNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle21StructuredBindingNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E10getDerivedEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E10getDerivedEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E10getDerivedEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E10parseSeqIdEPm = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E10parseSeqIdEPm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E10parseSeqIdEPm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E11parseNumberEb = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E11parseNumberEb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E11parseNumberEb"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E12parseAbiTagsEPNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E12parseAbiTagsEPNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E12parseAbiTagsEPNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E12parseNewExprEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E12parseNewExprEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E12parseNewExprEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13makeNodeArrayIPPNS0_4NodeEEENS0_9NodeArrayET_SB_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13makeNodeArrayIPPNS0_4NodeEEENS0_9NodeArrayET_SB_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13makeNodeArrayIPPNS0_4NodeEEENS0_9NodeArrayET_SB_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseDecltypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseDecltypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseDecltypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseEncodingEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseEncodingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseEncodingEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseFoldExprEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseFoldExprEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseFoldExprEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseSimpleIdEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseSimpleIdEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseSimpleIdEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E14parseArrayTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E14parseArrayTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E14parseArrayTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E14parseLocalNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E14parseLocalNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E14parseLocalNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseBinaryExprENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseBinaryExprENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseBinaryExprENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseBracedExprEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseBracedExprEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseBracedExprEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseCallOffsetEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseCallOffsetEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseCallOffsetEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseNestedNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseNestedNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseNestedNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parsePrefixExprENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parsePrefixExprENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parsePrefixExprENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseSourceNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseSourceNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseSourceNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseVectorTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseVectorTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseVectorTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseExprPrimaryEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseExprPrimaryEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseExprPrimaryEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseSpecialNameEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseSpecialNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseSpecialNameEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseTemplateArgEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseTemplateArgEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E16parseTemplateArgEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseCVQualifiersEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseCVQualifiersEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseCVQualifiersEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseCtorDtorNameERPNS0_4NodeEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseCtorDtorNameERPNS0_4NodeEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseCtorDtorNameERPNS0_4NodeEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseFunctionTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseFunctionTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseFunctionTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseOperatorNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseOperatorNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseOperatorNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseSubstitutionEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseSubstitutionEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseSubstitutionEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseTemplateArgsEb = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseTemplateArgsEb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseTemplateArgsEb"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseUnscopedNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseUnscopedNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E17parseUnscopedNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseClassEnumTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseClassEnumTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseClassEnumTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseFunctionParamEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseFunctionParamEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseFunctionParamEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseQualifiedTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseQualifiedTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseQualifiedTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseTemplateParamEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseTemplateParamEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E18parseTemplateParamEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseBareSourceNameEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseBareSourceNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseBareSourceNameEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseConversionExprEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseConversionExprEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseConversionExprEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseDestructorNameEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseDestructorNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseDestructorNameEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseIntegerLiteralENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseIntegerLiteralENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseIntegerLiteralENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseUnresolvedNameEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseUnresolvedNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseUnresolvedNameEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseUnresolvedTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseUnresolvedTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E19parseUnresolvedTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIdEEPNS0_4NodeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIdEEPNS0_4NodeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIdEEPNS0_4NodeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIeEEPNS0_4NodeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIeEEPNS0_4NodeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIeEEPNS0_4NodeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIfEEPNS0_4NodeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIfEEPNS0_4NodeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseFloatingLiteralIfEEPNS0_4NodeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parsePositiveIntegerEPm = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parsePositiveIntegerEPm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parsePositiveIntegerEPm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseUnnamedTypeNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseUnnamedTypeNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseUnnamedTypeNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseUnqualifiedNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseUnqualifiedNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20parseUnqualifiedNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20popTrailingNodeArrayEm = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20popTrailingNodeArrayEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E20popTrailingNodeArrayEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E23parseBaseUnresolvedNameEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E23parseBaseUnresolvedNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E23parseBaseUnresolvedNameEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E24parsePointerToMemberTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E24parsePointerToMemberTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E24parsePointerToMemberTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E26resolveForwardTemplateRefsERNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E26resolveForwardTemplateRefsERNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E26resolveForwardTemplateRefsERNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4lookEj = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4lookEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4lookEj"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10AbiTagAttrEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10AbiTagAttrEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10AbiTagAttrEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10BinaryExprEJRPNS0_4NodeERNS_10StringViewESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10BinaryExprEJRPNS0_4NodeERNS_10StringViewESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10BinaryExprEJRPNS0_4NodeERNS_10StringViewESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10BracedExprEJRPNS0_4NodeESA_bEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10BracedExprEJRPNS0_4NodeESA_bEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10BracedExprEJRPNS0_4NodeESA_bEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10DeleteExprEJRPNS0_4NodeERbbEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10DeleteExprEJRPNS0_4NodeERbbEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10DeleteExprEJRPNS0_4NodeERbbEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10MemberExprEJRPNS0_4NodeERA2_KcSA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10MemberExprEJRPNS0_4NodeERA2_KcSA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10MemberExprEJRPNS0_4NodeERA2_KcSA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10MemberExprEJRPNS0_4NodeERA3_KcSA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10MemberExprEJRPNS0_4NodeERA3_KcSA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10MemberExprEJRPNS0_4NodeERA3_KcSA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10NestedNameEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10NestedNameEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10NestedNameEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10PrefixExprEJRNS_10StringViewERPNS0_4NodeEEEESB_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10PrefixExprEJRNS_10StringViewERPNS0_4NodeEEEESB_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10PrefixExprEJRNS_10StringViewERPNS0_4NodeEEEESB_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeENS_10StringViewEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeENS_10StringViewEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeENS_10StringViewEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_10VectorTypeEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11PointerTypeEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11PointerTypeEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11PointerTypeEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11PostfixExprEJRPNS0_4NodeERA3_KcEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11PostfixExprEJRPNS0_4NodeERA3_KcEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11PostfixExprEJRPNS0_4NodeERA3_KcEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA12_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA12_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA12_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA14_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA14_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA14_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA18_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA18_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA18_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA19_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA19_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA19_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA20_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA20_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA20_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA22_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA22_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA22_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA25_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA25_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA25_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA27_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA27_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA27_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA34_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA34_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA34_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA41_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA41_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA41_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA9_KcRPNS0_4NodeEEEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA9_KcRPNS0_4NodeEEEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_11SpecialNameEJRA9_KcRPNS0_4NodeEEEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12CtorDtorNameEJRPNS0_4NodeEbRiEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12CtorDtorNameEJRPNS0_4NodeEbRiEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12CtorDtorNameEJRPNS0_4NodeEbRiEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12EnableIfAttrEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12EnableIfAttrEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12EnableIfAttrEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12FunctionTypeEJRPNS0_4NodeERNS0_9NodeArrayERNS0_10QualifiersERNS0_15FunctionRefQualESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12FunctionTypeEJRPNS0_4NodeERNS0_9NodeArrayERNS0_10QualifiersERNS0_15FunctionRefQualESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12FunctionTypeEJRPNS0_4NodeERNS0_9NodeArrayERNS0_10QualifiersERNS0_15FunctionRefQualESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12InitListExprEJDnNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12InitListExprEJDnNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12InitListExprEJDnNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12InitListExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12InitListExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12InitListExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12NoexceptSpecEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12NoexceptSpecEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12NoexceptSpecEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12TemplateArgsEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12TemplateArgsEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_12TemplateArgsEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA10_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA10_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA10_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA11_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA11_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA11_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA12_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA12_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA12_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA9_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA9_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13EnclosingExprEJRA9_KcRPNS0_4NodeERA2_S8_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13FunctionParamEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13FunctionParamEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13FunctionParamEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13NodeArrayNodeEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13NodeArrayNodeEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13NodeArrayNodeEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ObjCProtoNameEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ObjCProtoNameEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ObjCProtoNameEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ParameterPackEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ParameterPackEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ParameterPackEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13QualifiedNameEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13QualifiedNameEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13QualifiedNameEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ReferenceTypeEJRPNS0_4NodeENS0_13ReferenceKindEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ReferenceTypeEJRPNS0_4NodeENS0_13ReferenceKindEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_13ReferenceTypeEJRPNS0_4NodeENS0_13ReferenceKindEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14ConversionExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14ConversionExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14ConversionExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14ConversionExprEJRPNS0_4NodeERNS0_9NodeArrayEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14ConversionExprEJRPNS0_4NodeERNS0_9NodeArrayEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14ConversionExprEJRPNS0_4NodeERNS0_9NodeArrayEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14IntegerLiteralEJRNS_10StringViewES9_EEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14IntegerLiteralEJRNS_10StringViewES9_EEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_14IntegerLiteralEJRNS_10StringViewES9_EEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15BracedRangeExprEJRPNS0_4NodeESA_SA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15BracedRangeExprEJRPNS0_4NodeESA_SA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15BracedRangeExprEJRPNS0_4NodeESA_SA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15ClosureTypeNameEJRNS0_9NodeArrayERNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15ClosureTypeNameEJRNS0_9NodeArrayERNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15ClosureTypeNameEJRNS0_9NodeArrayERNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15ConditionalExprEJRPNS0_4NodeESA_SA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15ConditionalExprEJRPNS0_4NodeESA_SA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15ConditionalExprEJRPNS0_4NodeESA_SA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15IntegerCastExprEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15IntegerCastExprEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15IntegerCastExprEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15LiteralOperatorEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15LiteralOperatorEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15LiteralOperatorEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15PixelVectorTypeEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15PixelVectorTypeEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15PixelVectorTypeEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15UnnamedTypeNameEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15UnnamedTypeNameEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_15UnnamedTypeNameEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIdEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIdEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIdEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIeEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIeEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIeEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIfEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIfEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FloatLiteralImplIfEEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FunctionEncodingEJRPNS0_4NodeESA_NS0_9NodeArrayESA_RNS0_10QualifiersERNS0_15FunctionRefQualEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FunctionEncodingEJRPNS0_4NodeESA_NS0_9NodeArrayESA_RNS0_10QualifiersERNS0_15FunctionRefQualEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16FunctionEncodingEJRPNS0_4NodeESA_NS0_9NodeArrayESA_RNS0_10QualifiersERNS0_15FunctionRefQualEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16StdQualifiedNameEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16StdQualifiedNameEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_16StdQualifiedNameEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_17VendorExtQualTypeEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_17VendorExtQualTypeEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_17VendorExtQualTypeEJRPNS0_4NodeERNS_10StringViewEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_18ArraySubscriptExprEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_18ArraySubscriptExprEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_18ArraySubscriptExprEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19GlobalQualifiedNameEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19GlobalQualifiedNameEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19GlobalQualifiedNameEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19PointerToMemberTypeEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19PointerToMemberTypeEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19PointerToMemberTypeEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19SizeofParamPackExprEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19SizeofParamPackExprEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19SizeofParamPackExprEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19SpecialSubstitutionEJNS0_14SpecialSubKindEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19SpecialSubstitutionEJNS0_14SpecialSubKindEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_19SpecialSubstitutionEJNS0_14SpecialSubKindEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20DynamicExceptionSpecEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20DynamicExceptionSpecEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20DynamicExceptionSpecEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20NameWithTemplateArgsEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20NameWithTemplateArgsEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20NameWithTemplateArgsEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20PostfixQualifiedTypeEJRPNS0_4NodeERA11_KcEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20PostfixQualifiedTypeEJRPNS0_4NodeERA11_KcEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20PostfixQualifiedTypeEJRPNS0_4NodeERA11_KcEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20PostfixQualifiedTypeEJRPNS0_4NodeERA9_KcEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20PostfixQualifiedTypeEJRPNS0_4NodeERA9_KcEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20PostfixQualifiedTypeEJRPNS0_4NodeERA9_KcEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20TemplateArgumentPackEJRNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20TemplateArgumentPackEJRNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_20TemplateArgumentPackEJRNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_21CtorVtableSpecialNameEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_21CtorVtableSpecialNameEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_21CtorVtableSpecialNameEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_21StructuredBindingNameEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_21StructuredBindingNameEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_21StructuredBindingNameEJNS0_9NodeArrayEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ConversionOperatorTypeEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ConversionOperatorTypeEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ConversionOperatorTypeEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ElaboratedTypeSpefTypeEJRNS_10StringViewERPNS0_4NodeEEEESB_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ElaboratedTypeSpefTypeEJRNS_10StringViewERPNS0_4NodeEEEESB_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ElaboratedTypeSpefTypeEJRNS_10StringViewERPNS0_4NodeEEEESB_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ParameterPackExpansionEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ParameterPackExpansionEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_22ParameterPackExpansionEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_24ForwardTemplateReferenceEJRmEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_24ForwardTemplateReferenceEJRmEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_24ForwardTemplateReferenceEJRmEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_27ExpandedSpecialSubstitutionEJRNS0_14SpecialSubKindEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_27ExpandedSpecialSubstitutionEJRNS0_14SpecialSubKindEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_27ExpandedSpecialSubstitutionEJRNS0_14SpecialSubKindEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_7NewExprEJRNS0_9NodeArrayERPNS0_4NodeES8_RbSD_EEESB_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_7NewExprEJRNS0_9NodeArrayERPNS0_4NodeES8_RbSD_EEESB_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_7NewExprEJRNS0_9NodeArrayERPNS0_4NodeES8_RbSD_EEESB_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_7NewExprEJRNS0_9NodeArrayERPNS0_4NodeES9_RbSD_EEESB_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_7NewExprEJRNS0_9NodeArrayERPNS0_4NodeES9_RbSD_EEESB_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_7NewExprEJRNS0_9NodeArrayERPNS0_4NodeES9_RbSD_EEESB_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8BoolExprEJiEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8BoolExprEJiEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8BoolExprEJiEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CallExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CallExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CallExprEJRPNS0_4NodeENS0_9NodeArrayEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA11_KcRPNS0_4NodeESD_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA11_KcRPNS0_4NodeESD_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA11_KcRPNS0_4NodeESD_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA12_KcRPNS0_4NodeESD_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA12_KcRPNS0_4NodeESD_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA12_KcRPNS0_4NodeESD_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA13_KcRPNS0_4NodeESD_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA13_KcRPNS0_4NodeESD_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA13_KcRPNS0_4NodeESD_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA17_KcRPNS0_4NodeESD_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA17_KcRPNS0_4NodeESD_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8CastExprEJRA17_KcRPNS0_4NodeESD_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8DtorNameEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8DtorNameEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8DtorNameEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8FoldExprEJRbRNS_10StringViewERPNS0_4NodeESD_EEESC_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8FoldExprEJRbRNS_10StringViewERPNS0_4NodeESD_EEESC_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8FoldExprEJRbRNS_10StringViewERPNS0_4NodeESD_EEESC_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA10_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA10_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA10_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA11_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA11_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA11_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA12_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA12_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA12_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA13_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA13_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA13_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA14_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA14_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA14_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA15_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA15_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA15_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA16_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA16_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA16_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA18_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA18_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA18_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA19_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA19_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA19_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA22_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA22_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA22_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA4_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA4_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA4_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA5_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA5_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA5_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA6_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA6_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA6_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA7_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA7_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA7_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA8_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA8_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA8_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA9_KcEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA9_KcEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRA9_KcEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8NameTypeEJRNS_10StringViewEEEEPNS0_4NodeEDpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8QualTypeEJRPNS0_4NodeERNS0_10QualifiersEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8QualTypeEJRPNS0_4NodeERNS0_10QualifiersEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_8QualTypeEJRPNS0_4NodeERNS0_10QualifiersEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9ArrayTypeEJRPNS0_4NodeERNS0_12NodeOrStringEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9ArrayTypeEJRPNS0_4NodeERNS0_12NodeOrStringEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9ArrayTypeEJRPNS0_4NodeERNS0_12NodeOrStringEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9DotSuffixEJRPNS0_4NodeENS_10StringViewEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9DotSuffixEJRPNS0_4NodeENS_10StringViewEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9DotSuffixEJRPNS0_4NodeENS_10StringViewEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9LocalNameEJRPNS0_4NodeESA_EEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9LocalNameEJRPNS0_4NodeESA_EEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9LocalNameEJRPNS0_4NodeESA_EEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9ThrowExprEJRPNS0_4NodeEEEES9_DpOT0_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9ThrowExprEJRPNS0_4NodeEEEES9_DpOT0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E4makeINS0_9ThrowExprEJRPNS0_4NodeEEEES9_DpOT0_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E5parseEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E5parseEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E5parseEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E7consumeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E7consumeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E7consumeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9NameStateC2EPS5_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9NameStateC2EPS5_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9NameStateC2EPS5_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9consumeIfENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9consumeIfENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9consumeIfENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9consumeIfEc = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9consumeIfEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9consumeIfEc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseExprEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseExprEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseExprEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseNameEPNS5_9NameStateE = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseNameEPNS5_9NameStateE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseNameEPNS5_9NameStateE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseTypeEv = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseTypeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E9parseTypeEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_EC2EPKcS7_ = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_EC2EPKcS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_EC2EPKcS7_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_ED2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_ED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_ED2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22ConversionOperatorTypeC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle22ConversionOperatorTypeC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22ConversionOperatorTypeC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22ConversionOperatorTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle22ConversionOperatorTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22ConversionOperatorTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefTypeC2ENS_10StringViewEPNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefTypeC2ENS_10StringViewEPNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefTypeC2ENS_10StringViewEPNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22ParameterPackExpansionC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle22ParameterPackExpansionC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22ParameterPackExpansionC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle22ParameterPackExpansionD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle22ParameterPackExpansionD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle22ParameterPackExpansionD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle24ForwardTemplateReferenceC2Em = Module["__ZN12_GLOBAL__N_116itanium_demangle24ForwardTemplateReferenceC2Em"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle24ForwardTemplateReferenceC2Em"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle24ForwardTemplateReferenceD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle24ForwardTemplateReferenceD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle24ForwardTemplateReferenceD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitutionC2ENS0_14SpecialSubKindE = Module["__ZN12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitutionC2ENS0_14SpecialSubKindE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitutionC2ENS0_14SpecialSubKindE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitutionD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitutionD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitutionD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle4NodeC2ENS1_4KindENS1_5CacheES3_S3_ = Module["__ZN12_GLOBAL__N_116itanium_demangle4NodeC2ENS1_4KindENS1_5CacheES3_S3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle4NodeC2ENS1_4KindENS1_5CacheES3_S3_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle4NodeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle4NodeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle4NodeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle4NodeD2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle4NodeD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle4NodeD2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle7NewExprC2ENS0_9NodeArrayEPNS0_4NodeES2_bb = Module["__ZN12_GLOBAL__N_116itanium_demangle7NewExprC2ENS0_9NodeArrayEPNS0_4NodeES2_bb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle7NewExprC2ENS0_9NodeArrayEPNS0_4NodeES2_bb"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle7NewExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle7NewExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle7NewExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8BoolExprC2Eb = Module["__ZN12_GLOBAL__N_116itanium_demangle8BoolExprC2Eb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8BoolExprC2Eb"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8BoolExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle8BoolExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8BoolExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8CallExprC2EPKNS0_4NodeENS0_9NodeArrayE = Module["__ZN12_GLOBAL__N_116itanium_demangle8CallExprC2EPKNS0_4NodeENS0_9NodeArrayE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8CallExprC2EPKNS0_4NodeENS0_9NodeArrayE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8CallExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle8CallExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8CallExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8CastExprC2ENS_10StringViewEPKNS0_4NodeES5_ = Module["__ZN12_GLOBAL__N_116itanium_demangle8CastExprC2ENS_10StringViewEPKNS0_4NodeES5_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8CastExprC2ENS_10StringViewEPKNS0_4NodeES5_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8CastExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle8CastExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8CastExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8DtorNameC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle8DtorNameC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8DtorNameC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8DtorNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle8DtorNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8DtorNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8FoldExprC2EbNS_10StringViewEPKNS0_4NodeES5_ = Module["__ZN12_GLOBAL__N_116itanium_demangle8FoldExprC2EbNS_10StringViewEPKNS0_4NodeES5_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8FoldExprC2EbNS_10StringViewEPKNS0_4NodeES5_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8FoldExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle8FoldExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8FoldExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8NameTypeC2ENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle8NameTypeC2ENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8NameTypeC2ENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8NameTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle8NameTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8NameTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8QualTypeC2EPKNS0_4NodeENS0_10QualifiersE = Module["__ZN12_GLOBAL__N_116itanium_demangle8QualTypeC2EPKNS0_4NodeENS0_10QualifiersE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8QualTypeC2EPKNS0_4NodeENS0_10QualifiersE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle8QualTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle8QualTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle8QualTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9ArrayTypeC2EPKNS0_4NodeENS0_12NodeOrStringE = Module["__ZN12_GLOBAL__N_116itanium_demangle9ArrayTypeC2EPKNS0_4NodeENS0_12NodeOrStringE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9ArrayTypeC2EPKNS0_4NodeENS0_12NodeOrStringE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9ArrayTypeD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle9ArrayTypeD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9ArrayTypeD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9DotSuffixC2EPKNS0_4NodeENS_10StringViewE = Module["__ZN12_GLOBAL__N_116itanium_demangle9DotSuffixC2EPKNS0_4NodeENS_10StringViewE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9DotSuffixC2EPKNS0_4NodeENS_10StringViewE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9DotSuffixD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle9DotSuffixD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9DotSuffixD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9LocalNameC2EPNS0_4NodeES3_ = Module["__ZN12_GLOBAL__N_116itanium_demangle9LocalNameC2EPNS0_4NodeES3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9LocalNameC2EPNS0_4NodeES3_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9LocalNameD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle9LocalNameD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9LocalNameD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9NodeArrayC2EPPNS0_4NodeEm = Module["__ZN12_GLOBAL__N_116itanium_demangle9NodeArrayC2EPPNS0_4NodeEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9NodeArrayC2EPPNS0_4NodeEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9NodeArrayC2Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle9NodeArrayC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9NodeArrayC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9ThrowExprC2EPKNS0_4NodeE = Module["__ZN12_GLOBAL__N_116itanium_demangle9ThrowExprC2EPKNS0_4NodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9ThrowExprC2EPKNS0_4NodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangle9ThrowExprD0Ev = Module["__ZN12_GLOBAL__N_116itanium_demangle9ThrowExprD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangle9ThrowExprD0Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116itanium_demangleoRERNS0_10QualifiersES1_ = Module["__ZN12_GLOBAL__N_116itanium_demangleoRERNS0_10QualifiersES1_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116itanium_demangleoRERNS0_10QualifiersES1_"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116node_from_offsetEt = Module["__ZN12_GLOBAL__N_116node_from_offsetEt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116node_from_offsetEt"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116offset_from_nodeEPKNS_9heap_nodeE = Module["__ZN12_GLOBAL__N_116offset_from_nodeEPKNS_9heap_nodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116offset_from_nodeEPKNS_9heap_nodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerIaEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerIaEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerIaEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerIcEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerIcEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerIcEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerIhEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerIhEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerIhEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerIiEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerIiEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerIiEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerIjEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerIjEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerIjEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerIlEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerIlEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerIlEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerImEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerImEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerImEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerIsEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerIsEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerIsEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_116register_integerItEEvPKc = Module["__ZN12_GLOBAL__N_116register_integerItEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_116register_integerItEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIaEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIaEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIaEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIcEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIcEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIcEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIdEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIdEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIdEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIeEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIeEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIeEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIfEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIfEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIfEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIhEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIhEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIhEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIiEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIiEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIiEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIjEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIjEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIjEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIlEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIlEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIlEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexImEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexImEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexImEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexIsEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexIsEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexIsEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_118getTypedArrayIndexItEENS_15TypedArrayIndexEv = Module["__ZN12_GLOBAL__N_118getTypedArrayIndexItEENS_15TypedArrayIndexEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_118getTypedArrayIndexItEENS_15TypedArrayIndexEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120BumpPointerAllocator15allocateMassiveEm = Module["__ZN12_GLOBAL__N_120BumpPointerAllocator15allocateMassiveEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120BumpPointerAllocator15allocateMassiveEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120BumpPointerAllocator4growEv = Module["__ZN12_GLOBAL__N_120BumpPointerAllocator4growEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120BumpPointerAllocator4growEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120BumpPointerAllocator5resetEv = Module["__ZN12_GLOBAL__N_120BumpPointerAllocator5resetEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120BumpPointerAllocator5resetEv"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120BumpPointerAllocator8allocateEm = Module["__ZN12_GLOBAL__N_120BumpPointerAllocator8allocateEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120BumpPointerAllocator8allocateEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120BumpPointerAllocatorC2Ev = Module["__ZN12_GLOBAL__N_120BumpPointerAllocatorC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120BumpPointerAllocatorC2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120BumpPointerAllocatorD2Ev = Module["__ZN12_GLOBAL__N_120BumpPointerAllocatorD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120BumpPointerAllocatorD2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIcEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIcEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIcEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIdEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIdEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIdEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIeEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIeEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIeEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIfEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIfEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIfEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIlEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIlEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIlEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewImEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewImEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewImEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_120register_memory_viewItEEvPKc = Module["__ZN12_GLOBAL__N_120register_memory_viewItEEvPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_120register_memory_viewItEEvPKc"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_122initializeOutputStreamEPcPmRNS_12OutputStreamEm = Module["__ZN12_GLOBAL__N_122initializeOutputStreamEPcPmRNS_12OutputStreamEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_122initializeOutputStreamEPcPmRNS_12OutputStreamEm"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_15afterEPNS_9heap_nodeE = Module["__ZN12_GLOBAL__N_15afterEPNS_9heap_nodeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_15afterEPNS_9heap_nodeE"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_17mutexorC2EP15pthread_mutex_t = Module["__ZN12_GLOBAL__N_17mutexorC2EP15pthread_mutex_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_17mutexorC2EP15pthread_mutex_t"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_17mutexorD2Ev = Module["__ZN12_GLOBAL__N_17mutexorD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_17mutexorD2Ev"].apply(null, arguments);
});
var __ZN12_GLOBAL__N_1eqERKNS_10StringViewES2_ = Module["__ZN12_GLOBAL__N_1eqERKNS_10StringViewES2_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN12_GLOBAL__N_1eqERKNS_10StringViewES2_"].apply(null, arguments);
});
var __ZN13HsCallManager14getCallSessionEj = Module["__ZN13HsCallManager14getCallSessionEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallManager14getCallSessionEj"].apply(null, arguments);
});
var __ZN13HsCallManager15setNotifyObjectEP17CallManagerNotify = Module["__ZN13HsCallManager15setNotifyObjectEP17CallManagerNotify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallManager15setNotifyObjectEP17CallManagerNotify"].apply(null, arguments);
});
var __ZN13HsCallManager16setApplicationIdEj14UserIdentity_t = Module["__ZN13HsCallManager16setApplicationIdEj14UserIdentity_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallManager16setApplicationIdEj14UserIdentity_t"].apply(null, arguments);
});
var __ZN13HsCallManager17createCallSessionE14UserIdentity_tj = Module["__ZN13HsCallManager17createCallSessionE14UserIdentity_tj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallManager17createCallSessionE14UserIdentity_tj"].apply(null, arguments);
});
var __ZN13HsCallManager17processIndicationEPv = Module["__ZN13HsCallManager17processIndicationEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallManager17processIndicationEPv"].apply(null, arguments);
});
var __ZN13HsCallManagerC2Ev = Module["__ZN13HsCallManagerC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallManagerC2Ev"].apply(null, arguments);
});
var __ZN13HsCallManagerD2Ev = Module["__ZN13HsCallManagerD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallManagerD2Ev"].apply(null, arguments);
});
var __ZN13HsCallSession10answerCallE11eCallMode_t = Module["__ZN13HsCallSession10answerCallE11eCallMode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSession10answerCallE11eCallMode_t"].apply(null, arguments);
});
var __ZN13HsCallSession10unholdCallEv = Module["__ZN13HsCallSession10unholdCallEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSession10unholdCallEv"].apply(null, arguments);
});
var __ZN13HsCallSession15setNotifyObjectEP17CallSessionNotify = Module["__ZN13HsCallSession15setNotifyObjectEP17CallSessionNotify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSession15setNotifyObjectEP17CallSessionNotify"].apply(null, arguments);
});
var __ZN13HsCallSession17processIndicationEPv = Module["__ZN13HsCallSession17processIndicationEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSession17processIndicationEPv"].apply(null, arguments);
});
var __ZN13HsCallSession7endCallEv = Module["__ZN13HsCallSession7endCallEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSession7endCallEv"].apply(null, arguments);
});
var __ZN13HsCallSession8holdCallEv = Module["__ZN13HsCallSession8holdCallEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSession8holdCallEv"].apply(null, arguments);
});
var __ZN13HsCallSession8makeCallE11eCallMode_t = Module["__ZN13HsCallSession8makeCallE11eCallMode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSession8makeCallE11eCallMode_t"].apply(null, arguments);
});
var __ZN13HsCallSessionC2Ej14UserIdentity_tS0_jbbNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE = Module["__ZN13HsCallSessionC2Ej14UserIdentity_tS0_jbbNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSessionC2Ej14UserIdentity_tS0_jbbNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"].apply(null, arguments);
});
var __ZN13HsCallSessionD2Ev = Module["__ZN13HsCallSessionD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN13HsCallSessionD2Ev"].apply(null, arguments);
});
var __ZN15HsSystemManager11getInstanceEv = Module["__ZN15HsSystemManager11getInstanceEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager11getInstanceEv"].apply(null, arguments);
});
var __ZN15HsSystemManager14getCallManagerEv = Module["__ZN15HsSystemManager14getCallManagerEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager14getCallManagerEv"].apply(null, arguments);
});
var __ZN15HsSystemManager17startRegistrationE14UserIdentity_tNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE = Module["__ZN15HsSystemManager17startRegistrationE14UserIdentity_tNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager17startRegistrationE14UserIdentity_tNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE"].apply(null, arguments);
});
var __ZN15HsSystemManager18isNetworkAvailableEv = Module["__ZN15HsSystemManager18isNetworkAvailableEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager18isNetworkAvailableEv"].apply(null, arguments);
});
var __ZN15HsSystemManager20startRcsProvisioningEPcP12ProvParams_t = Module["__ZN15HsSystemManager20startRcsProvisioningEPcP12ProvParams_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager20startRcsProvisioningEPcP12ProvParams_t"].apply(null, arguments);
});
var __ZN15HsSystemManager22createSdkMessageThreadEv = Module["__ZN15HsSystemManager22createSdkMessageThreadEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager22createSdkMessageThreadEv"].apply(null, arguments);
});
var __ZN15HsSystemManager24processGeneralIndicationEPvj = Module["__ZN15HsSystemManager24processGeneralIndicationEPvj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager24processGeneralIndicationEPvj"].apply(null, arguments);
});
var __ZN15HsSystemManager6signInE14UserIdentity_tNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES7_14eServiceType_t = Module["__ZN15HsSystemManager6signInE14UserIdentity_tNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES7_14eServiceType_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager6signInE14UserIdentity_tNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES7_14eServiceType_t"].apply(null, arguments);
});
var __ZN15HsSystemManager7rcsInitEP12SystemNotifyNSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEES8_ = Module["__ZN15HsSystemManager7rcsInitEP12SystemNotifyNSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEES8_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManager7rcsInitEP12SystemNotifyNSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEES8_"].apply(null, arguments);
});
var __ZN15HsSystemManagerC2Ev = Module["__ZN15HsSystemManagerC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN15HsSystemManagerC2Ev"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler15onOtpSendFailedE25eProvisioningReasonCode_t = Module["__ZN16SdkNotifyHandler15onOtpSendFailedE25eProvisioningReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler15onOtpSendFailedE25eProvisioningReasonCode_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler18onNetworkConnectedE17eConnectionType_t = Module["__ZN16SdkNotifyHandler18onNetworkConnectedE17eConnectionType_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler18onNetworkConnectedE17eConnectionType_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler20onRegistrationFailedE21eRegisterReasonCode_t = Module["__ZN16SdkNotifyHandler20onRegistrationFailedE21eRegisterReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler20onRegistrationFailedE21eRegisterReasonCode_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler21onNetworkDisconnectedEv = Module["__ZN16SdkNotifyHandler21onNetworkDisconnectedEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler21onNetworkDisconnectedEv"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler21onRegistrationSuccessEv = Module["__ZN16SdkNotifyHandler21onRegistrationSuccessEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler21onRegistrationSuccessEv"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler22onDeregistrationFailedE21eRegisterReasonCode_t = Module["__ZN16SdkNotifyHandler22onDeregistrationFailedE21eRegisterReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler22onDeregistrationFailedE21eRegisterReasonCode_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler22onInitializationFailedE19eSystemReasonCode_t = Module["__ZN16SdkNotifyHandler22onInitializationFailedE19eSystemReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler22onInitializationFailedE19eSystemReasonCode_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler23onDeregistrationSuccessEv = Module["__ZN16SdkNotifyHandler23onDeregistrationSuccessEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler23onDeregistrationSuccessEv"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler23onInitializationSuccessE19eSystemReasonCode_t = Module["__ZN16SdkNotifyHandler23onInitializationSuccessE19eSystemReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler23onInitializationSuccessE19eSystemReasonCode_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler23onOtpVerificationFailedE25eProvisioningReasonCode_t = Module["__ZN16SdkNotifyHandler23onOtpVerificationFailedE25eProvisioningReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler23onOtpVerificationFailedE25eProvisioningReasonCode_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler24onDeIntializationSuccessEv = Module["__ZN16SdkNotifyHandler24onDeIntializationSuccessEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler24onDeIntializationSuccessEv"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler24onOtpVerificationSuccessENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE14UserIdentity_t = Module["__ZN16SdkNotifyHandler24onOtpVerificationSuccessENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE14UserIdentity_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler24onOtpVerificationSuccessENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE14UserIdentity_t"].apply(null, arguments);
});
var __ZN16SdkNotifyHandler9onOtpSentEv = Module["__ZN16SdkNotifyHandler9onOtpSentEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN16SdkNotifyHandler9onOtpSentEv"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf10answerCallEji = Module["__ZN17HsCommonSdkWasmIf10answerCallEji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf10answerCallEji"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf10unholdCallEj = Module["__ZN17HsCommonSdkWasmIf10unholdCallEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf10unholdCallEj"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf17startProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_S6_ = Module["__ZN17HsCommonSdkWasmIf17startProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_S6_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf17startProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_S6_"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf18manualProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE = Module["__ZN17HsCommonSdkWasmIf18manualProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf18manualProvisioningENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf19startRegistrationIfENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_ = Module["__ZN17HsCommonSdkWasmIf19startRegistrationIfENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf19startRegistrationIfENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_S6_"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf4initENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_ = Module["__ZN17HsCommonSdkWasmIf4initENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf4initENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf7endCallEj = Module["__ZN17HsCommonSdkWasmIf7endCallEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf7endCallEj"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf8holdCallEj = Module["__ZN17HsCommonSdkWasmIf8holdCallEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf8holdCallEj"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIf9startCallENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEi = Module["__ZN17HsCommonSdkWasmIf9startCallENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIf9startCallENSt3__212basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEi"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIfC2Ev = Module["__ZN17HsCommonSdkWasmIfC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIfC2Ev"].apply(null, arguments);
});
var __ZN17HsCommonSdkWasmIfD2Ev = Module["__ZN17HsCommonSdkWasmIfD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN17HsCommonSdkWasmIfD2Ev"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler11onCallEndedEj17eCallReasonCode_t = Module["__ZN24CallManagerNotifyHandler11onCallEndedEj17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler11onCallEndedEj17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler14onIncomingCallE14UserIdentity_t11eCallMode_tjb = Module["__ZN24CallManagerNotifyHandler14onIncomingCallE14UserIdentity_t11eCallMode_tjb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler14onIncomingCallE14UserIdentity_t11eCallMode_tjb"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler18onSwitchCallFailedE17eCallReasonCode_t = Module["__ZN24CallManagerNotifyHandler18onSwitchCallFailedE17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler18onSwitchCallFailedE17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler19onSwitchCallSuccessEv = Module["__ZN24CallManagerNotifyHandler19onSwitchCallSuccessEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler19onSwitchCallSuccessEv"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler22onConferenceIndicationEv = Module["__ZN24CallManagerNotifyHandler22onConferenceIndicationEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler22onConferenceIndicationEv"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler22onIncomingCallRejectedE14UserIdentity_t17eCallReasonCode_t = Module["__ZN24CallManagerNotifyHandler22onIncomingCallRejectedE14UserIdentity_t17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler22onIncomingCallRejectedE14UserIdentity_t17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler24onIncomingCallRedirectedE14UserIdentity_t17eCallReasonCode_t = Module["__ZN24CallManagerNotifyHandler24onIncomingCallRedirectedE14UserIdentity_t17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler24onIncomingCallRedirectedE14UserIdentity_t17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallManagerNotifyHandler28onVoiceMessageWaitIndicationEi = Module["__ZN24CallManagerNotifyHandler28onVoiceMessageWaitIndicationEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallManagerNotifyHandler28onVoiceMessageWaitIndicationEi"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler11onCallEndedE17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler11onCallEndedE17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler11onCallEndedE17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler14onCallReplacedE14UserIdentity_tS0_ = Module["__ZN24CallSessionNotifyHandler14onCallReplacedE14UserIdentity_tS0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler14onCallReplacedE14UserIdentity_tS0_"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler15onCallForwardedE14UserIdentity_t17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler15onCallForwardedE14UserIdentity_t17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler15onCallForwardedE14UserIdentity_t17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler16onMuteIndicationEb17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler16onMuteIndicationEb17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler16onMuteIndicationEb17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler17onCallTransferredE14UserIdentity_t = Module["__ZN24CallSessionNotifyHandler17onCallTransferredE14UserIdentity_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler17onCallTransferredE14UserIdentity_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler20onCallForwardRequestE14UserIdentity_t17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler20onCallForwardRequestE14UserIdentity_t17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler20onCallForwardRequestE14UserIdentity_t17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler20onCallReplaceFailureEv = Module["__ZN24CallSessionNotifyHandler20onCallReplaceFailureEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler20onCallReplaceFailureEv"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler21onCallTransferFailureE17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler21onCallTransferFailureE17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler21onCallTransferFailureE17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler21onCallTransferRequestE14UserIdentity_t17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler21onCallTransferRequestE14UserIdentity_t17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler21onCallTransferRequestE14UserIdentity_t17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler21onCallTransferSuccessEv = Module["__ZN24CallSessionNotifyHandler21onCallTransferSuccessEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler21onCallTransferSuccessEv"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler21onLocalHoldIndicationEb17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler21onLocalHoldIndicationEb17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler21onLocalHoldIndicationEb17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler22onRemoteHoldIndicationEb = Module["__ZN24CallSessionNotifyHandler22onRemoteHoldIndicationEb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler22onRemoteHoldIndicationEb"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler23onEndCallFailIndicationE17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler23onEndCallFailIndicationE17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler23onEndCallFailIndicationE17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler24onCallProgressIndicationE12eCallState_t = Module["__ZN24CallSessionNotifyHandler24onCallProgressIndicationE12eCallState_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler24onCallProgressIndicationE12eCallState_t"].apply(null, arguments);
});
var __ZN24CallSessionNotifyHandler26onAnswerCallFailIndicationE17eCallReasonCode_t = Module["__ZN24CallSessionNotifyHandler26onAnswerCallFailIndicationE17eCallReasonCode_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN24CallSessionNotifyHandler26onAnswerCallFailIndicationE17eCallReasonCode_t"].apply(null, arguments);
});
var __ZN38EmscriptenBindingInitializer_interfaceC2Ev = Module["__ZN38EmscriptenBindingInitializer_interfaceC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN38EmscriptenBindingInitializer_interfaceC2Ev"].apply(null, arguments);
});
var __ZN53EmscriptenBindingInitializer_native_and_builtin_typesC2Ev = Module["__ZN53EmscriptenBindingInitializer_native_and_builtin_typesC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZN53EmscriptenBindingInitializer_native_and_builtin_typesC2Ev"].apply(null, arguments);
});
var __ZNK10__cxxabiv116__enum_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv116__enum_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv116__enum_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments);
});
var __ZNK10__cxxabiv116__shim_type_info5noop1Ev = Module["__ZNK10__cxxabiv116__shim_type_info5noop1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv116__shim_type_info5noop1Ev"].apply(null, arguments);
});
var __ZNK10__cxxabiv116__shim_type_info5noop2Ev = Module["__ZNK10__cxxabiv116__shim_type_info5noop2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv116__shim_type_info5noop2Ev"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i = Module["__ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi = Module["__ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments);
});
var __ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments);
});
var __ZNK10__cxxabiv119__pointer_type_info16can_catch_nestedEPKNS_16__shim_type_infoE = Module["__ZNK10__cxxabiv119__pointer_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv119__pointer_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"].apply(null, arguments);
});
var __ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments);
});
var __ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments);
});
var __ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments);
});
var __ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments);
});
var __ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments);
});
var __ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments);
});
var __ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments);
});
var __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments);
});
var __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments);
});
var __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments);
});
var __ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments);
});
var __ZNK10__cxxabiv129__pointer_to_member_type_info16can_catch_nestedEPKNS_16__shim_type_infoE = Module["__ZNK10__cxxabiv129__pointer_to_member_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK10__cxxabiv129__pointer_to_member_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_110StringView10startsWithES0_ = Module["__ZNK12_GLOBAL__N_110StringView10startsWithES0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_110StringView10startsWithES0_"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_110StringView3endEv = Module["__ZNK12_GLOBAL__N_110StringView3endEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_110StringView3endEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_110StringView4sizeEv = Module["__ZNK12_GLOBAL__N_110StringView4sizeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_110StringView4sizeEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_110StringView5beginEv = Module["__ZNK12_GLOBAL__N_110StringView5beginEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_110StringView5beginEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_110StringView5emptyEv = Module["__ZNK12_GLOBAL__N_110StringView5emptyEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_110StringView5emptyEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_110StringView9dropFrontEm = Module["__ZNK12_GLOBAL__N_110StringView9dropFrontEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_110StringView9dropFrontEm"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_110StringViewixEm = Module["__ZNK12_GLOBAL__N_110StringViewixEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_110StringViewixEm"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_112OutputStream18getCurrentPositionEv = Module["__ZNK12_GLOBAL__N_112OutputStream18getCurrentPositionEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_112OutputStream18getCurrentPositionEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_112OutputStream4backEv = Module["__ZNK12_GLOBAL__N_112OutputStream4backEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_112OutputStream4backEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10AbiTagAttr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10AbiTagAttr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10AbiTagAttr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10BinaryExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10BinaryExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10BinaryExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10BracedExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10BracedExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10BracedExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10DeleteExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10DeleteExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10DeleteExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10MemberExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10MemberExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10MemberExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10NestedName11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle10NestedName11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10NestedName11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10NestedName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10NestedName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10NestedName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10PrefixExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10PrefixExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10PrefixExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle10VectorType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle10VectorType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle10VectorType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle11PointerType10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle11PointerType10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle11PointerType10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle11PointerType19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle11PointerType19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle11PointerType19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle11PointerType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle11PointerType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle11PointerType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle11PostfixExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle11PostfixExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle11PostfixExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle11SpecialName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle11SpecialName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle11SpecialName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12CtorDtorName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12CtorDtorName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12CtorDtorName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12EnableIfAttr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12EnableIfAttr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12EnableIfAttr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12FunctionType10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12FunctionType15hasFunctionSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType15hasFunctionSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType15hasFunctionSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12FunctionType19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12FunctionType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12FunctionType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12InitListExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12InitListExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12InitListExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString6asNodeEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString6asNodeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString6asNodeEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString6isNodeEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString6isNodeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString6isNodeEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString8asStringEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString8asStringEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString8asStringEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString8isStringEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString8isStringEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12NodeOrString8isStringEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12NoexceptSpec9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12NoexceptSpec9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12NoexceptSpec9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle12TemplateArgs9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle12TemplateArgs9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle12TemplateArgs9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13EnclosingExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13EnclosingExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13EnclosingExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13FunctionParam9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13FunctionParam9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13FunctionParam9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13NodeArrayNode9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13NodeArrayNode9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13NodeArrayNode9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ObjCProtoName12isObjCObjectEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ObjCProtoName12isObjCObjectEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ObjCProtoName12isObjCObjectEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ObjCProtoName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ObjCProtoName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ObjCProtoName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack12hasArraySlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack12hasArraySlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack12hasArraySlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack13getSyntaxNodeERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack13getSyntaxNodeERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack13getSyntaxNodeERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack15hasFunctionSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack15hasFunctionSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack15hasFunctionSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack23initializePackExpansionERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack23initializePackExpansionERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack23initializePackExpansionERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ParameterPack9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13QualifiedName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType8collapseERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType8collapseERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType8collapseERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle13ReferenceType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14ConversionExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle14ConversionExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14ConversionExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14IntegerLiteral9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle14IntegerLiteral9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14IntegerLiteral9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE4sizeEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE4sizeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE4sizeEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE8isInlineEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE8isInlineEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_24ForwardTemplateReferenceELm4EE8isInlineEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE4sizeEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE4sizeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE4sizeEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE5emptyEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE5emptyEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE5emptyEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8isInlineEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8isInlineEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm32EE8isInlineEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE4sizeEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE4sizeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE4sizeEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE8isInlineEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE8isInlineEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle14PODSmallVectorIPNS0_4NodeELm8EE8isInlineEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle15BracedRangeExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle15BracedRangeExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle15BracedRangeExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle15ClosureTypeName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle15ClosureTypeName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle15ClosureTypeName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle15ConditionalExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle15ConditionalExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle15ConditionalExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle15IntegerCastExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle15IntegerCastExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle15IntegerCastExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle15LiteralOperator9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle15LiteralOperator9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle15LiteralOperator9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle15PixelVectorType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle15PixelVectorType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle15PixelVectorType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle15UnnamedTypeName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle15UnnamedTypeName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle15UnnamedTypeName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdE9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdE9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIdE9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeE9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeE9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIeE9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfE9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfE9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16FloatLiteralImplIfE9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding15hasFunctionSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding15hasFunctionSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding15hasFunctionSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16FunctionEncoding9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle16StdQualifiedName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle17VendorExtQualType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle17VendorExtQualType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle17VendorExtQualType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle18ArraySubscriptExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle18ArraySubscriptExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle18ArraySubscriptExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19GlobalQualifiedName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19PointerToMemberType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19SizeofParamPackExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle19SizeofParamPackExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19SizeofParamPackExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle19SpecialSubstitution9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpec9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpec9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle20DynamicExceptionSpec9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle20NameWithTemplateArgs9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle20PostfixQualifiedType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle20PostfixQualifiedType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle20PostfixQualifiedType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle20TemplateArgumentPack11getElementsEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle20TemplateArgumentPack11getElementsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle20TemplateArgumentPack11getElementsEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle20TemplateArgumentPack9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle20TemplateArgumentPack9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle20TemplateArgumentPack9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle21CtorVtableSpecialName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle21StructuredBindingName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle21StructuredBindingName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle21StructuredBindingName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E7numLeftEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E7numLeftEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E7numLeftEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle22ConversionOperatorType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle22ConversionOperatorType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle22ConversionOperatorType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle22ElaboratedTypeSpefType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle22ParameterPackExpansion9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle22ParameterPackExpansion9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle22ParameterPackExpansion9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference12hasArraySlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference12hasArraySlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference12hasArraySlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference13getSyntaxNodeERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference13getSyntaxNodeERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference13getSyntaxNodeERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference15hasFunctionSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference15hasFunctionSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference15hasFunctionSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle24ForwardTemplateReference9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle27ExpandedSpecialSubstitution9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node11hasFunctionERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node11hasFunctionERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node11hasFunctionERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node12hasArraySlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node12hasArraySlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node12hasArraySlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node13getSyntaxNodeERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node13getSyntaxNodeERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node13getSyntaxNodeERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node15hasFunctionSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node15hasFunctionSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node15hasFunctionSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node15hasRHSComponentERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node15hasRHSComponentERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node15hasRHSComponentERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node5printERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node5printERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node5printERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node7getKindEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node7getKindEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node7getKindEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle4Node8hasArrayERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle4Node8hasArrayERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle4Node8hasArrayERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle7NewExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle7NewExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle7NewExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8BoolExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8BoolExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8BoolExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8CallExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8CallExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8CallExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8CastExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8CastExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8CastExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8DtorName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8DtorName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8DtorName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8FoldExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8FoldExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8FoldExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8NameType11getBaseNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle8NameType11getBaseNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8NameType11getBaseNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8NameType7getNameEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle8NameType7getNameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8NameType7getNameEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8NameType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8NameType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8NameType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8QualType10printQualsERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8QualType10printQualsERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8QualType10printQualsERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8QualType10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8QualType10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8QualType10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8QualType12hasArraySlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8QualType12hasArraySlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8QualType12hasArraySlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8QualType15hasFunctionSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8QualType15hasFunctionSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8QualType15hasFunctionSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8QualType19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8QualType19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8QualType19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle8QualType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle8QualType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle8QualType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9ArrayType10printRightERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType10printRightERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType10printRightERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9ArrayType12hasArraySlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType12hasArraySlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType12hasArraySlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9ArrayType19hasRHSComponentSlowERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType19hasRHSComponentSlowERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType19hasRHSComponentSlowERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9ArrayType9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9ArrayType9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9DotSuffix9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9DotSuffix9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9DotSuffix9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9LocalName9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9LocalName9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9LocalName9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9NodeArray14printWithCommaERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray14printWithCommaERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray14printWithCommaERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9NodeArray3endEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray3endEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray3endEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9NodeArray4sizeEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray4sizeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray4sizeEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9NodeArray5beginEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray5beginEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray5beginEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9NodeArray5emptyEv = Module["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray5emptyEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArray5emptyEv"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9NodeArrayixEm = Module["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArrayixEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9NodeArrayixEm"].apply(null, arguments);
});
var __ZNK12_GLOBAL__N_116itanium_demangle9ThrowExpr9printLeftERNS_12OutputStreamE = Module["__ZNK12_GLOBAL__N_116itanium_demangle9ThrowExpr9printLeftERNS_12OutputStreamE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNK12_GLOBAL__N_116itanium_demangle9ThrowExpr9printLeftERNS_12OutputStreamE"].apply(null, arguments);
});
var __ZNKSt11logic_error4whatEv = Module["__ZNKSt11logic_error4whatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt11logic_error4whatEv"].apply(null, arguments);
});
var __ZNKSt3__210__time_put8__do_putEPcRS1_PK2tmcc = Module["__ZNKSt3__210__time_put8__do_putEPcRS1_PK2tmcc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210__time_put8__do_putEPcRS1_PK2tmcc"].apply(null, arguments);
});
var __ZNKSt3__210__time_put8__do_putEPwRS1_PK2tmcc = Module["__ZNKSt3__210__time_put8__do_putEPwRS1_PK2tmcc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210__time_put8__do_putEPwRS1_PK2tmcc"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE11do_groupingEv = Module["__ZNKSt3__210moneypunctIcLb0EE11do_groupingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE11do_groupingEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE13do_neg_formatEv = Module["__ZNKSt3__210moneypunctIcLb0EE13do_neg_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE13do_neg_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE13do_pos_formatEv = Module["__ZNKSt3__210moneypunctIcLb0EE13do_pos_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE13do_pos_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE14do_curr_symbolEv = Module["__ZNKSt3__210moneypunctIcLb0EE14do_curr_symbolEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE14do_curr_symbolEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE14do_frac_digitsEv = Module["__ZNKSt3__210moneypunctIcLb0EE14do_frac_digitsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE14do_frac_digitsEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE16do_decimal_pointEv = Module["__ZNKSt3__210moneypunctIcLb0EE16do_decimal_pointEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE16do_decimal_pointEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE16do_negative_signEv = Module["__ZNKSt3__210moneypunctIcLb0EE16do_negative_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE16do_negative_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE16do_positive_signEv = Module["__ZNKSt3__210moneypunctIcLb0EE16do_positive_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE16do_positive_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb0EE16do_thousands_sepEv = Module["__ZNKSt3__210moneypunctIcLb0EE16do_thousands_sepEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb0EE16do_thousands_sepEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE11do_groupingEv = Module["__ZNKSt3__210moneypunctIcLb1EE11do_groupingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE11do_groupingEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE13do_neg_formatEv = Module["__ZNKSt3__210moneypunctIcLb1EE13do_neg_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE13do_neg_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE13do_pos_formatEv = Module["__ZNKSt3__210moneypunctIcLb1EE13do_pos_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE13do_pos_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE14do_curr_symbolEv = Module["__ZNKSt3__210moneypunctIcLb1EE14do_curr_symbolEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE14do_curr_symbolEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE14do_frac_digitsEv = Module["__ZNKSt3__210moneypunctIcLb1EE14do_frac_digitsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE14do_frac_digitsEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE16do_decimal_pointEv = Module["__ZNKSt3__210moneypunctIcLb1EE16do_decimal_pointEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE16do_decimal_pointEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE16do_negative_signEv = Module["__ZNKSt3__210moneypunctIcLb1EE16do_negative_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE16do_negative_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE16do_positive_signEv = Module["__ZNKSt3__210moneypunctIcLb1EE16do_positive_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE16do_positive_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIcLb1EE16do_thousands_sepEv = Module["__ZNKSt3__210moneypunctIcLb1EE16do_thousands_sepEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIcLb1EE16do_thousands_sepEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE11do_groupingEv = Module["__ZNKSt3__210moneypunctIwLb0EE11do_groupingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE11do_groupingEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE13do_neg_formatEv = Module["__ZNKSt3__210moneypunctIwLb0EE13do_neg_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE13do_neg_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE13do_pos_formatEv = Module["__ZNKSt3__210moneypunctIwLb0EE13do_pos_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE13do_pos_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE14do_curr_symbolEv = Module["__ZNKSt3__210moneypunctIwLb0EE14do_curr_symbolEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE14do_curr_symbolEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE14do_frac_digitsEv = Module["__ZNKSt3__210moneypunctIwLb0EE14do_frac_digitsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE14do_frac_digitsEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE16do_decimal_pointEv = Module["__ZNKSt3__210moneypunctIwLb0EE16do_decimal_pointEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE16do_decimal_pointEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE16do_negative_signEv = Module["__ZNKSt3__210moneypunctIwLb0EE16do_negative_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE16do_negative_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE16do_positive_signEv = Module["__ZNKSt3__210moneypunctIwLb0EE16do_positive_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE16do_positive_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb0EE16do_thousands_sepEv = Module["__ZNKSt3__210moneypunctIwLb0EE16do_thousands_sepEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb0EE16do_thousands_sepEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE11do_groupingEv = Module["__ZNKSt3__210moneypunctIwLb1EE11do_groupingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE11do_groupingEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE13do_neg_formatEv = Module["__ZNKSt3__210moneypunctIwLb1EE13do_neg_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE13do_neg_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE13do_pos_formatEv = Module["__ZNKSt3__210moneypunctIwLb1EE13do_pos_formatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE13do_pos_formatEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE14do_curr_symbolEv = Module["__ZNKSt3__210moneypunctIwLb1EE14do_curr_symbolEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE14do_curr_symbolEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE14do_frac_digitsEv = Module["__ZNKSt3__210moneypunctIwLb1EE14do_frac_digitsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE14do_frac_digitsEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE16do_decimal_pointEv = Module["__ZNKSt3__210moneypunctIwLb1EE16do_decimal_pointEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE16do_decimal_pointEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE16do_negative_signEv = Module["__ZNKSt3__210moneypunctIwLb1EE16do_negative_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE16do_negative_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE16do_positive_signEv = Module["__ZNKSt3__210moneypunctIwLb1EE16do_positive_signEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE16do_positive_signEv"].apply(null, arguments);
});
var __ZNKSt3__210moneypunctIwLb1EE16do_thousands_sepEv = Module["__ZNKSt3__210moneypunctIwLb1EE16do_thousands_sepEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__210moneypunctIwLb1EE16do_thousands_sepEv"].apply(null, arguments);
});
var __ZNKSt3__212_GLOBAL__N_111__fake_bindclEv = Module["__ZNKSt3__212_GLOBAL__N_111__fake_bindclEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__212_GLOBAL__N_111__fake_bindclEv"].apply(null, arguments);
});
var __ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7compareEmmPKcm = Module["__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7compareEmmPKcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7compareEmmPKcm"].apply(null, arguments);
});
var __ZNKSt3__218__libcpp_refstring15__uses_refcountEv = Module["__ZNKSt3__218__libcpp_refstring15__uses_refcountEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__218__libcpp_refstring15__uses_refcountEv"].apply(null, arguments);
});
var __ZNKSt3__218__libcpp_refstring5c_strEv = Module["__ZNKSt3__218__libcpp_refstring5c_strEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__218__libcpp_refstring5c_strEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIcE3__XEv = Module["__ZNKSt3__220__time_get_c_storageIcE3__XEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIcE3__XEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIcE3__cEv = Module["__ZNKSt3__220__time_get_c_storageIcE3__cEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIcE3__cEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIcE3__rEv = Module["__ZNKSt3__220__time_get_c_storageIcE3__rEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIcE3__rEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIcE3__xEv = Module["__ZNKSt3__220__time_get_c_storageIcE3__xEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIcE3__xEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIcE7__am_pmEv = Module["__ZNKSt3__220__time_get_c_storageIcE7__am_pmEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIcE7__am_pmEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIcE7__weeksEv = Module["__ZNKSt3__220__time_get_c_storageIcE7__weeksEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIcE7__weeksEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIcE8__monthsEv = Module["__ZNKSt3__220__time_get_c_storageIcE8__monthsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIcE8__monthsEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIwE3__XEv = Module["__ZNKSt3__220__time_get_c_storageIwE3__XEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIwE3__XEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIwE3__cEv = Module["__ZNKSt3__220__time_get_c_storageIwE3__cEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIwE3__cEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIwE3__rEv = Module["__ZNKSt3__220__time_get_c_storageIwE3__rEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIwE3__rEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIwE3__xEv = Module["__ZNKSt3__220__time_get_c_storageIwE3__xEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIwE3__xEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIwE7__am_pmEv = Module["__ZNKSt3__220__time_get_c_storageIwE7__am_pmEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIwE7__am_pmEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIwE7__weeksEv = Module["__ZNKSt3__220__time_get_c_storageIwE7__weeksEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIwE7__weeksEv"].apply(null, arguments);
});
var __ZNKSt3__220__time_get_c_storageIwE8__monthsEv = Module["__ZNKSt3__220__time_get_c_storageIwE8__monthsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__time_get_c_storageIwE8__monthsEv"].apply(null, arguments);
});
var __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = Module["__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv"].apply(null, arguments);
});
var __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv = Module["__ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv"].apply(null, arguments);
});
var __ZNKSt3__221__basic_string_commonILb1EE20__throw_out_of_rangeEv = Module["__ZNKSt3__221__basic_string_commonILb1EE20__throw_out_of_rangeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__221__basic_string_commonILb1EE20__throw_out_of_rangeEv"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE10do_tolowerEPcPKc = Module["__ZNKSt3__25ctypeIcE10do_tolowerEPcPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE10do_tolowerEPcPKc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE10do_tolowerEc = Module["__ZNKSt3__25ctypeIcE10do_tolowerEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE10do_tolowerEc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE10do_toupperEPcPKc = Module["__ZNKSt3__25ctypeIcE10do_toupperEPcPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE10do_toupperEPcPKc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE10do_toupperEc = Module["__ZNKSt3__25ctypeIcE10do_toupperEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE10do_toupperEc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE8do_widenEPKcS3_Pc = Module["__ZNKSt3__25ctypeIcE8do_widenEPKcS3_Pc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE8do_widenEPKcS3_Pc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE8do_widenEc = Module["__ZNKSt3__25ctypeIcE8do_widenEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE8do_widenEc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE9do_narrowEPKcS3_cPc = Module["__ZNKSt3__25ctypeIcE9do_narrowEPKcS3_cPc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE9do_narrowEPKcS3_cPc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIcE9do_narrowEcc = Module["__ZNKSt3__25ctypeIcE9do_narrowEcc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIcE9do_narrowEcc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE10do_scan_isEtPKwS3_ = Module["__ZNKSt3__25ctypeIwE10do_scan_isEtPKwS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE10do_scan_isEtPKwS3_"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE10do_tolowerEPwPKw = Module["__ZNKSt3__25ctypeIwE10do_tolowerEPwPKw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE10do_tolowerEPwPKw"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE10do_tolowerEw = Module["__ZNKSt3__25ctypeIwE10do_tolowerEw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE10do_tolowerEw"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE10do_toupperEPwPKw = Module["__ZNKSt3__25ctypeIwE10do_toupperEPwPKw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE10do_toupperEPwPKw"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE10do_toupperEw = Module["__ZNKSt3__25ctypeIwE10do_toupperEw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE10do_toupperEw"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE11do_scan_notEtPKwS3_ = Module["__ZNKSt3__25ctypeIwE11do_scan_notEtPKwS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE11do_scan_notEtPKwS3_"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE5do_isEPKwS3_Pt = Module["__ZNKSt3__25ctypeIwE5do_isEPKwS3_Pt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE5do_isEPKwS3_Pt"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE5do_isEtw = Module["__ZNKSt3__25ctypeIwE5do_isEtw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE5do_isEtw"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE8do_widenEPKcS3_Pw = Module["__ZNKSt3__25ctypeIwE8do_widenEPKcS3_Pw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE8do_widenEPKcS3_Pw"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE8do_widenEc = Module["__ZNKSt3__25ctypeIwE8do_widenEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE8do_widenEc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE9do_narrowEPKwS3_cPc = Module["__ZNKSt3__25ctypeIwE9do_narrowEPKwS3_cPc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE9do_narrowEPKwS3_cPc"].apply(null, arguments);
});
var __ZNKSt3__25ctypeIwE9do_narrowEwc = Module["__ZNKSt3__25ctypeIwE9do_narrowEwc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__25ctypeIwE9do_narrowEwc"].apply(null, arguments);
});
var __ZNKSt3__26locale5__imp9use_facetEl = Module["__ZNKSt3__26locale5__imp9use_facetEl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__26locale5__imp9use_facetEl"].apply(null, arguments);
});
var __ZNKSt3__26locale9use_facetERNS0_2idE = Module["__ZNKSt3__26locale9use_facetERNS0_2idE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__26locale9use_facetERNS0_2idE"].apply(null, arguments);
});
var __ZNKSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE8max_sizeEv = Module["__ZNKSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE8max_sizeEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE8max_sizeEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDic11__mbstate_tE10do_unshiftERS1_PcS4_RS4_ = Module["__ZNKSt3__27codecvtIDic11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDic11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDic11__mbstate_tE11do_encodingEv = Module["__ZNKSt3__27codecvtIDic11__mbstate_tE11do_encodingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDic11__mbstate_tE11do_encodingEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDic11__mbstate_tE13do_max_lengthEv = Module["__ZNKSt3__27codecvtIDic11__mbstate_tE13do_max_lengthEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDic11__mbstate_tE13do_max_lengthEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDic11__mbstate_tE16do_always_noconvEv = Module["__ZNKSt3__27codecvtIDic11__mbstate_tE16do_always_noconvEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDic11__mbstate_tE16do_always_noconvEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDic11__mbstate_tE5do_inERS1_PKcS5_RS5_PDiS7_RS7_ = Module["__ZNKSt3__27codecvtIDic11__mbstate_tE5do_inERS1_PKcS5_RS5_PDiS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDic11__mbstate_tE5do_inERS1_PKcS5_RS5_PDiS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDic11__mbstate_tE6do_outERS1_PKDiS5_RS5_PcS7_RS7_ = Module["__ZNKSt3__27codecvtIDic11__mbstate_tE6do_outERS1_PKDiS5_RS5_PcS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDic11__mbstate_tE6do_outERS1_PKDiS5_RS5_PcS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDic11__mbstate_tE9do_lengthERS1_PKcS5_m = Module["__ZNKSt3__27codecvtIDic11__mbstate_tE9do_lengthERS1_PKcS5_m"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDic11__mbstate_tE9do_lengthERS1_PKcS5_m"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDsc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_ = Module["__ZNKSt3__27codecvtIDsc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDsc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDsc11__mbstate_tE11do_encodingEv = Module["__ZNKSt3__27codecvtIDsc11__mbstate_tE11do_encodingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDsc11__mbstate_tE11do_encodingEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDsc11__mbstate_tE13do_max_lengthEv = Module["__ZNKSt3__27codecvtIDsc11__mbstate_tE13do_max_lengthEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDsc11__mbstate_tE13do_max_lengthEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDsc11__mbstate_tE16do_always_noconvEv = Module["__ZNKSt3__27codecvtIDsc11__mbstate_tE16do_always_noconvEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDsc11__mbstate_tE16do_always_noconvEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDsc11__mbstate_tE5do_inERS1_PKcS5_RS5_PDsS7_RS7_ = Module["__ZNKSt3__27codecvtIDsc11__mbstate_tE5do_inERS1_PKcS5_RS5_PDsS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDsc11__mbstate_tE5do_inERS1_PKcS5_RS5_PDsS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDsc11__mbstate_tE6do_outERS1_PKDsS5_RS5_PcS7_RS7_ = Module["__ZNKSt3__27codecvtIDsc11__mbstate_tE6do_outERS1_PKDsS5_RS5_PcS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDsc11__mbstate_tE6do_outERS1_PKDsS5_RS5_PcS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIDsc11__mbstate_tE9do_lengthERS1_PKcS5_m = Module["__ZNKSt3__27codecvtIDsc11__mbstate_tE9do_lengthERS1_PKcS5_m"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIDsc11__mbstate_tE9do_lengthERS1_PKcS5_m"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIcc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_ = Module["__ZNKSt3__27codecvtIcc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIcc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIcc11__mbstate_tE11do_encodingEv = Module["__ZNKSt3__27codecvtIcc11__mbstate_tE11do_encodingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIcc11__mbstate_tE11do_encodingEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIcc11__mbstate_tE13do_max_lengthEv = Module["__ZNKSt3__27codecvtIcc11__mbstate_tE13do_max_lengthEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIcc11__mbstate_tE13do_max_lengthEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIcc11__mbstate_tE16do_always_noconvEv = Module["__ZNKSt3__27codecvtIcc11__mbstate_tE16do_always_noconvEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIcc11__mbstate_tE16do_always_noconvEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIcc11__mbstate_tE5do_inERS1_PKcS5_RS5_PcS7_RS7_ = Module["__ZNKSt3__27codecvtIcc11__mbstate_tE5do_inERS1_PKcS5_RS5_PcS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIcc11__mbstate_tE5do_inERS1_PKcS5_RS5_PcS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIcc11__mbstate_tE6do_outERS1_PKcS5_RS5_PcS7_RS7_ = Module["__ZNKSt3__27codecvtIcc11__mbstate_tE6do_outERS1_PKcS5_RS5_PcS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIcc11__mbstate_tE6do_outERS1_PKcS5_RS5_PcS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIcc11__mbstate_tE9do_lengthERS1_PKcS5_m = Module["__ZNKSt3__27codecvtIcc11__mbstate_tE9do_lengthERS1_PKcS5_m"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIcc11__mbstate_tE9do_lengthERS1_PKcS5_m"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIwc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_ = Module["__ZNKSt3__27codecvtIwc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIwc11__mbstate_tE10do_unshiftERS1_PcS4_RS4_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIwc11__mbstate_tE11do_encodingEv = Module["__ZNKSt3__27codecvtIwc11__mbstate_tE11do_encodingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIwc11__mbstate_tE11do_encodingEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIwc11__mbstate_tE13do_max_lengthEv = Module["__ZNKSt3__27codecvtIwc11__mbstate_tE13do_max_lengthEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIwc11__mbstate_tE13do_max_lengthEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIwc11__mbstate_tE16do_always_noconvEv = Module["__ZNKSt3__27codecvtIwc11__mbstate_tE16do_always_noconvEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIwc11__mbstate_tE16do_always_noconvEv"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIwc11__mbstate_tE5do_inERS1_PKcS5_RS5_PwS7_RS7_ = Module["__ZNKSt3__27codecvtIwc11__mbstate_tE5do_inERS1_PKcS5_RS5_PwS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIwc11__mbstate_tE5do_inERS1_PKcS5_RS5_PwS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIwc11__mbstate_tE6do_outERS1_PKwS5_RS5_PcS7_RS7_ = Module["__ZNKSt3__27codecvtIwc11__mbstate_tE6do_outERS1_PKwS5_RS5_PcS7_RS7_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIwc11__mbstate_tE6do_outERS1_PKwS5_RS5_PcS7_RS7_"].apply(null, arguments);
});
var __ZNKSt3__27codecvtIwc11__mbstate_tE9do_lengthERS1_PKcS5_m = Module["__ZNKSt3__27codecvtIwc11__mbstate_tE9do_lengthERS1_PKcS5_m"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27codecvtIwc11__mbstate_tE9do_lengthERS1_PKcS5_m"].apply(null, arguments);
});
var __ZNKSt3__27collateIcE10do_compareEPKcS3_S3_S3_ = Module["__ZNKSt3__27collateIcE10do_compareEPKcS3_S3_S3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27collateIcE10do_compareEPKcS3_S3_S3_"].apply(null, arguments);
});
var __ZNKSt3__27collateIcE12do_transformEPKcS3_ = Module["__ZNKSt3__27collateIcE12do_transformEPKcS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27collateIcE12do_transformEPKcS3_"].apply(null, arguments);
});
var __ZNKSt3__27collateIcE7do_hashEPKcS3_ = Module["__ZNKSt3__27collateIcE7do_hashEPKcS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27collateIcE7do_hashEPKcS3_"].apply(null, arguments);
});
var __ZNKSt3__27collateIwE10do_compareEPKwS3_S3_S3_ = Module["__ZNKSt3__27collateIwE10do_compareEPKwS3_S3_S3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27collateIwE10do_compareEPKwS3_S3_S3_"].apply(null, arguments);
});
var __ZNKSt3__27collateIwE12do_transformEPKwS3_ = Module["__ZNKSt3__27collateIwE12do_transformEPKwS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27collateIwE12do_transformEPKwS3_"].apply(null, arguments);
});
var __ZNKSt3__27collateIwE7do_hashEPKwS3_ = Module["__ZNKSt3__27collateIwE7do_hashEPKwS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27collateIwE7do_hashEPKwS3_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__do_get_signedIlEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__do_get_signedIlEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__do_get_signedIlEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__do_get_signedIxEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__do_get_signedIxEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__do_get_signedIxEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedIjEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedIjEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedIjEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedImEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedImEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedImEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedItEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedItEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedItEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedIyEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedIyEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__do_get_unsignedIyEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIdEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIdEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIdEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIeEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIeEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIeEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIfEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIfEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE23__do_get_floating_pointIfEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRb = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRb"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRd = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRd"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRe = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRe"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRf = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRf"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRl = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRl"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRm = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRm"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRt = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRt"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRx = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRx"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRy = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjRy"].apply(null, arguments);
});
var __ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_ = Module["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__do_get_signedIlEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__do_get_signedIlEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__do_get_signedIlEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__do_get_signedIxEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__do_get_signedIxEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__do_get_signedIxEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedIjEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedIjEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedIjEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedImEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedImEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedImEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedItEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedItEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedItEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedIyEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedIyEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__do_get_unsignedIyEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIdEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIdEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIdEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIeEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIeEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIeEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIfEES4_S4_S4_RNS_8ios_baseERjRT_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIfEES4_S4_S4_RNS_8ios_baseERjRT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE23__do_get_floating_pointIfEES4_S4_S4_RNS_8ios_baseERjRT_"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRPv"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRb = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRb"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRd = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRd"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRe = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRe"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRf = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRf"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRl = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRl"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRm = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRm"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRt = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRt"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRx = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRx"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRy = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjRy"].apply(null, arguments);
});
var __ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_ = Module["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjS8_"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPKv = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPKv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPKv"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcb = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcb"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcd = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcd"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEce = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEce"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEce"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcl = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcl"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcm = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcm"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcx = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcx"].apply(null, arguments);
});
var __ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcy = Module["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcy"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPKv = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPKv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPKv"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwb = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwb"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwd = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwd"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwe = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwe"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwl = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwl"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwm = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwm"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwx = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwx"].apply(null, arguments);
});
var __ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwy = Module["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwy"].apply(null, arguments);
});
var __ZNKSt3__28ios_base6getlocEv = Module["__ZNKSt3__28ios_base6getlocEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28ios_base6getlocEv"].apply(null, arguments);
});
var __ZNKSt3__28messagesIcE6do_getEliiRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = Module["__ZNKSt3__28messagesIcE6do_getEliiRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28messagesIcE6do_getEliiRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE"].apply(null, arguments);
});
var __ZNKSt3__28messagesIcE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE = Module["__ZNKSt3__28messagesIcE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28messagesIcE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE"].apply(null, arguments);
});
var __ZNKSt3__28messagesIcE8do_closeEl = Module["__ZNKSt3__28messagesIcE8do_closeEl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28messagesIcE8do_closeEl"].apply(null, arguments);
});
var __ZNKSt3__28messagesIwE6do_getEliiRKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEE = Module["__ZNKSt3__28messagesIwE6do_getEliiRKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28messagesIwE6do_getEliiRKNS_12basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEEE"].apply(null, arguments);
});
var __ZNKSt3__28messagesIwE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE = Module["__ZNKSt3__28messagesIwE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28messagesIwE7do_openERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNS_6localeE"].apply(null, arguments);
});
var __ZNKSt3__28messagesIwE8do_closeEl = Module["__ZNKSt3__28messagesIwE8do_closeEl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28messagesIwE8do_closeEl"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIcE11do_groupingEv = Module["__ZNKSt3__28numpunctIcE11do_groupingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIcE11do_groupingEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIcE11do_truenameEv = Module["__ZNKSt3__28numpunctIcE11do_truenameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIcE11do_truenameEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIcE12do_falsenameEv = Module["__ZNKSt3__28numpunctIcE12do_falsenameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIcE12do_falsenameEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIcE16do_decimal_pointEv = Module["__ZNKSt3__28numpunctIcE16do_decimal_pointEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIcE16do_decimal_pointEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIcE16do_thousands_sepEv = Module["__ZNKSt3__28numpunctIcE16do_thousands_sepEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIcE16do_thousands_sepEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIwE11do_groupingEv = Module["__ZNKSt3__28numpunctIwE11do_groupingEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIwE11do_groupingEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIwE11do_truenameEv = Module["__ZNKSt3__28numpunctIwE11do_truenameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIwE11do_truenameEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIwE12do_falsenameEv = Module["__ZNKSt3__28numpunctIwE12do_falsenameEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIwE12do_falsenameEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIwE16do_decimal_pointEv = Module["__ZNKSt3__28numpunctIwE16do_decimal_pointEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIwE16do_decimal_pointEv"].apply(null, arguments);
});
var __ZNKSt3__28numpunctIwE16do_thousands_sepEv = Module["__ZNKSt3__28numpunctIwE16do_thousands_sepEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28numpunctIwE16do_thousands_sepEv"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE10__get_hourERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE10__get_hourERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE10__get_hourERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE10__get_yearERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE10__get_yearERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE10__get_yearERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_am_pmERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_am_pmERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_am_pmERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_monthERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_monthERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_monthERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_year4ERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_year4ERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11__get_year4ERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE12__get_minuteERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE12__get_minuteERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE12__get_minuteERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE12__get_secondERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE12__get_secondERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE12__get_secondERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_12_hourERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_12_hourERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_12_hourERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_percentERS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_percentERS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_percentERS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_weekdayERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_weekdayERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13__get_weekdayERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13do_date_orderEv = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13do_date_orderEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE13do_date_orderEv"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__get_monthnameERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__get_monthnameERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE15__get_monthnameERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__get_weekdaynameERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__get_weekdaynameERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__get_weekdaynameERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__get_white_spaceERS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__get_white_spaceERS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE17__get_white_spaceERS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE18__get_day_year_numERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE18__get_day_year_numERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE18__get_day_year_numERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE3getES4_S4_RNS_8ios_baseERjP2tmPKcSC_ = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE3getES4_S4_RNS_8ios_baseERjP2tmPKcSC_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE3getES4_S4_RNS_8ios_baseERjP2tmPKcSC_"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc"].apply(null, arguments);
});
var __ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE9__get_dayERiRS4_S4_RjRKNS_5ctypeIcEE = Module["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE9__get_dayERiRS4_S4_RjRKNS_5ctypeIcEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE9__get_dayERiRS4_S4_RjRKNS_5ctypeIcEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE10__get_hourERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE10__get_hourERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE10__get_hourERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE10__get_yearERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE10__get_yearERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE10__get_yearERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_am_pmERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_am_pmERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_am_pmERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_monthERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_monthERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_monthERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_year4ERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_year4ERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11__get_year4ERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_dateES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_timeES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE11do_get_yearES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE12__get_minuteERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE12__get_minuteERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE12__get_minuteERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE12__get_secondERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE12__get_secondERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE12__get_secondERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_12_hourERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_12_hourERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_12_hourERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_percentERS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_percentERS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_percentERS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_weekdayERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_weekdayERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13__get_weekdayERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13do_date_orderEv = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13do_date_orderEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE13do_date_orderEv"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE14do_get_weekdayES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__get_monthnameERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__get_monthnameERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE15__get_monthnameERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE16do_get_monthnameES4_S4_RNS_8ios_baseERjP2tm"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__get_weekdaynameERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__get_weekdaynameERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__get_weekdaynameERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__get_white_spaceERS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__get_white_spaceERS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE17__get_white_spaceERS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE18__get_day_year_numERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE18__get_day_year_numERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE18__get_day_year_numERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE3getES4_S4_RNS_8ios_baseERjP2tmPKwSC_ = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE3getES4_S4_RNS_8ios_baseERjP2tmPKwSC_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE3getES4_S4_RNS_8ios_baseERjP2tmPKwSC_"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_RNS_8ios_baseERjP2tmcc"].apply(null, arguments);
});
var __ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE9__get_dayERiRS4_S4_RjRKNS_5ctypeIwEE = Module["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE9__get_dayERiRS4_S4_RjRKNS_5ctypeIwEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE9__get_dayERiRS4_S4_RjRKNS_5ctypeIwEE"].apply(null, arguments);
});
var __ZNKSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPK2tmcc = Module["__ZNKSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPK2tmcc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_RNS_8ios_baseEcPK2tmcc"].apply(null, arguments);
});
var __ZNKSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPK2tmcc = Module["__ZNKSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPK2tmcc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_RNS_8ios_baseEwPK2tmcc"].apply(null, arguments);
});
var __ZNKSt3__29__num_getIcE10__do_widenERNS_8ios_baseEPc = Module["__ZNKSt3__29__num_getIcE10__do_widenERNS_8ios_baseEPc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29__num_getIcE10__do_widenERNS_8ios_baseEPc"].apply(null, arguments);
});
var __ZNKSt3__29__num_getIcE12__do_widen_pERNS_8ios_baseEPc = Module["__ZNKSt3__29__num_getIcE12__do_widen_pERNS_8ios_baseEPc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29__num_getIcE12__do_widen_pERNS_8ios_baseEPc"].apply(null, arguments);
});
var __ZNKSt3__29__num_getIwE10__do_widenERNS_8ios_baseEPw = Module["__ZNKSt3__29__num_getIwE10__do_widenERNS_8ios_baseEPw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29__num_getIwE10__do_widenERNS_8ios_baseEPw"].apply(null, arguments);
});
var __ZNKSt3__29__num_getIwE12__do_widen_pIwEEPKT_RNS_8ios_baseEPS3_ = Module["__ZNKSt3__29__num_getIwE12__do_widen_pIwEEPKT_RNS_8ios_baseEPS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29__num_getIwE12__do_widen_pIwEEPKT_RNS_8ios_baseEPS3_"].apply(null, arguments);
});
var __ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIcS3_NS_9allocatorIcEEEE = Module["__ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIcS3_NS_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIcS3_NS_9allocatorIcEEEE"].apply(null, arguments);
});
var __ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe = Module["__ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe"].apply(null, arguments);
});
var __ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIwS3_NS_9allocatorIwEEEE = Module["__ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIwS3_NS_9allocatorIwEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRNS_12basic_stringIwS3_NS_9allocatorIwEEEE"].apply(null, arguments);
});
var __ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe = Module["__ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_getES4_S4_bRNS_8ios_baseERjRe"].apply(null, arguments);
});
var __ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEcRKNS_12basic_stringIcS3_NS_9allocatorIcEEEE = Module["__ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEcRKNS_12basic_stringIcS3_NS_9allocatorIcEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEcRKNS_12basic_stringIcS3_NS_9allocatorIcEEEE"].apply(null, arguments);
});
var __ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEce = Module["__ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEce"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEE6do_putES4_bRNS_8ios_baseEce"].apply(null, arguments);
});
var __ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwRKNS_12basic_stringIwS3_NS_9allocatorIwEEEE = Module["__ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwRKNS_12basic_stringIwS3_NS_9allocatorIwEEEE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwRKNS_12basic_stringIwS3_NS_9allocatorIwEEEE"].apply(null, arguments);
});
var __ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwe = Module["__ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEE6do_putES4_bRNS_8ios_baseEwe"].apply(null, arguments);
});
var __ZNKSt9bad_alloc4whatEv = Module["__ZNKSt9bad_alloc4whatEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNKSt9bad_alloc4whatEv"].apply(null, arguments);
});
var __ZNSt11logic_errorC2EPKc = Module["__ZNSt11logic_errorC2EPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt11logic_errorC2EPKc"].apply(null, arguments);
});
var __ZNSt11logic_errorD0Ev = Module["__ZNSt11logic_errorD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt11logic_errorD0Ev"].apply(null, arguments);
});
var __ZNSt11logic_errorD2Ev = Module["__ZNSt11logic_errorD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt11logic_errorD2Ev"].apply(null, arguments);
});
var __ZNSt12length_errorD0Ev = Module["__ZNSt12length_errorD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt12length_errorD0Ev"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIcE5imbueERKNS_6localeE = Module["__ZNSt3__210__stdinbufIcE5imbueERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIcE5imbueERKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIcE5uflowEv = Module["__ZNSt3__210__stdinbufIcE5uflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIcE5uflowEv"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIcE9__getcharEb = Module["__ZNSt3__210__stdinbufIcE9__getcharEb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIcE9__getcharEb"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIcE9pbackfailEi = Module["__ZNSt3__210__stdinbufIcE9pbackfailEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIcE9pbackfailEi"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIcE9underflowEv = Module["__ZNSt3__210__stdinbufIcE9underflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIcE9underflowEv"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIcEC2EP8_IO_FILEP11__mbstate_t = Module["__ZNSt3__210__stdinbufIcEC2EP8_IO_FILEP11__mbstate_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIcEC2EP8_IO_FILEP11__mbstate_t"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIcED0Ev = Module["__ZNSt3__210__stdinbufIcED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIcED0Ev"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIwE5imbueERKNS_6localeE = Module["__ZNSt3__210__stdinbufIwE5imbueERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIwE5imbueERKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIwE5uflowEv = Module["__ZNSt3__210__stdinbufIwE5uflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIwE5uflowEv"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIwE9__getcharEb = Module["__ZNSt3__210__stdinbufIwE9__getcharEb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIwE9__getcharEb"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIwE9pbackfailEj = Module["__ZNSt3__210__stdinbufIwE9pbackfailEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIwE9pbackfailEj"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIwE9underflowEv = Module["__ZNSt3__210__stdinbufIwE9underflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIwE9underflowEv"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIwEC2EP8_IO_FILEP11__mbstate_t = Module["__ZNSt3__210__stdinbufIwEC2EP8_IO_FILEP11__mbstate_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIwEC2EP8_IO_FILEP11__mbstate_t"].apply(null, arguments);
});
var __ZNSt3__210__stdinbufIwED0Ev = Module["__ZNSt3__210__stdinbufIwED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__stdinbufIwED0Ev"].apply(null, arguments);
});
var __ZNSt3__210__time_putD2Ev = Module["__ZNSt3__210__time_putD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210__time_putD2Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIcLb0EED0Ev = Module["__ZNSt3__210moneypunctIcLb0EED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIcLb0EED0Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIcLb0EED2Ev = Module["__ZNSt3__210moneypunctIcLb0EED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIcLb0EED2Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIcLb1EED0Ev = Module["__ZNSt3__210moneypunctIcLb1EED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIcLb1EED0Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIcLb1EED2Ev = Module["__ZNSt3__210moneypunctIcLb1EED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIcLb1EED2Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIwLb0EED0Ev = Module["__ZNSt3__210moneypunctIwLb0EED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIwLb0EED0Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIwLb0EED2Ev = Module["__ZNSt3__210moneypunctIwLb0EED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIwLb0EED2Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIwLb1EED0Ev = Module["__ZNSt3__210moneypunctIwLb1EED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIwLb1EED0Ev"].apply(null, arguments);
});
var __ZNSt3__210moneypunctIwLb1EED2Ev = Module["__ZNSt3__210moneypunctIwLb1EED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__210moneypunctIwLb1EED2Ev"].apply(null, arguments);
});
var __ZNSt3__211__call_onceERVmPvPFvS2_E = Module["__ZNSt3__211__call_onceERVmPvPFvS2_E"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__call_onceERVmPvPFvS2_E"].apply(null, arguments);
});
var __ZNSt3__211__money_getIcE13__gather_infoEbRKNS_6localeERNS_10money_base7patternERcS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESF_SF_SF_Ri = Module["__ZNSt3__211__money_getIcE13__gather_infoEbRKNS_6localeERNS_10money_base7patternERcS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESF_SF_SF_Ri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__money_getIcE13__gather_infoEbRKNS_6localeERNS_10money_base7patternERcS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESF_SF_SF_Ri"].apply(null, arguments);
});
var __ZNSt3__211__money_getIwE13__gather_infoEbRKNS_6localeERNS_10money_base7patternERwS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS9_IwNSA_IwEENSC_IwEEEESJ_SJ_Ri = Module["__ZNSt3__211__money_getIwE13__gather_infoEbRKNS_6localeERNS_10money_base7patternERwS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS9_IwNSA_IwEENSC_IwEEEESJ_SJ_Ri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__money_getIwE13__gather_infoEbRKNS_6localeERNS_10money_base7patternERwS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS9_IwNSA_IwEENSC_IwEEEESJ_SJ_Ri"].apply(null, arguments);
});
var __ZNSt3__211__money_putIcE13__gather_infoEbbRKNS_6localeERNS_10money_base7patternERcS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESF_SF_Ri = Module["__ZNSt3__211__money_putIcE13__gather_infoEbbRKNS_6localeERNS_10money_base7patternERcS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESF_SF_Ri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__money_putIcE13__gather_infoEbbRKNS_6localeERNS_10money_base7patternERcS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESF_SF_Ri"].apply(null, arguments);
});
var __ZNSt3__211__money_putIcE8__formatEPcRS2_S3_jPKcS5_RKNS_5ctypeIcEEbRKNS_10money_base7patternEccRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESL_SL_i = Module["__ZNSt3__211__money_putIcE8__formatEPcRS2_S3_jPKcS5_RKNS_5ctypeIcEEbRKNS_10money_base7patternEccRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESL_SL_i"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__money_putIcE8__formatEPcRS2_S3_jPKcS5_RKNS_5ctypeIcEEbRKNS_10money_base7patternEccRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESL_SL_i"].apply(null, arguments);
});
var __ZNSt3__211__money_putIwE13__gather_infoEbbRKNS_6localeERNS_10money_base7patternERwS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS9_IwNSA_IwEENSC_IwEEEESJ_Ri = Module["__ZNSt3__211__money_putIwE13__gather_infoEbbRKNS_6localeERNS_10money_base7patternERwS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS9_IwNSA_IwEENSC_IwEEEESJ_Ri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__money_putIwE13__gather_infoEbbRKNS_6localeERNS_10money_base7patternERwS8_RNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS9_IwNSA_IwEENSC_IwEEEESJ_Ri"].apply(null, arguments);
});
var __ZNSt3__211__money_putIwE8__formatEPwRS2_S3_jPKwS5_RKNS_5ctypeIwEEbRKNS_10money_base7patternEwwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNSE_IwNSF_IwEENSH_IwEEEESQ_i = Module["__ZNSt3__211__money_putIwE8__formatEPwRS2_S3_jPKwS5_RKNS_5ctypeIwEEbRKNS_10money_base7patternEwwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNSE_IwNSF_IwEENSH_IwEEEESQ_i"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__money_putIwE8__formatEPwRS2_S3_jPKwS5_RKNS_5ctypeIwEEbRKNS_10money_base7patternEwwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKNSE_IwNSF_IwEENSH_IwEEEESQ_i"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIcE4syncEv = Module["__ZNSt3__211__stdoutbufIcE4syncEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIcE4syncEv"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIcE5imbueERKNS_6localeE = Module["__ZNSt3__211__stdoutbufIcE5imbueERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIcE5imbueERKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIcE6xsputnEPKcl = Module["__ZNSt3__211__stdoutbufIcE6xsputnEPKcl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIcE6xsputnEPKcl"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIcE8overflowEi = Module["__ZNSt3__211__stdoutbufIcE8overflowEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIcE8overflowEi"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIcEC2EP8_IO_FILEP11__mbstate_t = Module["__ZNSt3__211__stdoutbufIcEC2EP8_IO_FILEP11__mbstate_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIcEC2EP8_IO_FILEP11__mbstate_t"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIcED0Ev = Module["__ZNSt3__211__stdoutbufIcED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIcED0Ev"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIwE4syncEv = Module["__ZNSt3__211__stdoutbufIwE4syncEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIwE4syncEv"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIwE5imbueERKNS_6localeE = Module["__ZNSt3__211__stdoutbufIwE5imbueERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIwE5imbueERKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIwE6xsputnEPKwl = Module["__ZNSt3__211__stdoutbufIwE6xsputnEPKwl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIwE6xsputnEPKwl"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIwE8overflowEj = Module["__ZNSt3__211__stdoutbufIwE8overflowEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIwE8overflowEj"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIwEC2EP8_IO_FILEP11__mbstate_t = Module["__ZNSt3__211__stdoutbufIwEC2EP8_IO_FILEP11__mbstate_t"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIwEC2EP8_IO_FILEP11__mbstate_t"].apply(null, arguments);
});
var __ZNSt3__211__stdoutbufIwED0Ev = Module["__ZNSt3__211__stdoutbufIwED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211__stdoutbufIwED0Ev"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE11eq_int_typeEii = Module["__ZNSt3__211char_traitsIcE11eq_int_typeEii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE11eq_int_typeEii"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE11to_int_typeEc = Module["__ZNSt3__211char_traitsIcE11to_int_typeEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE11to_int_typeEc"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE12to_char_typeEi = Module["__ZNSt3__211char_traitsIcE12to_char_typeEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE12to_char_typeEi"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE3eofEv = Module["__ZNSt3__211char_traitsIcE3eofEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE3eofEv"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE4copyEPcPKcm = Module["__ZNSt3__211char_traitsIcE4copyEPcPKcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE4copyEPcPKcm"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE4moveEPcPKcm = Module["__ZNSt3__211char_traitsIcE4moveEPcPKcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE4moveEPcPKcm"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE6assignEPcmc = Module["__ZNSt3__211char_traitsIcE6assignEPcmc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE6assignEPcmc"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE6assignERcRKc = Module["__ZNSt3__211char_traitsIcE6assignERcRKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE6assignERcRKc"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE6lengthEPKc = Module["__ZNSt3__211char_traitsIcE6lengthEPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE6lengthEPKc"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE7compareEPKcS3_m = Module["__ZNSt3__211char_traitsIcE7compareEPKcS3_m"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE7compareEPKcS3_m"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIcE7not_eofEi = Module["__ZNSt3__211char_traitsIcE7not_eofEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIcE7not_eofEi"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE11eq_int_typeEjj = Module["__ZNSt3__211char_traitsIwE11eq_int_typeEjj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE11eq_int_typeEjj"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE11to_int_typeEw = Module["__ZNSt3__211char_traitsIwE11to_int_typeEw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE11to_int_typeEw"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE12to_char_typeEj = Module["__ZNSt3__211char_traitsIwE12to_char_typeEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE12to_char_typeEj"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE3eofEv = Module["__ZNSt3__211char_traitsIwE3eofEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE3eofEv"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE4copyEPwPKwm = Module["__ZNSt3__211char_traitsIwE4copyEPwPKwm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE4copyEPwPKwm"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE4moveEPwPKwm = Module["__ZNSt3__211char_traitsIwE4moveEPwPKwm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE4moveEPwPKwm"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE6assignEPwmw = Module["__ZNSt3__211char_traitsIwE6assignEPwmw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE6assignEPwmw"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE6assignERwRKw = Module["__ZNSt3__211char_traitsIwE6assignERwRKw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE6assignERwRKw"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE6lengthEPKw = Module["__ZNSt3__211char_traitsIwE6lengthEPKw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE6lengthEPKw"].apply(null, arguments);
});
var __ZNSt3__211char_traitsIwE7not_eofEj = Module["__ZNSt3__211char_traitsIwE7not_eofEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__211char_traitsIwE7not_eofEj"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_111__fake_bindC2EMNS_6locale2idEFvvEPS3_ = Module["__ZNSt3__212_GLOBAL__N_111__fake_bindC2EMNS_6locale2idEFvvEPS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_111__fake_bindC2EMNS_6locale2idEFvvEPS3_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIcLb0EEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIcLb0EEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIcLb0EEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIcLb1EEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIcLb1EEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIcLb1EEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIwLb0EEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIwLb0EEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIwLb0EEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIwLb1EEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIwLb1EEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_10moneypunctIwLb1EEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_5ctypeIcEEDnbjEERT_T0_T1_T2_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_5ctypeIcEEDnbjEERT_T0_T1_T2_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_5ctypeIcEEDnbjEERT_T0_T1_T2_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_5ctypeIwEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_5ctypeIwEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_5ctypeIwEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_6locale5__impEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_6locale5__impEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_6locale5__impEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIDic11__mbstate_tEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIDic11__mbstate_tEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIDic11__mbstate_tEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIDsc11__mbstate_tEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIDsc11__mbstate_tEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIDsc11__mbstate_tEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIcc11__mbstate_tEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIcc11__mbstate_tEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIcc11__mbstate_tEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIwc11__mbstate_tEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIwc11__mbstate_tEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7codecvtIwc11__mbstate_tEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7collateIcEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7collateIcEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7collateIcEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7collateIwEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7collateIwEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7collateIwEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_7num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_7num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_7num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8messagesIcEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8messagesIcEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8messagesIcEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8messagesIwEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8messagesIwEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8messagesIwEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8numpunctIcEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8numpunctIcEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8numpunctIcEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8numpunctIwEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8numpunctIwEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8numpunctIwEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_8time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_8time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_8time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_9money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_9money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_9money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_9money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_9money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_9money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_9money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_9money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_9money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_14makeINS_9money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_ = Module["__ZNSt3__212_GLOBAL__N_14makeINS_9money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_14makeINS_9money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEjEERT_T0_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_17countofIcEEmPKT_S4_ = Module["__ZNSt3__212_GLOBAL__N_17countofIcEEmPKT_S4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_17countofIcEEmPKT_S4_"].apply(null, arguments);
});
var __ZNSt3__212_GLOBAL__N_17countofIwEEmPKT_S4_ = Module["__ZNSt3__212_GLOBAL__N_17countofIwEEmPKT_S4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212_GLOBAL__N_17countofIwEEmPKT_S4_"].apply(null, arguments);
});
var __ZNSt3__212__do_nothingEPv = Module["__ZNSt3__212__do_nothingEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212__do_nothingEPv"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE21__grow_by_and_replaceEmmmmmmPKc = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE21__grow_by_and_replaceEmmmmmmPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE21__grow_by_and_replaceEmmmmmmPKc"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE23__append_forward_unsafeIPcEERS5_T_S9_ = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE23__append_forward_unsafeIPcEERS5_T_S9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE23__append_forward_unsafeIPcEERS5_T_S9_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEmc = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEmc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEmc"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESA_SA_ = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESA_SA_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESA_SA_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initIPcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeES9_S9_ = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initIPcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeES9_S9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initIPcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeES9_S9_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6resizeEmc = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6resizeEmc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6resizeEmc"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2ERKS5_ = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2ERKS5_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2ERKS5_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEaSERKS5_ = Module["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEaSERKS5_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEaSERKS5_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE21__grow_by_and_replaceEmmmmmmPKw = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE21__grow_by_and_replaceEmmmmmmPKw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE21__grow_by_and_replaceEmmmmmmPKw"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE23__append_forward_unsafeIPwEERS5_T_S9_ = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE23__append_forward_unsafeIPwEERS5_T_S9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE23__append_forward_unsafeIPwEERS5_T_S9_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initEPKwm = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initEPKwm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initEPKwm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initEmw = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initEmw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initEmw"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initIPKwEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESA_SA_ = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initIPKwEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESA_SA_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initIPKwEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESA_SA_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initIPwEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeES9_S9_ = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initIPwEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeES9_S9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6__initIPwEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeES9_S9_"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6appendEPKwm = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6appendEPKwm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6appendEPKwm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6assignEPKw = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6assignEPKw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6assignEPKw"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6assignEPKwm = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6assignEPKwm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6assignEPKwm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9__grow_byEmmmmmm = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9__grow_byEmmmmmm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9__grow_byEmmmmmm"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw"].apply(null, arguments);
});
var __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__213__vector_baseIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEED2Ev = Module["__ZNSt3__213__vector_baseIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213__vector_baseIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev = Module["__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev = Module["__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED2Ev = Module["__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_istreamIcNS_11char_traitsIcEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev = Module["__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev = Module["__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED2Ev = Module["__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_istreamIwNS_11char_traitsIwEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE3putEc = Module["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE3putEc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE3putEc"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE5flushEv = Module["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE5flushEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE5flushEv"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE6sentryC2ERS3_ = Module["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE6sentryC2ERS3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE6sentryC2ERS3_"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE6sentryD2Ev = Module["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE6sentryD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEE6sentryD2Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev = Module["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev = Module["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED2Ev = Module["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIcNS_11char_traitsIcEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev = Module["__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev = Module["__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev"].apply(null, arguments);
});
var __ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED2Ev = Module["__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__213basic_ostreamIwNS_11char_traitsIwEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__214__num_get_base10__get_baseERNS_8ios_baseE = Module["__ZNSt3__214__num_get_base10__get_baseERNS_8ios_baseE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__num_get_base10__get_baseERNS_8ios_baseE"].apply(null, arguments);
});
var __ZNSt3__214__num_put_base12__format_intEPcPKcbj = Module["__ZNSt3__214__num_put_base12__format_intEPcPKcbj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__num_put_base12__format_intEPcPKcbj"].apply(null, arguments);
});
var __ZNSt3__214__num_put_base14__format_floatEPcPKcj = Module["__ZNSt3__214__num_put_base14__format_floatEPcPKcj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__num_put_base14__format_floatEPcPKcj"].apply(null, arguments);
});
var __ZNSt3__214__num_put_base18__identify_paddingEPcS1_RKNS_8ios_baseE = Module["__ZNSt3__214__num_put_base18__identify_paddingEPcS1_RKNS_8ios_baseE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__num_put_base18__identify_paddingEPcS1_RKNS_8ios_baseE"].apply(null, arguments);
});
var __ZNSt3__214__ptr_in_rangeIcEEbPKT_S3_S3_ = Module["__ZNSt3__214__ptr_in_rangeIcEEbPKT_S3_S3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__ptr_in_rangeIcEEbPKT_S3_S3_"].apply(null, arguments);
});
var __ZNSt3__214__ptr_in_rangeIwEEbPKT_S3_S3_ = Module["__ZNSt3__214__ptr_in_rangeIwEEbPKT_S3_S3_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__ptr_in_rangeIwEEbPKT_S3_S3_"].apply(null, arguments);
});
var __ZNSt3__214__scan_keywordINS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEPKNS_12basic_stringIcS3_NS_9allocatorIcEEEENS_5ctypeIcEEEET0_RT_SE_SD_SD_RKT1_Rjb = Module["__ZNSt3__214__scan_keywordINS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEPKNS_12basic_stringIcS3_NS_9allocatorIcEEEENS_5ctypeIcEEEET0_RT_SE_SD_SD_RKT1_Rjb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__scan_keywordINS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEPKNS_12basic_stringIcS3_NS_9allocatorIcEEEENS_5ctypeIcEEEET0_RT_SE_SD_SD_RKT1_Rjb"].apply(null, arguments);
});
var __ZNSt3__214__scan_keywordINS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEPKNS_12basic_stringIwS3_NS_9allocatorIwEEEENS_5ctypeIwEEEET0_RT_SE_SD_SD_RKT1_Rjb = Module["__ZNSt3__214__scan_keywordINS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEPKNS_12basic_stringIwS3_NS_9allocatorIwEEEENS_5ctypeIwEEEET0_RT_SE_SD_SD_RKT1_Rjb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__scan_keywordINS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEPKNS_12basic_stringIwS3_NS_9allocatorIwEEEENS_5ctypeIwEEEET0_RT_SE_SD_SD_RKT1_Rjb"].apply(null, arguments);
});
var __ZNSt3__214__shared_countD2Ev = Module["__ZNSt3__214__shared_countD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__shared_countD2Ev"].apply(null, arguments);
});
var __ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEE18__construct_at_endEm = Module["__ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEE18__construct_at_endEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEE18__construct_at_endEm"].apply(null, arguments);
});
var __ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEEC2EmmS6_ = Module["__ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEEC2EmmS6_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEEC2EmmS6_"].apply(null, arguments);
});
var __ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEED2Ev = Module["__ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__214__split_bufferIPNS_6locale5facetERNS_15__sso_allocatorIS3_Lm28EEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__215__num_get_floatIdEET_PKcS3_Rj = Module["__ZNSt3__215__num_get_floatIdEET_PKcS3_Rj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215__num_get_floatIdEET_PKcS3_Rj"].apply(null, arguments);
});
var __ZNSt3__215__num_get_floatIeEET_PKcS3_Rj = Module["__ZNSt3__215__num_get_floatIeEET_PKcS3_Rj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215__num_get_floatIeEET_PKcS3_Rj"].apply(null, arguments);
});
var __ZNSt3__215__num_get_floatIfEET_PKcS3_Rj = Module["__ZNSt3__215__num_get_floatIfEET_PKcS3_Rj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215__num_get_floatIfEET_PKcS3_Rj"].apply(null, arguments);
});
var __ZNSt3__215__refstring_imp12_GLOBAL__N_113data_from_repEPNS1_9_Rep_baseE = Module["__ZNSt3__215__refstring_imp12_GLOBAL__N_113data_from_repEPNS1_9_Rep_baseE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215__refstring_imp12_GLOBAL__N_113data_from_repEPNS1_9_Rep_baseE"].apply(null, arguments);
});
var __ZNSt3__215__refstring_imp12_GLOBAL__N_113rep_from_dataEPKc = Module["__ZNSt3__215__refstring_imp12_GLOBAL__N_113rep_from_dataEPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215__refstring_imp12_GLOBAL__N_113rep_from_dataEPKc"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE4syncEv = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE4syncEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE4syncEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5imbueERKNS_6localeE = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5imbueERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5imbueERKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5uflowEv = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5uflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE5uflowEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6setbufEPcl = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6setbufEPcl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6setbufEPcl"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsgetnEPcl = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsgetnEPcl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsgetnEPcl"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsputnEPKcl = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsputnEPKcl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE6xsputnEPKcl"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekoffExNS_8ios_base7seekdirEj = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekoffExNS_8ios_base7seekdirEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekoffExNS_8ios_base7seekdirEj"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekposENS_4fposI11__mbstate_tEEj = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekposENS_4fposI11__mbstate_tEEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE7seekposENS_4fposI11__mbstate_tEEj"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE8overflowEi = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE8overflowEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE8overflowEi"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9pbackfailEi = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9pbackfailEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9pbackfailEi"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9showmanycEv = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9showmanycEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9showmanycEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9underflowEv = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9underflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEE9underflowEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEEC2Ev = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEEC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEEC2Ev"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED0Ev = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED2Ev = Module["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIcNS_11char_traitsIcEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE4syncEv = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE4syncEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE4syncEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5imbueERKNS_6localeE = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5imbueERKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5imbueERKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5uflowEv = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5uflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE5uflowEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6setbufEPwl = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6setbufEPwl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6setbufEPwl"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsgetnEPwl = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsgetnEPwl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsgetnEPwl"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsputnEPKwl = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsputnEPKwl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE6xsputnEPKwl"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekoffExNS_8ios_base7seekdirEj = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekoffExNS_8ios_base7seekdirEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekoffExNS_8ios_base7seekdirEj"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekposENS_4fposI11__mbstate_tEEj = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekposENS_4fposI11__mbstate_tEEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE7seekposENS_4fposI11__mbstate_tEEj"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE8overflowEj = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE8overflowEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE8overflowEj"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9pbackfailEj = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9pbackfailEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9pbackfailEj"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9showmanycEv = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9showmanycEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9showmanycEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9underflowEv = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9underflowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEE9underflowEv"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEEC2Ev = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEEC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEEC2Ev"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED0Ev = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED2Ev = Module["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__215basic_streambufIwNS_11char_traitsIwEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__216__check_groupingERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjS8_Rj = Module["__ZNSt3__216__check_groupingERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjS8_Rj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__216__check_groupingERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjS8_Rj"].apply(null, arguments);
});
var __ZNSt3__216__narrow_to_utf8ILm32EED0Ev = Module["__ZNSt3__216__narrow_to_utf8ILm32EED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__216__narrow_to_utf8ILm32EED0Ev"].apply(null, arguments);
});
var __ZNSt3__216__pad_and_outputIcNS_11char_traitsIcEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_ = Module["__ZNSt3__216__pad_and_outputIcNS_11char_traitsIcEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__216__pad_and_outputIcNS_11char_traitsIcEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_"].apply(null, arguments);
});
var __ZNSt3__216__pad_and_outputIwNS_11char_traitsIwEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_ = Module["__ZNSt3__216__pad_and_outputIwNS_11char_traitsIwEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__216__pad_and_outputIwNS_11char_traitsIwEEEENS_19ostreambuf_iteratorIT_T0_EES6_PKS4_S8_S8_RNS_8ios_baseES4_"].apply(null, arguments);
});
var __ZNSt3__217_DeallocateCaller27__do_deallocate_handle_sizeEPvm = Module["__ZNSt3__217_DeallocateCaller27__do_deallocate_handle_sizeEPvm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__217_DeallocateCaller27__do_deallocate_handle_sizeEPvm"].apply(null, arguments);
});
var __ZNSt3__217_DeallocateCaller9__do_callEPv = Module["__ZNSt3__217_DeallocateCaller9__do_callEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__217_DeallocateCaller9__do_callEPv"].apply(null, arguments);
});
var __ZNSt3__217__call_once_proxyINS_5tupleIJONS_12_GLOBAL__N_111__fake_bindEEEEEEvPv = Module["__ZNSt3__217__call_once_proxyINS_5tupleIJONS_12_GLOBAL__N_111__fake_bindEEEEEEvPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__217__call_once_proxyINS_5tupleIJONS_12_GLOBAL__N_111__fake_bindEEEEEEvPv"].apply(null, arguments);
});
var __ZNSt3__217__libcpp_sscanf_lEPKcP15__locale_structS1_z = Module["__ZNSt3__217__libcpp_sscanf_lEPKcP15__locale_structS1_z"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__217__libcpp_sscanf_lEPKcP15__locale_structS1_z"].apply(null, arguments);
});
var __ZNSt3__217__widen_from_utf8ILm32EED0Ev = Module["__ZNSt3__217__widen_from_utf8ILm32EED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__217__widen_from_utf8ILm32EED0Ev"].apply(null, arguments);
});
var __ZNSt3__218__libcpp_refstringC2EPKc = Module["__ZNSt3__218__libcpp_refstringC2EPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__218__libcpp_refstringC2EPKc"].apply(null, arguments);
});
var __ZNSt3__218__libcpp_refstringD2Ev = Module["__ZNSt3__218__libcpp_refstringD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__218__libcpp_refstringD2Ev"].apply(null, arguments);
});
var __ZNSt3__219__double_or_nothingIcEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_ = Module["__ZNSt3__219__double_or_nothingIcEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__219__double_or_nothingIcEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_"].apply(null, arguments);
});
var __ZNSt3__219__double_or_nothingIjEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_ = Module["__ZNSt3__219__double_or_nothingIjEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__219__double_or_nothingIjEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_"].apply(null, arguments);
});
var __ZNSt3__219__double_or_nothingIwEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_ = Module["__ZNSt3__219__double_or_nothingIwEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__219__double_or_nothingIwEEvRNS_10unique_ptrIT_PFvPvEEERPS2_S9_"].apply(null, arguments);
});
var __ZNSt3__219__libcpp_asprintf_lEPPcP15__locale_structPKcz = Module["__ZNSt3__219__libcpp_asprintf_lEPPcP15__locale_structPKcz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__219__libcpp_asprintf_lEPPcP15__locale_structPKcz"].apply(null, arguments);
});
var __ZNSt3__219__libcpp_snprintf_lEPcmP15__locale_structPKcz = Module["__ZNSt3__219__libcpp_snprintf_lEPcmP15__locale_structPKcz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__219__libcpp_snprintf_lEPcmP15__locale_structPKcz"].apply(null, arguments);
});
var __ZNSt3__220__get_up_to_n_digitsIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEiRT0_S5_RjRKNS_5ctypeIT_EEi = Module["__ZNSt3__220__get_up_to_n_digitsIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEiRT0_S5_RjRKNS_5ctypeIT_EEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__220__get_up_to_n_digitsIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEiRT0_S5_RjRKNS_5ctypeIT_EEi"].apply(null, arguments);
});
var __ZNSt3__220__get_up_to_n_digitsIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEiRT0_S5_RjRKNS_5ctypeIT_EEi = Module["__ZNSt3__220__get_up_to_n_digitsIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEiRT0_S5_RjRKNS_5ctypeIT_EEi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__220__get_up_to_n_digitsIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEiRT0_S5_RjRKNS_5ctypeIT_EEi"].apply(null, arguments);
});
var __ZNSt3__220__time_get_c_storageIcEC2Ev = Module["__ZNSt3__220__time_get_c_storageIcEC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__220__time_get_c_storageIcEC2Ev"].apply(null, arguments);
});
var __ZNSt3__220__time_get_c_storageIwEC2Ev = Module["__ZNSt3__220__time_get_c_storageIwEC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__220__time_get_c_storageIwEC2Ev"].apply(null, arguments);
});
var __ZNSt3__221__throw_runtime_errorEPKc = Module["__ZNSt3__221__throw_runtime_errorEPKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__221__throw_runtime_errorEPKc"].apply(null, arguments);
});
var __ZNSt3__224__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m = Module["__ZNSt3__224__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__224__put_character_sequenceIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_PKS4_m"].apply(null, arguments);
});
var __ZNSt3__225__num_get_signed_integralIlEET_PKcS3_Rji = Module["__ZNSt3__225__num_get_signed_integralIlEET_PKcS3_Rji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__225__num_get_signed_integralIlEET_PKcS3_Rji"].apply(null, arguments);
});
var __ZNSt3__225__num_get_signed_integralIxEET_PKcS3_Rji = Module["__ZNSt3__225__num_get_signed_integralIxEET_PKcS3_Rji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__225__num_get_signed_integralIxEET_PKcS3_Rji"].apply(null, arguments);
});
var __ZNSt3__227__num_get_unsigned_integralIjEET_PKcS3_Rji = Module["__ZNSt3__227__num_get_unsigned_integralIjEET_PKcS3_Rji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__227__num_get_unsigned_integralIjEET_PKcS3_Rji"].apply(null, arguments);
});
var __ZNSt3__227__num_get_unsigned_integralImEET_PKcS3_Rji = Module["__ZNSt3__227__num_get_unsigned_integralImEET_PKcS3_Rji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__227__num_get_unsigned_integralImEET_PKcS3_Rji"].apply(null, arguments);
});
var __ZNSt3__227__num_get_unsigned_integralItEET_PKcS3_Rji = Module["__ZNSt3__227__num_get_unsigned_integralItEET_PKcS3_Rji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__227__num_get_unsigned_integralItEET_PKcS3_Rji"].apply(null, arguments);
});
var __ZNSt3__227__num_get_unsigned_integralIyEET_PKcS3_Rji = Module["__ZNSt3__227__num_get_unsigned_integralIyEET_PKcS3_Rji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__227__num_get_unsigned_integralIyEET_PKcS3_Rji"].apply(null, arguments);
});
var __ZNSt3__25ctypeIcE13classic_tableEv = Module["__ZNSt3__25ctypeIcE13classic_tableEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__25ctypeIcE13classic_tableEv"].apply(null, arguments);
});
var __ZNSt3__25ctypeIcE21__classic_lower_tableEv = Module["__ZNSt3__25ctypeIcE21__classic_lower_tableEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__25ctypeIcE21__classic_lower_tableEv"].apply(null, arguments);
});
var __ZNSt3__25ctypeIcE21__classic_upper_tableEv = Module["__ZNSt3__25ctypeIcE21__classic_upper_tableEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__25ctypeIcE21__classic_upper_tableEv"].apply(null, arguments);
});
var __ZNSt3__25ctypeIcEC2EPKtbm = Module["__ZNSt3__25ctypeIcEC2EPKtbm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__25ctypeIcEC2EPKtbm"].apply(null, arguments);
});
var __ZNSt3__25ctypeIcED0Ev = Module["__ZNSt3__25ctypeIcED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__25ctypeIcED0Ev"].apply(null, arguments);
});
var __ZNSt3__25ctypeIcED2Ev = Module["__ZNSt3__25ctypeIcED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__25ctypeIcED2Ev"].apply(null, arguments);
});
var __ZNSt3__25ctypeIwED0Ev = Module["__ZNSt3__25ctypeIwED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__25ctypeIwED0Ev"].apply(null, arguments);
});
var __ZNSt3__26__clocEv = Module["__ZNSt3__26__clocEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26__clocEv"].apply(null, arguments);
});
var __ZNSt3__26locale2id5__getEv = Module["__ZNSt3__26locale2id5__getEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale2id5__getEv"].apply(null, arguments);
});
var __ZNSt3__26locale2id6__initEv = Module["__ZNSt3__26locale2id6__initEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale2id6__initEv"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp11make_globalEv = Module["__ZNSt3__26locale5__imp11make_globalEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp11make_globalEv"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp12make_classicEv = Module["__ZNSt3__26locale5__imp12make_classicEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp12make_classicEv"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installEPNS0_5facetEl = Module["__ZNSt3__26locale5__imp7installEPNS0_5facetEl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installEPNS0_5facetEl"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_10moneypunctIcLb0EEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_10moneypunctIcLb0EEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_10moneypunctIcLb0EEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_10moneypunctIcLb1EEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_10moneypunctIcLb1EEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_10moneypunctIcLb1EEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_10moneypunctIwLb0EEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_10moneypunctIwLb0EEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_10moneypunctIwLb0EEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_10moneypunctIwLb1EEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_10moneypunctIwLb1EEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_10moneypunctIwLb1EEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_5ctypeIcEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_5ctypeIcEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_5ctypeIcEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_5ctypeIwEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_5ctypeIwEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_5ctypeIwEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7codecvtIDic11__mbstate_tEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7codecvtIDic11__mbstate_tEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7codecvtIDic11__mbstate_tEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7codecvtIDsc11__mbstate_tEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7codecvtIDsc11__mbstate_tEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7codecvtIDsc11__mbstate_tEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7codecvtIcc11__mbstate_tEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7codecvtIcc11__mbstate_tEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7codecvtIcc11__mbstate_tEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7codecvtIwc11__mbstate_tEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7codecvtIwc11__mbstate_tEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7codecvtIwc11__mbstate_tEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7collateIcEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7collateIcEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7collateIcEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7collateIwEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7collateIwEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7collateIwEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_7num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_7num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_7num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8messagesIcEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8messagesIcEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8messagesIcEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8messagesIwEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8messagesIwEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8messagesIwEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8numpunctIcEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8numpunctIcEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8numpunctIcEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8numpunctIwEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8numpunctIwEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8numpunctIwEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_8time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_8time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_8time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_9money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_9money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_9money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_9money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_9money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_9money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_9money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_9money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_9money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__imp7installINS_9money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_ = Module["__ZNSt3__26locale5__imp7installINS_9money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__imp7installINS_9money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEEEEvPT_"].apply(null, arguments);
});
var __ZNSt3__26locale5__impC2Em = Module["__ZNSt3__26locale5__impC2Em"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__impC2Em"].apply(null, arguments);
});
var __ZNSt3__26locale5__impD0Ev = Module["__ZNSt3__26locale5__impD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__impD0Ev"].apply(null, arguments);
});
var __ZNSt3__26locale5__impD2Ev = Module["__ZNSt3__26locale5__impD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5__impD2Ev"].apply(null, arguments);
});
var __ZNSt3__26locale5facet16__on_zero_sharedEv = Module["__ZNSt3__26locale5facet16__on_zero_sharedEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5facet16__on_zero_sharedEv"].apply(null, arguments);
});
var __ZNSt3__26locale5facetD0Ev = Module["__ZNSt3__26locale5facetD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5facetD0Ev"].apply(null, arguments);
});
var __ZNSt3__26locale5facetD2Ev = Module["__ZNSt3__26locale5facetD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale5facetD2Ev"].apply(null, arguments);
});
var __ZNSt3__26locale7classicEv = Module["__ZNSt3__26locale7classicEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale7classicEv"].apply(null, arguments);
});
var __ZNSt3__26locale8__globalEv = Module["__ZNSt3__26locale8__globalEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26locale8__globalEv"].apply(null, arguments);
});
var __ZNSt3__26localeC2ERKS0_ = Module["__ZNSt3__26localeC2ERKS0_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26localeC2ERKS0_"].apply(null, arguments);
});
var __ZNSt3__26localeC2Ev = Module["__ZNSt3__26localeC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26localeC2Ev"].apply(null, arguments);
});
var __ZNSt3__26localeD2Ev = Module["__ZNSt3__26localeD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26localeD2Ev"].apply(null, arguments);
});
var __ZNSt3__26vectorI24CallSessionNotifyHandlerNS_9allocatorIS1_EEE21__push_back_slow_pathIRKS1_EEvOT_ = Module["__ZNSt3__26vectorI24CallSessionNotifyHandlerNS_9allocatorIS1_EEE21__push_back_slow_pathIRKS1_EEvOT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorI24CallSessionNotifyHandlerNS_9allocatorIS1_EEE21__push_back_slow_pathIRKS1_EEvOT_"].apply(null, arguments);
});
var __ZNSt3__26vectorIP13HsCallSessionNS_9allocatorIS2_EEE21__push_back_slow_pathIRKS2_EEvOT_ = Module["__ZNSt3__26vectorIP13HsCallSessionNS_9allocatorIS2_EEE21__push_back_slow_pathIRKS2_EEvOT_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorIP13HsCallSessionNS_9allocatorIS2_EEE21__push_back_slow_pathIRKS2_EEvOT_"].apply(null, arguments);
});
var __ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE11__vallocateEm = Module["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE11__vallocateEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE11__vallocateEm"].apply(null, arguments);
});
var __ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE18__construct_at_endEm = Module["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE18__construct_at_endEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE18__construct_at_endEm"].apply(null, arguments);
});
var __ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE = Module["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE"].apply(null, arguments);
});
var __ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE6resizeEm = Module["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE6resizeEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE6resizeEm"].apply(null, arguments);
});
var __ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE8__appendEm = Module["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE8__appendEm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEE8__appendEm"].apply(null, arguments);
});
var __ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEEC2Em = Module["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEEC2Em"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__26vectorIPNS_6locale5facetENS_15__sso_allocatorIS3_Lm28EEEEC2Em"].apply(null, arguments);
});
var __ZNSt3__27codecvtIDic11__mbstate_tED0Ev = Module["__ZNSt3__27codecvtIDic11__mbstate_tED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27codecvtIDic11__mbstate_tED0Ev"].apply(null, arguments);
});
var __ZNSt3__27codecvtIDsc11__mbstate_tED0Ev = Module["__ZNSt3__27codecvtIDsc11__mbstate_tED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27codecvtIDsc11__mbstate_tED0Ev"].apply(null, arguments);
});
var __ZNSt3__27codecvtIcc11__mbstate_tED0Ev = Module["__ZNSt3__27codecvtIcc11__mbstate_tED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27codecvtIcc11__mbstate_tED0Ev"].apply(null, arguments);
});
var __ZNSt3__27codecvtIwc11__mbstate_tEC2Em = Module["__ZNSt3__27codecvtIwc11__mbstate_tEC2Em"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27codecvtIwc11__mbstate_tEC2Em"].apply(null, arguments);
});
var __ZNSt3__27codecvtIwc11__mbstate_tED0Ev = Module["__ZNSt3__27codecvtIwc11__mbstate_tED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27codecvtIwc11__mbstate_tED0Ev"].apply(null, arguments);
});
var __ZNSt3__27codecvtIwc11__mbstate_tED2Ev = Module["__ZNSt3__27codecvtIwc11__mbstate_tED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27codecvtIwc11__mbstate_tED2Ev"].apply(null, arguments);
});
var __ZNSt3__27collateIcED0Ev = Module["__ZNSt3__27collateIcED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27collateIcED0Ev"].apply(null, arguments);
});
var __ZNSt3__27collateIcED2Ev = Module["__ZNSt3__27collateIcED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27collateIcED2Ev"].apply(null, arguments);
});
var __ZNSt3__27collateIwED0Ev = Module["__ZNSt3__27collateIwED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27collateIwED0Ev"].apply(null, arguments);
});
var __ZNSt3__27collateIwED2Ev = Module["__ZNSt3__27collateIwED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27collateIwED2Ev"].apply(null, arguments);
});
var __ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev = Module["__ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev = Module["__ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev = Module["__ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev = Module["__ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev = Module["__ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev = Module["__ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev = Module["__ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev = Module["__ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__27num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__28ios_base16__call_callbacksENS0_5eventE = Module["__ZNSt3__28ios_base16__call_callbacksENS0_5eventE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28ios_base16__call_callbacksENS0_5eventE"].apply(null, arguments);
});
var __ZNSt3__28ios_base33__set_badbit_and_consider_rethrowEv = Module["__ZNSt3__28ios_base33__set_badbit_and_consider_rethrowEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28ios_base33__set_badbit_and_consider_rethrowEv"].apply(null, arguments);
});
var __ZNSt3__28ios_base4InitC2Ev = Module["__ZNSt3__28ios_base4InitC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28ios_base4InitC2Ev"].apply(null, arguments);
});
var __ZNSt3__28ios_base4initEPv = Module["__ZNSt3__28ios_base4initEPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28ios_base4initEPv"].apply(null, arguments);
});
var __ZNSt3__28ios_base5clearEj = Module["__ZNSt3__28ios_base5clearEj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28ios_base5clearEj"].apply(null, arguments);
});
var __ZNSt3__28ios_baseD0Ev = Module["__ZNSt3__28ios_baseD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28ios_baseD0Ev"].apply(null, arguments);
});
var __ZNSt3__28ios_baseD2Ev = Module["__ZNSt3__28ios_baseD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28ios_baseD2Ev"].apply(null, arguments);
});
var __ZNSt3__28messagesIcED0Ev = Module["__ZNSt3__28messagesIcED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28messagesIcED0Ev"].apply(null, arguments);
});
var __ZNSt3__28messagesIcED2Ev = Module["__ZNSt3__28messagesIcED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28messagesIcED2Ev"].apply(null, arguments);
});
var __ZNSt3__28messagesIwED0Ev = Module["__ZNSt3__28messagesIwED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28messagesIwED0Ev"].apply(null, arguments);
});
var __ZNSt3__28messagesIwED2Ev = Module["__ZNSt3__28messagesIwED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28messagesIwED2Ev"].apply(null, arguments);
});
var __ZNSt3__28numpunctIcEC2Em = Module["__ZNSt3__28numpunctIcEC2Em"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28numpunctIcEC2Em"].apply(null, arguments);
});
var __ZNSt3__28numpunctIcED0Ev = Module["__ZNSt3__28numpunctIcED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28numpunctIcED0Ev"].apply(null, arguments);
});
var __ZNSt3__28numpunctIcED2Ev = Module["__ZNSt3__28numpunctIcED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28numpunctIcED2Ev"].apply(null, arguments);
});
var __ZNSt3__28numpunctIwEC2Em = Module["__ZNSt3__28numpunctIwEC2Em"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28numpunctIwEC2Em"].apply(null, arguments);
});
var __ZNSt3__28numpunctIwED0Ev = Module["__ZNSt3__28numpunctIwED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28numpunctIwED0Ev"].apply(null, arguments);
});
var __ZNSt3__28numpunctIwED2Ev = Module["__ZNSt3__28numpunctIwED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28numpunctIwED2Ev"].apply(null, arguments);
});
var __ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev = Module["__ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev = Module["__ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev = Module["__ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev = Module["__ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev = Module["__ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev = Module["__ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev = Module["__ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev = Module["__ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__28time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__29__num_getIcE17__stage2_int_loopEciPcRS2_RjcRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSD_PKc = Module["__ZNSt3__29__num_getIcE17__stage2_int_loopEciPcRS2_RjcRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSD_PKc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIcE17__stage2_int_loopEciPcRS2_RjcRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSD_PKc"].apply(null, arguments);
});
var __ZNSt3__29__num_getIcE17__stage2_int_prepERNS_8ios_baseERc = Module["__ZNSt3__29__num_getIcE17__stage2_int_prepERNS_8ios_baseERc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIcE17__stage2_int_prepERNS_8ios_baseERc"].apply(null, arguments);
});
var __ZNSt3__29__num_getIcE19__stage2_float_loopEcRbRcPcRS4_ccRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSE_RjS4_ = Module["__ZNSt3__29__num_getIcE19__stage2_float_loopEcRbRcPcRS4_ccRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSE_RjS4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIcE19__stage2_float_loopEcRbRcPcRS4_ccRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSE_RjS4_"].apply(null, arguments);
});
var __ZNSt3__29__num_getIcE19__stage2_float_prepERNS_8ios_baseEPcRcS5_ = Module["__ZNSt3__29__num_getIcE19__stage2_float_prepERNS_8ios_baseEPcRcS5_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIcE19__stage2_float_prepERNS_8ios_baseEPcRcS5_"].apply(null, arguments);
});
var __ZNSt3__29__num_getIwE17__stage2_int_loopEwiPcRS2_RjwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSD_PKw = Module["__ZNSt3__29__num_getIwE17__stage2_int_loopEwiPcRS2_RjwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSD_PKw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIwE17__stage2_int_loopEwiPcRS2_RjwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSD_PKw"].apply(null, arguments);
});
var __ZNSt3__29__num_getIwE17__stage2_int_prepERNS_8ios_baseERw = Module["__ZNSt3__29__num_getIwE17__stage2_int_prepERNS_8ios_baseERw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIwE17__stage2_int_prepERNS_8ios_baseERw"].apply(null, arguments);
});
var __ZNSt3__29__num_getIwE19__stage2_float_loopEwRbRcPcRS4_wwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSE_RjPw = Module["__ZNSt3__29__num_getIwE19__stage2_float_loopEwRbRcPcRS4_wwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSE_RjPw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIwE19__stage2_float_loopEwRbRcPcRS4_wwRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPjRSE_RjPw"].apply(null, arguments);
});
var __ZNSt3__29__num_getIwE19__stage2_float_prepERNS_8ios_baseEPwRwS5_ = Module["__ZNSt3__29__num_getIwE19__stage2_float_prepERNS_8ios_baseEPwRwS5_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_getIwE19__stage2_float_prepERNS_8ios_baseEPwRwS5_"].apply(null, arguments);
});
var __ZNSt3__29__num_putIcE21__widen_and_group_intEPcS2_S2_S2_RS2_S3_RKNS_6localeE = Module["__ZNSt3__29__num_putIcE21__widen_and_group_intEPcS2_S2_S2_RS2_S3_RKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_putIcE21__widen_and_group_intEPcS2_S2_S2_RS2_S3_RKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__29__num_putIcE23__widen_and_group_floatEPcS2_S2_S2_RS2_S3_RKNS_6localeE = Module["__ZNSt3__29__num_putIcE23__widen_and_group_floatEPcS2_S2_S2_RS2_S3_RKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_putIcE23__widen_and_group_floatEPcS2_S2_S2_RS2_S3_RKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__29__num_putIwE21__widen_and_group_intEPcS2_S2_PwRS3_S4_RKNS_6localeE = Module["__ZNSt3__29__num_putIwE21__widen_and_group_intEPcS2_S2_PwRS3_S4_RKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_putIwE21__widen_and_group_intEPcS2_S2_PwRS3_S4_RKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__29__num_putIwE23__widen_and_group_floatEPcS2_S2_PwRS3_S4_RKNS_6localeE = Module["__ZNSt3__29__num_putIwE23__widen_and_group_floatEPcS2_S2_PwRS3_S4_RKNS_6localeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29__num_putIwE23__widen_and_group_floatEPcS2_S2_PwRS3_S4_RKNS_6localeE"].apply(null, arguments);
});
var __ZNSt3__29basic_iosIcNS_11char_traitsIcEEED2Ev = Module["__ZNSt3__29basic_iosIcNS_11char_traitsIcEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29basic_iosIcNS_11char_traitsIcEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__29basic_iosIwNS_11char_traitsIwEEED2Ev = Module["__ZNSt3__29basic_iosIwNS_11char_traitsIwEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29basic_iosIwNS_11char_traitsIwEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE8__do_getERS4_S4_bRKNS_6localeEjRjRbRKNS_5ctypeIcEERNS_10unique_ptrIcPFvPvEEERPcSM_ = Module["__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE8__do_getERS4_S4_bRKNS_6localeEjRjRbRKNS_5ctypeIcEERNS_10unique_ptrIcPFvPvEEERPcSM_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEE8__do_getERS4_S4_bRKNS_6localeEjRjRbRKNS_5ctypeIcEERNS_10unique_ptrIcPFvPvEEERPcSM_"].apply(null, arguments);
});
var __ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev = Module["__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev = Module["__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE8__do_getERS4_S4_bRKNS_6localeEjRjRbRKNS_5ctypeIwEERNS_10unique_ptrIwPFvPvEEERPwSM_ = Module["__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE8__do_getERS4_S4_bRKNS_6localeEjRjRbRKNS_5ctypeIwEERNS_10unique_ptrIwPFvPvEEERPwSM_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEE8__do_getERS4_S4_bRKNS_6localeEjRjRbRKNS_5ctypeIwEERNS_10unique_ptrIwPFvPvEEERPwSM_"].apply(null, arguments);
});
var __ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev = Module["__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev = Module["__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev = Module["__ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev = Module["__ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev = Module["__ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED0Ev"].apply(null, arguments);
});
var __ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev = Module["__ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__29money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEED2Ev"].apply(null, arguments);
});
var __ZNSt3__2L10init_am_pmEv = Module["__ZNSt3__2L10init_am_pmEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L10init_am_pmEv"].apply(null, arguments);
});
var __ZNSt3__2L10init_weeksEv = Module["__ZNSt3__2L10init_weeksEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L10init_weeksEv"].apply(null, arguments);
});
var __ZNSt3__2L11init_monthsEv = Module["__ZNSt3__2L11init_monthsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L11init_monthsEv"].apply(null, arguments);
});
var __ZNSt3__2L11init_wam_pmEv = Module["__ZNSt3__2L11init_wam_pmEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L11init_wam_pmEv"].apply(null, arguments);
});
var __ZNSt3__2L11init_wweeksEv = Module["__ZNSt3__2L11init_wweeksEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L11init_wweeksEv"].apply(null, arguments);
});
var __ZNSt3__2L12init_wmonthsEv = Module["__ZNSt3__2L12init_wmonthsEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L12init_wmonthsEv"].apply(null, arguments);
});
var __ZNSt3__2L12ucs4_to_utf8EPKjS1_RS1_PhS3_RS3_mNS_12codecvt_modeE = Module["__ZNSt3__2L12ucs4_to_utf8EPKjS1_RS1_PhS3_RS3_mNS_12codecvt_modeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L12ucs4_to_utf8EPKjS1_RS1_PhS3_RS3_mNS_12codecvt_modeE"].apply(null, arguments);
});
var __ZNSt3__2L12utf8_to_ucs4EPKhS1_RS1_PjS3_RS3_mNS_12codecvt_modeE = Module["__ZNSt3__2L12utf8_to_ucs4EPKhS1_RS1_PjS3_RS3_mNS_12codecvt_modeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L12utf8_to_ucs4EPKhS1_RS1_PjS3_RS3_mNS_12codecvt_modeE"].apply(null, arguments);
});
var __ZNSt3__2L13utf16_to_utf8EPKtS1_RS1_PhS3_RS3_mNS_12codecvt_modeE = Module["__ZNSt3__2L13utf16_to_utf8EPKtS1_RS1_PhS3_RS3_mNS_12codecvt_modeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L13utf16_to_utf8EPKtS1_RS1_PhS3_RS3_mNS_12codecvt_modeE"].apply(null, arguments);
});
var __ZNSt3__2L13utf8_to_utf16EPKhS1_RS1_PtS3_RS3_mNS_12codecvt_modeE = Module["__ZNSt3__2L13utf8_to_utf16EPKhS1_RS1_PtS3_RS3_mNS_12codecvt_modeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L13utf8_to_utf16EPKhS1_RS1_PtS3_RS3_mNS_12codecvt_modeE"].apply(null, arguments);
});
var __ZNSt3__2L19utf8_to_ucs4_lengthEPKhS1_mmNS_12codecvt_modeE = Module["__ZNSt3__2L19utf8_to_ucs4_lengthEPKhS1_mmNS_12codecvt_modeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L19utf8_to_ucs4_lengthEPKhS1_mmNS_12codecvt_modeE"].apply(null, arguments);
});
var __ZNSt3__2L20utf8_to_utf16_lengthEPKhS1_mmNS_12codecvt_modeE = Module["__ZNSt3__2L20utf8_to_utf16_lengthEPKhS1_mmNS_12codecvt_modeE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt3__2L20utf8_to_utf16_lengthEPKhS1_mmNS_12codecvt_modeE"].apply(null, arguments);
});
var __ZNSt9bad_allocC2Ev = Module["__ZNSt9bad_allocC2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt9bad_allocC2Ev"].apply(null, arguments);
});
var __ZNSt9bad_allocD0Ev = Module["__ZNSt9bad_allocD0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt9bad_allocD0Ev"].apply(null, arguments);
});
var __ZNSt9exceptionD2Ev = Module["__ZNSt9exceptionD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt9exceptionD2Ev"].apply(null, arguments);
});
var __ZNSt9type_infoD2Ev = Module["__ZNSt9type_infoD2Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZNSt9type_infoD2Ev"].apply(null, arguments);
});
var __ZSt11__terminatePFvvE = Module["__ZSt11__terminatePFvvE"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZSt11__terminatePFvvE"].apply(null, arguments);
});
var __ZSt13get_terminatev = Module["__ZSt13get_terminatev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZSt13get_terminatev"].apply(null, arguments);
});
var __ZSt15get_new_handlerv = Module["__ZSt15get_new_handlerv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZSt15get_new_handlerv"].apply(null, arguments);
});
var __ZSt17__throw_bad_allocv = Module["__ZSt17__throw_bad_allocv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZSt17__throw_bad_allocv"].apply(null, arguments);
});
var __ZSt18uncaught_exceptionv = Module["__ZSt18uncaught_exceptionv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZSt18uncaught_exceptionv"].apply(null, arguments);
});
var __ZSt19uncaught_exceptionsv = Module["__ZSt19uncaught_exceptionsv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZSt19uncaught_exceptionsv"].apply(null, arguments);
});
var __ZSt9terminatev = Module["__ZSt9terminatev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZSt9terminatev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev = Module["__ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED0Ev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev = Module["__ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_istreamIcNS_11char_traitsIcEEED1Ev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev = Module["__ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED0Ev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev = Module["__ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_istreamIwNS_11char_traitsIwEEED1Ev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev = Module["__ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED0Ev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev = Module["__ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_ostreamIcNS_11char_traitsIcEEED1Ev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev = Module["__ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED0Ev"].apply(null, arguments);
});
var __ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev = Module["__ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZTv0_n12_NSt3__213basic_ostreamIwNS_11char_traitsIwEEED1Ev"].apply(null, arguments);
});
var __ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE0_clES4_ = Module["__ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE0_clES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE0_clES4_"].apply(null, arguments);
});
var __ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE1_clES4_ = Module["__ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE1_clES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE1_clES4_"].apply(null, arguments);
});
var __ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE_clES4_ = Module["__ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE_clES4_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZZN12_GLOBAL__N_116itanium_demangle13ParameterPackC1ENS0_9NodeArrayEENKUlPNS0_4NodeEE_clES4_"].apply(null, arguments);
});
var __ZZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseEncodingEvENKUlvE_clEv = Module["__ZZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseEncodingEvENKUlvE_clEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E13parseEncodingEvENKUlvE_clEv"].apply(null, arguments);
});
var __ZZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseNestedNameEPNS5_9NameStateEENKUlPNS0_4NodeEE_clES9_ = Module["__ZZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseNestedNameEPNS5_9NameStateEENKUlPNS0_4NodeEE_clES9_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZZN12_GLOBAL__N_116itanium_demangle22AbstractManglingParserINS0_14ManglingParserINS_16DefaultAllocatorEEES3_E15parseNestedNameEPNS5_9NameStateEENKUlPNS0_4NodeEE_clES9_"].apply(null, arguments);
});
var __ZZNK12_GLOBAL__N_116itanium_demangle8FoldExpr9printLeftERNS_12OutputStreamEENKUlvE_clEv = Module["__ZZNK12_GLOBAL__N_116itanium_demangle8FoldExpr9printLeftERNS_12OutputStreamEENKUlvE_clEv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZZNK12_GLOBAL__N_116itanium_demangle8FoldExpr9printLeftERNS_12OutputStreamEENKUlvE_clEv"].apply(null, arguments);
});
var __ZdaPv = Module["__ZdaPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZdaPv"].apply(null, arguments);
});
var __ZdlPv = Module["__ZdlPv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__ZdlPv"].apply(null, arguments);
});
var __Znwm = Module["__Znwm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__Znwm"].apply(null, arguments);
});
var ___DOUBLE_BITS = Module["___DOUBLE_BITS"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___DOUBLE_BITS"].apply(null, arguments);
});
var ___DOUBLE_BITS_558 = Module["___DOUBLE_BITS_558"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___DOUBLE_BITS_558"].apply(null, arguments);
});
var ___bswap_16 = Module["___bswap_16"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___bswap_16"].apply(null, arguments);
});
var ___bswap_16_646 = Module["___bswap_16_646"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___bswap_16_646"].apply(null, arguments);
});
var ___bswap_32 = Module["___bswap_32"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___bswap_32"].apply(null, arguments);
});
var ___bswap_32_604 = Module["___bswap_32_604"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___bswap_32_604"].apply(null, arguments);
});
var ___clang_call_terminate = Module["___clang_call_terminate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___clang_call_terminate"].apply(null, arguments);
});
var ___ctype_b_loc = Module["___ctype_b_loc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ctype_b_loc"].apply(null, arguments);
});
var ___ctype_get_mb_cur_max = Module["___ctype_get_mb_cur_max"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ctype_get_mb_cur_max"].apply(null, arguments);
});
var ___ctype_tolower_loc = Module["___ctype_tolower_loc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ctype_tolower_loc"].apply(null, arguments);
});
var ___ctype_toupper_loc = Module["___ctype_toupper_loc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ctype_toupper_loc"].apply(null, arguments);
});
var ___cxa_can_catch = Module["___cxa_can_catch"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxa_can_catch"].apply(null, arguments);
});
var ___cxa_demangle = Module["___cxa_demangle"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxa_demangle"].apply(null, arguments);
});
var ___cxa_get_globals_fast = Module["___cxa_get_globals_fast"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxa_get_globals_fast"].apply(null, arguments);
});
var ___cxa_guard_acquire = Module["___cxa_guard_acquire"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxa_guard_acquire"].apply(null, arguments);
});
var ___cxa_guard_release = Module["___cxa_guard_release"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxa_guard_release"].apply(null, arguments);
});
var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxa_is_pointer_type"].apply(null, arguments);
});
var ___cxx_global_var_init = Module["___cxx_global_var_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxx_global_var_init"].apply(null, arguments);
});
var ___cxx_global_var_init_14617 = Module["___cxx_global_var_init_14617"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___cxx_global_var_init_14617"].apply(null, arguments);
});
var ___dynamic_cast = Module["___dynamic_cast"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___dynamic_cast"].apply(null, arguments);
});
var ___em_js__CallManagerNotificationHandlerWrapper = Module["___em_js__CallManagerNotificationHandlerWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__CallManagerNotificationHandlerWrapper"].apply(null, arguments);
});
var ___em_js__CallSessionNotifyHandlerWrapper = Module["___em_js__CallSessionNotifyHandlerWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__CallSessionNotifyHandlerWrapper"].apply(null, arguments);
});
var ___em_js__CallSessionNotifyHandlerWrapper1 = Module["___em_js__CallSessionNotifyHandlerWrapper1"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__CallSessionNotifyHandlerWrapper1"].apply(null, arguments);
});
var ___em_js__CallSessionNotifyHandlerWrapperWasm = Module["___em_js__CallSessionNotifyHandlerWrapperWasm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__CallSessionNotifyHandlerWrapperWasm"].apply(null, arguments);
});
var ___em_js__SystemManagerNotificationHandlerWrapper = Module["___em_js__SystemManagerNotificationHandlerWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__SystemManagerNotificationHandlerWrapper"].apply(null, arguments);
});
var ___em_js__closePeerConnectionWrapper = Module["___em_js__closePeerConnectionWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__closePeerConnectionWrapper"].apply(null, arguments);
});
var ___em_js__createPeerConnectionWrapper = Module["___em_js__createPeerConnectionWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__createPeerConnectionWrapper"].apply(null, arguments);
});
var ___em_js__initPthreadsJS = Module["___em_js__initPthreadsJS"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__initPthreadsJS"].apply(null, arguments);
});
var ___em_js__modifyMediaStreamWrapper = Module["___em_js__modifyMediaStreamWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__modifyMediaStreamWrapper"].apply(null, arguments);
});
var ___em_js__receivingRemoteIceWrapper = Module["___em_js__receivingRemoteIceWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__receivingRemoteIceWrapper"].apply(null, arguments);
});
var ___em_js__setRemoteDescriptionWrapper = Module["___em_js__setRemoteDescriptionWrapper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___em_js__setRemoteDescriptionWrapper"].apply(null, arguments);
});
var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___embind_register_native_and_builtin_types"].apply(null, arguments);
});
var ___emscripten_environ_constructor = Module["___emscripten_environ_constructor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___emscripten_environ_constructor"].apply(null, arguments);
});
var ___emscripten_pthread_data_constructor = Module["___emscripten_pthread_data_constructor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___emscripten_pthread_data_constructor"].apply(null, arguments);
});
var ___emscripten_thread_main = Module["___emscripten_thread_main"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___emscripten_thread_main"].apply(null, arguments);
});
var ___errno_location = Module["___errno_location"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___errno_location"].apply(null, arguments);
});
var ___fdopen = Module["___fdopen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___fdopen"].apply(null, arguments);
});
var ___fflush_unlocked = Module["___fflush_unlocked"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___fflush_unlocked"].apply(null, arguments);
});
var ___floatscan = Module["___floatscan"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___floatscan"].apply(null, arguments);
});
var ___fmodeflags = Module["___fmodeflags"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___fmodeflags"].apply(null, arguments);
});
var ___fseeko = Module["___fseeko"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___fseeko"].apply(null, arguments);
});
var ___fseeko_unlocked = Module["___fseeko_unlocked"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___fseeko_unlocked"].apply(null, arguments);
});
var ___ftello = Module["___ftello"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ftello"].apply(null, arguments);
});
var ___ftello_unlocked = Module["___ftello_unlocked"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ftello_unlocked"].apply(null, arguments);
});
var ___fwritex = Module["___fwritex"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___fwritex"].apply(null, arguments);
});
var ___getTypeName = Module["___getTypeName"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___getTypeName"].apply(null, arguments);
});
var ___get_locale = Module["___get_locale"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___get_locale"].apply(null, arguments);
});
var ___intscan = Module["___intscan"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___intscan"].apply(null, arguments);
});
var ___lctrans_cur = Module["___lctrans_cur"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___lctrans_cur"].apply(null, arguments);
});
var ___lctrans_impl = Module["___lctrans_impl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___lctrans_impl"].apply(null, arguments);
});
var ___loc_is_allocated = Module["___loc_is_allocated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___loc_is_allocated"].apply(null, arguments);
});
var ___lockfile = Module["___lockfile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___lockfile"].apply(null, arguments);
});
var ___memrchr = Module["___memrchr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___memrchr"].apply(null, arguments);
});
var ___mo_lookup = Module["___mo_lookup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___mo_lookup"].apply(null, arguments);
});
var ___munmap = Module["___munmap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___munmap"].apply(null, arguments);
});
var ___netlink_enumerate = Module["___netlink_enumerate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___netlink_enumerate"].apply(null, arguments);
});
var ___newlocale = Module["___newlocale"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___newlocale"].apply(null, arguments);
});
var ___ofl_add = Module["___ofl_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ofl_add"].apply(null, arguments);
});
var ___ofl_lock = Module["___ofl_lock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ofl_lock"].apply(null, arguments);
});
var ___ofl_unlock = Module["___ofl_unlock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___ofl_unlock"].apply(null, arguments);
});
var ___overflow = Module["___overflow"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___overflow"].apply(null, arguments);
});
var ___private_cond_signal = Module["___private_cond_signal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___private_cond_signal"].apply(null, arguments);
});
var ___pthread_cond_timedwait = Module["___pthread_cond_timedwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_cond_timedwait"].apply(null, arguments);
});
var ___pthread_getspecific = Module["___pthread_getspecific"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_getspecific"].apply(null, arguments);
});
var ___pthread_key_create = Module["___pthread_key_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_key_create"].apply(null, arguments);
});
var ___pthread_mutex_lock = Module["___pthread_mutex_lock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_mutex_lock"].apply(null, arguments);
});
var ___pthread_mutex_timedlock = Module["___pthread_mutex_timedlock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_mutex_timedlock"].apply(null, arguments);
});
var ___pthread_mutex_trylock = Module["___pthread_mutex_trylock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_mutex_trylock"].apply(null, arguments);
});
var ___pthread_mutex_trylock_owner = Module["___pthread_mutex_trylock_owner"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_mutex_trylock_owner"].apply(null, arguments);
});
var ___pthread_mutex_unlock = Module["___pthread_mutex_unlock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_mutex_unlock"].apply(null, arguments);
});
var ___pthread_once = Module["___pthread_once"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_once"].apply(null, arguments);
});
var ___pthread_once_full = Module["___pthread_once_full"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_once_full"].apply(null, arguments);
});
var ___pthread_self_233 = Module["___pthread_self_233"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_233"].apply(null, arguments);
});
var ___pthread_self_315 = Module["___pthread_self_315"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_315"].apply(null, arguments);
});
var ___pthread_self_323 = Module["___pthread_self_323"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_323"].apply(null, arguments);
});
var ___pthread_self_707 = Module["___pthread_self_707"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_707"].apply(null, arguments);
});
var ___pthread_self_710 = Module["___pthread_self_710"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_710"].apply(null, arguments);
});
var ___pthread_self_723 = Module["___pthread_self_723"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_723"].apply(null, arguments);
});
var ___pthread_self_728 = Module["___pthread_self_728"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_728"].apply(null, arguments);
});
var ___pthread_self_840 = Module["___pthread_self_840"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_840"].apply(null, arguments);
});
var ___pthread_self_89 = Module["___pthread_self_89"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_self_89"].apply(null, arguments);
});
var ___pthread_setcancelstate = Module["___pthread_setcancelstate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_setcancelstate"].apply(null, arguments);
});
var ___pthread_testcancel = Module["___pthread_testcancel"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_testcancel"].apply(null, arguments);
});
var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___pthread_tsd_run_dtors"].apply(null, arguments);
});
var ___res_state = Module["___res_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___res_state"].apply(null, arguments);
});
var ___rtnetlink_enumerate = Module["___rtnetlink_enumerate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___rtnetlink_enumerate"].apply(null, arguments);
});
var ___shgetc = Module["___shgetc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___shgetc"].apply(null, arguments);
});
var ___shlim = Module["___shlim"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___shlim"].apply(null, arguments);
});
var ___stdio_close = Module["___stdio_close"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___stdio_close"].apply(null, arguments);
});
var ___stdio_read = Module["___stdio_read"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___stdio_read"].apply(null, arguments);
});
var ___stdio_seek = Module["___stdio_seek"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___stdio_seek"].apply(null, arguments);
});
var ___stdio_write = Module["___stdio_write"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___stdio_write"].apply(null, arguments);
});
var ___stdout_write = Module["___stdout_write"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___stdout_write"].apply(null, arguments);
});
var ___stpcpy = Module["___stpcpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___stpcpy"].apply(null, arguments);
});
var ___stpncpy = Module["___stpncpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___stpncpy"].apply(null, arguments);
});
var ___strchrnul = Module["___strchrnul"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___strchrnul"].apply(null, arguments);
});
var ___strdup = Module["___strdup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___strdup"].apply(null, arguments);
});
var ___string_read = Module["___string_read"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___string_read"].apply(null, arguments);
});
var ___syscall_ret = Module["___syscall_ret"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___syscall_ret"].apply(null, arguments);
});
var ___timedwait = Module["___timedwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___timedwait"].apply(null, arguments);
});
var ___timedwait_cp = Module["___timedwait_cp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___timedwait_cp"].apply(null, arguments);
});
var ___toread = Module["___toread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___toread"].apply(null, arguments);
});
var ___towrite = Module["___towrite"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___towrite"].apply(null, arguments);
});
var ___uflow = Module["___uflow"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___uflow"].apply(null, arguments);
});
var ___unlist_locked_file = Module["___unlist_locked_file"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___unlist_locked_file"].apply(null, arguments);
});
var ___unlockfile = Module["___unlockfile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___unlockfile"].apply(null, arguments);
});
var ___uselocale = Module["___uselocale"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___uselocale"].apply(null, arguments);
});
var ___vfprintf_internal = Module["___vfprintf_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___vfprintf_internal"].apply(null, arguments);
});
var ___vm_lock = Module["___vm_lock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___vm_lock"].apply(null, arguments);
});
var ___vm_unlock = Module["___vm_unlock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___vm_unlock"].apply(null, arguments);
});
var ___vm_wait = Module["___vm_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___vm_wait"].apply(null, arguments);
});
var ___wait = Module["___wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["___wait"].apply(null, arguments);
});
var __do_call = Module["__do_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__do_call"].apply(null, arguments);
});
var __emscripten_atomic_fetch_and_add_u64 = Module["__emscripten_atomic_fetch_and_add_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__emscripten_atomic_fetch_and_add_u64"].apply(null, arguments);
});
var __emscripten_atomic_fetch_and_and_u64 = Module["__emscripten_atomic_fetch_and_and_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__emscripten_atomic_fetch_and_and_u64"].apply(null, arguments);
});
var __emscripten_atomic_fetch_and_or_u64 = Module["__emscripten_atomic_fetch_and_or_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__emscripten_atomic_fetch_and_or_u64"].apply(null, arguments);
});
var __emscripten_atomic_fetch_and_sub_u64 = Module["__emscripten_atomic_fetch_and_sub_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__emscripten_atomic_fetch_and_sub_u64"].apply(null, arguments);
});
var __emscripten_atomic_fetch_and_xor_u64 = Module["__emscripten_atomic_fetch_and_xor_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__emscripten_atomic_fetch_and_xor_u64"].apply(null, arguments);
});
var __emscripten_get_fetch_queue = Module["__emscripten_get_fetch_queue"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__emscripten_get_fetch_queue"].apply(null, arguments);
});
var __get_daylight = Module["__get_daylight"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__get_daylight"].apply(null, arguments);
});
var __get_environ = Module["__get_environ"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__get_environ"].apply(null, arguments);
});
var __get_timezone = Module["__get_timezone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__get_timezone"].apply(null, arguments);
});
var __get_tzname = Module["__get_tzname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__get_tzname"].apply(null, arguments);
});
var __pthread_isduecanceled = Module["__pthread_isduecanceled"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__pthread_isduecanceled"].apply(null, arguments);
});
var __register_pthread_ptr = Module["__register_pthread_ptr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["__register_pthread_ptr"].apply(null, arguments);
});
var _abort_message = Module["_abort_message"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_abort_message"].apply(null, arguments);
});
var _accept = Module["_accept"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_accept"].apply(null, arguments);
});
var _arg_n_200 = Module["_arg_n_200"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_arg_n_200"].apply(null, arguments);
});
var _async_close_cb = Module["_async_close_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_async_close_cb"].apply(null, arguments);
});
var _async_message_cb = Module["_async_message_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_async_message_cb"].apply(null, arguments);
});
var _async_open_cbk = Module["_async_open_cbk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_async_open_cbk"].apply(null, arguments);
});
var _atof = Module["_atof"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_atof"].apply(null, arguments);
});
var _atoi = Module["_atoi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_atoi"].apply(null, arguments);
});
var _avb_media_handler = Module["_avb_media_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_avb_media_handler"].apply(null, arguments);
});
var _bind = Module["_bind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_bind"].apply(null, arguments);
});
var _calloc = Module["_calloc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_calloc"].apply(null, arguments);
});
var _catclose = Module["_catclose"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_catclose"].apply(null, arguments);
});
var _catgets = Module["_catgets"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_catgets"].apply(null, arguments);
});
var _catopen = Module["_catopen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_catopen"].apply(null, arguments);
});
var _cbrule_hndlr = Module["_cbrule_hndlr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_cbrule_hndlr"].apply(null, arguments);
});
var _cdivrule_hndlr = Module["_cdivrule_hndlr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_cdivrule_hndlr"].apply(null, arguments);
});
var _cleanup_14569 = Module["_cleanup_14569"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_cleanup_14569"].apply(null, arguments);
});
var _close = Module["_close"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_close"].apply(null, arguments);
});
var _closedir = Module["_closedir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_closedir"].apply(null, arguments);
});
var _conds_hndlr = Module["_conds_hndlr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_conds_hndlr"].apply(null, arguments);
});
var _conf_desc_handler = Module["_conf_desc_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_conf_desc_handler"].apply(null, arguments);
});
var _conf_info_handler = Module["_conf_info_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_conf_info_handler"].apply(null, arguments);
});
var _connect = Module["_connect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_connect"].apply(null, arguments);
});
var _copy_addr = Module["_copy_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_copy_addr"].apply(null, arguments);
});
var _copy_lladdr = Module["_copy_lladdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_copy_lladdr"].apply(null, arguments);
});
var _copysign = Module["_copysign"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_copysign"].apply(null, arguments);
});
var _copysignl = Module["_copysignl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_copysignl"].apply(null, arguments);
});
var _decfloat = Module["_decfloat"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_decfloat"].apply(null, arguments);
});
var _dispose_chunk = Module["_dispose_chunk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_dispose_chunk"].apply(null, arguments);
});
var _do_read = Module["_do_read"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_do_read"].apply(null, arguments);
});
var _doc_start_handler = Module["_doc_start_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_doc_start_handler"].apply(null, arguments);
});
var _dummy = Module["_dummy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_dummy"].apply(null, arguments);
});
var _emscripten_async_queue_call_on_thread = Module["_emscripten_async_queue_call_on_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_async_queue_call_on_thread"].apply(null, arguments);
});
var _emscripten_async_queue_on_thread_ = Module["_emscripten_async_queue_on_thread_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_async_queue_on_thread_"].apply(null, arguments);
});
var _emscripten_async_run_in_main_thread = Module["_emscripten_async_run_in_main_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_async_run_in_main_thread"].apply(null, arguments);
});
var _emscripten_atomic_add_u64 = Module["_emscripten_atomic_add_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_add_u64"].apply(null, arguments);
});
var _emscripten_atomic_and_u64 = Module["_emscripten_atomic_and_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_and_u64"].apply(null, arguments);
});
var _emscripten_atomic_cas_u64 = Module["_emscripten_atomic_cas_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_cas_u64"].apply(null, arguments);
});
var _emscripten_atomic_exchange_u64 = Module["_emscripten_atomic_exchange_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_exchange_u64"].apply(null, arguments);
});
var _emscripten_atomic_load_f32 = Module["_emscripten_atomic_load_f32"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_load_f32"].apply(null, arguments);
});
var _emscripten_atomic_load_f64 = Module["_emscripten_atomic_load_f64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_load_f64"].apply(null, arguments);
});
var _emscripten_atomic_load_u64 = Module["_emscripten_atomic_load_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_load_u64"].apply(null, arguments);
});
var _emscripten_atomic_or_u64 = Module["_emscripten_atomic_or_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_or_u64"].apply(null, arguments);
});
var _emscripten_atomic_store_f32 = Module["_emscripten_atomic_store_f32"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_store_f32"].apply(null, arguments);
});
var _emscripten_atomic_store_f64 = Module["_emscripten_atomic_store_f64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_store_f64"].apply(null, arguments);
});
var _emscripten_atomic_store_u64 = Module["_emscripten_atomic_store_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_store_u64"].apply(null, arguments);
});
var _emscripten_atomic_sub_u64 = Module["_emscripten_atomic_sub_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_sub_u64"].apply(null, arguments);
});
var _emscripten_atomic_xor_u64 = Module["_emscripten_atomic_xor_u64"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_atomic_xor_u64"].apply(null, arguments);
});
var _emscripten_conditional_set_current_thread_status = Module["_emscripten_conditional_set_current_thread_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_conditional_set_current_thread_status"].apply(null, arguments);
});
var _emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_current_thread_process_queued_calls"].apply(null, arguments);
});
var _emscripten_fetch = Module["_emscripten_fetch"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_fetch"].apply(null, arguments);
});
var _emscripten_fetch_attr_init = Module["_emscripten_fetch_attr_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_fetch_attr_init"].apply(null, arguments);
});
var _emscripten_fetch_close = Module["_emscripten_fetch_close"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_fetch_close"].apply(null, arguments);
});
var _emscripten_fetch_free = Module["_emscripten_fetch_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_fetch_free"].apply(null, arguments);
});
var _emscripten_fetch_wait = Module["_emscripten_fetch_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_fetch_wait"].apply(null, arguments);
});
var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_get_global_libc"].apply(null, arguments);
});
var _emscripten_is_main_browser_thread = Module["_emscripten_is_main_browser_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_is_main_browser_thread"].apply(null, arguments);
});
var _emscripten_is_main_runtime_thread = Module["_emscripten_is_main_runtime_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_is_main_runtime_thread"].apply(null, arguments);
});
var _emscripten_main_browser_thread_id = Module["_emscripten_main_browser_thread_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_main_browser_thread_id"].apply(null, arguments);
});
var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_main_thread_process_queued_calls"].apply(null, arguments);
});
var _emscripten_proxy_fetch = Module["_emscripten_proxy_fetch"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_proxy_fetch"].apply(null, arguments);
});
var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_register_main_browser_thread_id"].apply(null, arguments);
});
var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_replace_memory"].apply(null, arguments);
});
var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_run_in_main_runtime_thread_js"].apply(null, arguments);
});
var _emscripten_set_current_thread_status = Module["_emscripten_set_current_thread_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_set_current_thread_status"].apply(null, arguments);
});
var _emscripten_set_thread_name = Module["_emscripten_set_thread_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_set_thread_name"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_runtime_thread_ = Module["_emscripten_sync_run_in_main_runtime_thread_"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_runtime_thread_"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread = Module["_emscripten_sync_run_in_main_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_0 = Module["_emscripten_sync_run_in_main_thread_0"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_0"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_1 = Module["_emscripten_sync_run_in_main_thread_1"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_1"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_2 = Module["_emscripten_sync_run_in_main_thread_2"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_2"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_3 = Module["_emscripten_sync_run_in_main_thread_3"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_3"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_4"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_5 = Module["_emscripten_sync_run_in_main_thread_5"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_5"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_6 = Module["_emscripten_sync_run_in_main_thread_6"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_6"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_7 = Module["_emscripten_sync_run_in_main_thread_7"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_7"].apply(null, arguments);
});
var _emscripten_sync_run_in_main_thread_xprintf_varargs = Module["_emscripten_sync_run_in_main_thread_xprintf_varargs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_sync_run_in_main_thread_xprintf_varargs"].apply(null, arguments);
});
var _emscripten_thread_sleep = Module["_emscripten_thread_sleep"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_thread_sleep"].apply(null, arguments);
});
var _emscripten_wait_for_call_v = Module["_emscripten_wait_for_call_v"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_emscripten_wait_for_call_v"].apply(null, arguments);
});
var _ep_handler = Module["_ep_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ep_handler"].apply(null, arguments);
});
var _error_callback = Module["_error_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_error_callback"].apply(null, arguments);
});
var _f1 = Module["_f1"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_f1"].apply(null, arguments);
});
var _f1star = Module["_f1star"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_f1star"].apply(null, arguments);
});
var _f2 = Module["_f2"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_f2"].apply(null, arguments);
});
var _f3 = Module["_f3"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_f3"].apply(null, arguments);
});
var _f4 = Module["_f4"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_f4"].apply(null, arguments);
});
var _f5 = Module["_f5"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_f5"].apply(null, arguments);
});
var _f5star = Module["_f5star"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_f5star"].apply(null, arguments);
});
var _fclose = Module["_fclose"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fclose"].apply(null, arguments);
});
var _fcntl = Module["_fcntl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fcntl"].apply(null, arguments);
});
var _feof = Module["_feof"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_feof"].apply(null, arguments);
});
var _ferror = Module["_ferror"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ferror"].apply(null, arguments);
});
var _fflush = Module["_fflush"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fflush"].apply(null, arguments);
});
var _fgetc = Module["_fgetc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fgetc"].apply(null, arguments);
});
var _fgets = Module["_fgets"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fgets"].apply(null, arguments);
});
var _fmod = Module["_fmod"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fmod"].apply(null, arguments);
});
var _fmodl = Module["_fmodl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fmodl"].apply(null, arguments);
});
var _fmt_fp = Module["_fmt_fp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fmt_fp"].apply(null, arguments);
});
var _fmt_o = Module["_fmt_o"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fmt_o"].apply(null, arguments);
});
var _fmt_u = Module["_fmt_u"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fmt_u"].apply(null, arguments);
});
var _fmt_x = Module["_fmt_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fmt_x"].apply(null, arguments);
});
var _fopen = Module["_fopen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fopen"].apply(null, arguments);
});
var _fourbyte_strstr = Module["_fourbyte_strstr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fourbyte_strstr"].apply(null, arguments);
});
var _fprintf = Module["_fprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fprintf"].apply(null, arguments);
});
var _fputc = Module["_fputc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fputc"].apply(null, arguments);
});
var _fputs = Module["_fputs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fputs"].apply(null, arguments);
});
var _fread = Module["_fread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fread"].apply(null, arguments);
});
var _free = Module["_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_free"].apply(null, arguments);
});
var _freeaddrinfo = Module["_freeaddrinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_freeaddrinfo"].apply(null, arguments);
});
var _freeifaddrs = Module["_freeifaddrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_freeifaddrs"].apply(null, arguments);
});
var _freelocale = Module["_freelocale"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_freelocale"].apply(null, arguments);
});
var _frexp = Module["_frexp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_frexp"].apply(null, arguments);
});
var _fseek = Module["_fseek"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fseek"].apply(null, arguments);
});
var _ftell = Module["_ftell"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ftell"].apply(null, arguments);
});
var _fwrite = Module["_fwrite"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_fwrite"].apply(null, arguments);
});
var _gen_netmask = Module["_gen_netmask"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_gen_netmask"].apply(null, arguments);
});
var _get_elmt_name = Module["_get_elmt_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_get_elmt_name"].apply(null, arguments);
});
var _get_ieee_node_identifier = Module["_get_ieee_node_identifier"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_get_ieee_node_identifier"].apply(null, arguments);
});
var _get_next_attr = Module["_get_next_attr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_get_next_attr"].apply(null, arguments);
});
var _get_system_time = Module["_get_system_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_get_system_time"].apply(null, arguments);
});
var _getc = Module["_getc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_getc"].apply(null, arguments);
});
var _gethostname = Module["_gethostname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_gethostname"].apply(null, arguments);
});
var _getifaddrs = Module["_getifaddrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_getifaddrs"].apply(null, arguments);
});
var _getint = Module["_getint"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_getint"].apply(null, arguments);
});
var _getpid = Module["_getpid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_getpid"].apply(null, arguments);
});
var _getsockname = Module["_getsockname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_getsockname"].apply(null, arguments);
});
var _getsockopt = Module["_getsockopt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_getsockopt"].apply(null, arguments);
});
var _hexfloat = Module["_hexfloat"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hexfloat"].apply(null, arguments);
});
var _hexval_592 = Module["_hexval_592"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hexval_592"].apply(null, arguments);
});
var _hmac_md5 = Module["_hmac_md5"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hmac_md5"].apply(null, arguments);
});
var _hs_CB_sip_reginfo_doc_end = Module["_hs_CB_sip_reginfo_doc_end"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_CB_sip_reginfo_doc_end"].apply(null, arguments);
});
var _hs_CB_sip_reginfo_doc_start = Module["_hs_CB_sip_reginfo_doc_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_CB_sip_reginfo_doc_start"].apply(null, arguments);
});
var _hs_CB_sip_reginfo_tag_data = Module["_hs_CB_sip_reginfo_tag_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_CB_sip_reginfo_tag_data"].apply(null, arguments);
});
var _hs_CB_sip_reginfo_tag_end = Module["_hs_CB_sip_reginfo_tag_end"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_CB_sip_reginfo_tag_end"].apply(null, arguments);
});
var _hs_CB_sip_reginfo_tag_start = Module["_hs_CB_sip_reginfo_tag_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_CB_sip_reginfo_tag_start"].apply(null, arguments);
});
var _hs_config_get_cdma_entry_ecio = Module["_hs_config_get_cdma_entry_ecio"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_cdma_entry_ecio"].apply(null, arguments);
});
var _hs_config_get_cell_entry_ss = Module["_hs_config_get_cell_entry_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_cell_entry_ss"].apply(null, arguments);
});
var _hs_config_get_cell_exit_ss = Module["_hs_config_get_cell_exit_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_cell_exit_ss"].apply(null, arguments);
});
var _hs_config_get_cell_return_ss = Module["_hs_config_get_cell_return_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_cell_return_ss"].apply(null, arguments);
});
var _hs_config_get_cell_scan_ss = Module["_hs_config_get_cell_scan_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_cell_scan_ss"].apply(null, arguments);
});
var _hs_config_get_cell_ss = Module["_hs_config_get_cell_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_cell_ss"].apply(null, arguments);
});
var _hs_config_get_celldata_ecio = Module["_hs_config_get_celldata_ecio"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_ecio"].apply(null, arguments);
});
var _hs_config_get_celldata_entry_ecio = Module["_hs_config_get_celldata_entry_ecio"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_entry_ecio"].apply(null, arguments);
});
var _hs_config_get_celldata_entry_snr = Module["_hs_config_get_celldata_entry_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_entry_snr"].apply(null, arguments);
});
var _hs_config_get_celldata_entry_ss = Module["_hs_config_get_celldata_entry_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_entry_ss"].apply(null, arguments);
});
var _hs_config_get_celldata_exit_snr = Module["_hs_config_get_celldata_exit_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_exit_snr"].apply(null, arguments);
});
var _hs_config_get_celldata_exit_ss = Module["_hs_config_get_celldata_exit_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_exit_ss"].apply(null, arguments);
});
var _hs_config_get_celldata_return_snr = Module["_hs_config_get_celldata_return_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_return_snr"].apply(null, arguments);
});
var _hs_config_get_celldata_return_ss = Module["_hs_config_get_celldata_return_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_return_ss"].apply(null, arguments);
});
var _hs_config_get_celldata_scan_snr = Module["_hs_config_get_celldata_scan_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_scan_snr"].apply(null, arguments);
});
var _hs_config_get_celldata_scan_ss = Module["_hs_config_get_celldata_scan_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_scan_ss"].apply(null, arguments);
});
var _hs_config_get_celldata_snr = Module["_hs_config_get_celldata_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_snr"].apply(null, arguments);
});
var _hs_config_get_celldata_ss = Module["_hs_config_get_celldata_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_celldata_ss"].apply(null, arguments);
});
var _hs_config_get_gsm_ber = Module["_hs_config_get_gsm_ber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_gsm_ber"].apply(null, arguments);
});
var _hs_config_get_gsm_entry_ber = Module["_hs_config_get_gsm_entry_ber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_gsm_entry_ber"].apply(null, arguments);
});
var _hs_config_get_gsm_exit_ber = Module["_hs_config_get_gsm_exit_ber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_gsm_exit_ber"].apply(null, arguments);
});
var _hs_config_get_gsm_return_ber = Module["_hs_config_get_gsm_return_ber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_gsm_return_ber"].apply(null, arguments);
});
var _hs_config_get_gsm_scan_ber = Module["_hs_config_get_gsm_scan_ber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_gsm_scan_ber"].apply(null, arguments);
});
var _hs_config_get_list_from_str = Module["_hs_config_get_list_from_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_list_from_str"].apply(null, arguments);
});
var _hs_config_get_wifi_entry_snr = Module["_hs_config_get_wifi_entry_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_entry_snr"].apply(null, arguments);
});
var _hs_config_get_wifi_entry_ss = Module["_hs_config_get_wifi_entry_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_entry_ss"].apply(null, arguments);
});
var _hs_config_get_wifi_exit_snr = Module["_hs_config_get_wifi_exit_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_exit_snr"].apply(null, arguments);
});
var _hs_config_get_wifi_exit_ss = Module["_hs_config_get_wifi_exit_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_exit_ss"].apply(null, arguments);
});
var _hs_config_get_wifi_return_snr = Module["_hs_config_get_wifi_return_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_return_snr"].apply(null, arguments);
});
var _hs_config_get_wifi_return_ss = Module["_hs_config_get_wifi_return_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_return_ss"].apply(null, arguments);
});
var _hs_config_get_wifi_scan_snr = Module["_hs_config_get_wifi_scan_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_scan_snr"].apply(null, arguments);
});
var _hs_config_get_wifi_scan_ss = Module["_hs_config_get_wifi_scan_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_scan_ss"].apply(null, arguments);
});
var _hs_config_get_wifi_snr = Module["_hs_config_get_wifi_snr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_snr"].apply(null, arguments);
});
var _hs_config_get_wifi_ss = Module["_hs_config_get_wifi_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wifi_ss"].apply(null, arguments);
});
var _hs_config_get_wimax_entry_ss = Module["_hs_config_get_wimax_entry_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wimax_entry_ss"].apply(null, arguments);
});
var _hs_config_get_wimax_exit_ss = Module["_hs_config_get_wimax_exit_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wimax_exit_ss"].apply(null, arguments);
});
var _hs_config_get_wimax_return_ss = Module["_hs_config_get_wimax_return_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wimax_return_ss"].apply(null, arguments);
});
var _hs_config_get_wimax_scan_ss = Module["_hs_config_get_wimax_scan_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wimax_scan_ss"].apply(null, arguments);
});
var _hs_config_get_wimax_ss = Module["_hs_config_get_wimax_ss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_get_wimax_ss"].apply(null, arguments);
});
var _hs_config_set_enterprise_mode = Module["_hs_config_set_enterprise_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_config_set_enterprise_mode"].apply(null, arguments);
});
var _hs_contcap_dec_encodings = Module["_hs_contcap_dec_encodings"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_dec_encodings"].apply(null, arguments);
});
var _hs_contcap_dec_language = Module["_hs_contcap_dec_language"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_dec_language"].apply(null, arguments);
});
var _hs_contcap_dec_media_range = Module["_hs_contcap_dec_media_range"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_dec_media_range"].apply(null, arguments);
});
var _hs_contcap_dec_syntverf_encoding = Module["_hs_contcap_dec_syntverf_encoding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_dec_syntverf_encoding"].apply(null, arguments);
});
var _hs_contcap_dec_syntverf_lang = Module["_hs_contcap_dec_syntverf_lang"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_dec_syntverf_lang"].apply(null, arguments);
});
var _hs_contcap_dec_syntverf_type = Module["_hs_contcap_dec_syntverf_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_dec_syntverf_type"].apply(null, arguments);
});
var _hs_contcap_dec_type = Module["_hs_contcap_dec_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_dec_type"].apply(null, arguments);
});
var _hs_contcap_enc_create_copy = Module["_hs_contcap_enc_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_enc_create_copy"].apply(null, arguments);
});
var _hs_contcap_enc_create_default = Module["_hs_contcap_enc_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_enc_create_default"].apply(null, arguments);
});
var _hs_contcap_enc_free = Module["_hs_contcap_enc_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_enc_free"].apply(null, arguments);
});
var _hs_contcap_lang_create_copy = Module["_hs_contcap_lang_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_lang_create_copy"].apply(null, arguments);
});
var _hs_contcap_lang_create_default = Module["_hs_contcap_lang_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_lang_create_default"].apply(null, arguments);
});
var _hs_contcap_lang_free = Module["_hs_contcap_lang_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_lang_free"].apply(null, arguments);
});
var _hs_contcap_type_create_copy = Module["_hs_contcap_type_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_type_create_copy"].apply(null, arguments);
});
var _hs_contcap_type_free = Module["_hs_contcap_type_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_contcap_type_free"].apply(null, arguments);
});
var _hs_content_build_reslist_xml = Module["_hs_content_build_reslist_xml"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_build_reslist_xml"].apply(null, arguments);
});
var _hs_content_cap_add_lang_2 = Module["_hs_content_cap_add_lang_2"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_cap_add_lang_2"].apply(null, arguments);
});
var _hs_content_cap_create_2 = Module["_hs_content_cap_create_2"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_cap_create_2"].apply(null, arguments);
});
var _hs_content_cap_create_copy = Module["_hs_content_cap_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_cap_create_copy"].apply(null, arguments);
});
var _hs_content_cap_create_default = Module["_hs_content_cap_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_cap_create_default"].apply(null, arguments);
});
var _hs_content_cap_free = Module["_hs_content_cap_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_cap_free"].apply(null, arguments);
});
var _hs_content_cap_type_create_default = Module["_hs_content_cap_type_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_cap_type_create_default"].apply(null, arguments);
});
var _hs_content_copy = Module["_hs_content_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_copy"].apply(null, arguments);
});
var _hs_content_create = Module["_hs_content_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_create"].apply(null, arguments);
});
var _hs_content_create_2 = Module["_hs_content_create_2"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_create_2"].apply(null, arguments);
});
var _hs_content_create_copy = Module["_hs_content_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_create_copy"].apply(null, arguments);
});
var _hs_content_create_default = Module["_hs_content_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_create_default"].apply(null, arguments);
});
var _hs_content_create_mime_2 = Module["_hs_content_create_mime_2"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_create_mime_2"].apply(null, arguments);
});
var _hs_content_create_rootmime = Module["_hs_content_create_rootmime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_create_rootmime"].apply(null, arguments);
});
var _hs_content_dec_common = Module["_hs_content_dec_common"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_common"].apply(null, arguments);
});
var _hs_content_dec_disp = Module["_hs_content_dec_disp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_disp"].apply(null, arguments);
});
var _hs_content_dec_extension_token = Module["_hs_content_dec_extension_token"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_extension_token"].apply(null, arguments);
});
var _hs_content_dec_generic_param = Module["_hs_content_dec_generic_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_generic_param"].apply(null, arguments);
});
var _hs_content_dec_hex4 = Module["_hs_content_dec_hex4"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_hex4"].apply(null, arguments);
});
var _hs_content_dec_hostname = Module["_hs_content_dec_hostname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_hostname"].apply(null, arguments);
});
var _hs_content_dec_ipv4address = Module["_hs_content_dec_ipv4address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_ipv4address"].apply(null, arguments);
});
var _hs_content_dec_ipv6address = Module["_hs_content_dec_ipv6address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_ipv6address"].apply(null, arguments);
});
var _hs_content_dec_m_param = Module["_hs_content_dec_m_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_m_param"].apply(null, arguments);
});
var _hs_content_dec_m_subtype = Module["_hs_content_dec_m_subtype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_m_subtype"].apply(null, arguments);
});
var _hs_content_dec_m_type = Module["_hs_content_dec_m_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_m_type"].apply(null, arguments);
});
var _hs_content_dec_mediatype = Module["_hs_content_dec_mediatype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_mediatype"].apply(null, arguments);
});
var _hs_content_dec_mime_anlyz = Module["_hs_content_dec_mime_anlyz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_mime_anlyz"].apply(null, arguments);
});
var _hs_content_dec_qdtext = Module["_hs_content_dec_qdtext"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_qdtext"].apply(null, arguments);
});
var _hs_content_dec_quoted_stringval = Module["_hs_content_dec_quoted_stringval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_quoted_stringval"].apply(null, arguments);
});
var _hs_content_dec_syntverf_disp = Module["_hs_content_dec_syntverf_disp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_syntverf_disp"].apply(null, arguments);
});
var _hs_content_dec_syntverf_type = Module["_hs_content_dec_syntverf_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_syntverf_type"].apply(null, arguments);
});
var _hs_content_dec_tokenval = Module["_hs_content_dec_tokenval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_dec_tokenval"].apply(null, arguments);
});
var _hs_content_disp_copy = Module["_hs_content_disp_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_copy"].apply(null, arguments);
});
var _hs_content_disp_create = Module["_hs_content_disp_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_create"].apply(null, arguments);
});
var _hs_content_disp_create_copy = Module["_hs_content_disp_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_create_copy"].apply(null, arguments);
});
var _hs_content_disp_create_default = Module["_hs_content_disp_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_create_default"].apply(null, arguments);
});
var _hs_content_disp_free = Module["_hs_content_disp_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_free"].apply(null, arguments);
});
var _hs_content_disp_free_internal = Module["_hs_content_disp_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_free_internal"].apply(null, arguments);
});
var _hs_content_disp_get_param = Module["_hs_content_disp_get_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_get_param"].apply(null, arguments);
});
var _hs_content_disp_get_type = Module["_hs_content_disp_get_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_get_type"].apply(null, arguments);
});
var _hs_content_disp_init = Module["_hs_content_disp_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_disp_init"].apply(null, arguments);
});
var _hs_content_free = Module["_hs_content_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_free"].apply(null, arguments);
});
var _hs_content_free_internal = Module["_hs_content_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_free_internal"].apply(null, arguments);
});
var _hs_content_get_body = Module["_hs_content_get_body"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_body"].apply(null, arguments);
});
var _hs_content_get_disp = Module["_hs_content_get_disp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_disp"].apply(null, arguments);
});
var _hs_content_get_enc_list = Module["_hs_content_get_enc_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_enc_list"].apply(null, arguments);
});
var _hs_content_get_lang_list = Module["_hs_content_get_lang_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_lang_list"].apply(null, arguments);
});
var _hs_content_get_length = Module["_hs_content_get_length"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_length"].apply(null, arguments);
});
var _hs_content_get_media_sub_type = Module["_hs_content_get_media_sub_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_media_sub_type"].apply(null, arguments);
});
var _hs_content_get_media_type = Module["_hs_content_get_media_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_media_type"].apply(null, arguments);
});
var _hs_content_get_mime_body = Module["_hs_content_get_mime_body"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_mime_body"].apply(null, arguments);
});
var _hs_content_get_type = Module["_hs_content_get_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_get_type"].apply(null, arguments);
});
var _hs_content_is_mime = Module["_hs_content_is_mime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_is_mime"].apply(null, arguments);
});
var _hs_content_mime_part_append = Module["_hs_content_mime_part_append"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_mime_part_append"].apply(null, arguments);
});
var _hs_content_set_disp = Module["_hs_content_set_disp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_set_disp"].apply(null, arguments);
});
var _hs_content_type_copy = Module["_hs_content_type_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_copy"].apply(null, arguments);
});
var _hs_content_type_create = Module["_hs_content_type_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_create"].apply(null, arguments);
});
var _hs_content_type_create_copy = Module["_hs_content_type_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_create_copy"].apply(null, arguments);
});
var _hs_content_type_create_default = Module["_hs_content_type_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_create_default"].apply(null, arguments);
});
var _hs_content_type_free = Module["_hs_content_type_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_free"].apply(null, arguments);
});
var _hs_content_type_free_internal = Module["_hs_content_type_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_free_internal"].apply(null, arguments);
});
var _hs_content_type_get_media_sub_type = Module["_hs_content_type_get_media_sub_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_get_media_sub_type"].apply(null, arguments);
});
var _hs_content_type_get_media_type = Module["_hs_content_type_get_media_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_get_media_type"].apply(null, arguments);
});
var _hs_content_type_icompare = Module["_hs_content_type_icompare"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_icompare"].apply(null, arguments);
});
var _hs_content_type_init = Module["_hs_content_type_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_content_type_init"].apply(null, arguments);
});
var _hs_dash_boundary_skip = Module["_hs_dash_boundary_skip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_dash_boundary_skip"].apply(null, arguments);
});
var _hs_eam_alloc_stats = Module["_hs_eam_alloc_stats"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_eam_alloc_stats"].apply(null, arguments);
});
var _hs_eam_free_stats = Module["_hs_eam_free_stats"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_eam_free_stats"].apply(null, arguments);
});
var _hs_eam_free_stats_db = Module["_hs_eam_free_stats_db"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_eam_free_stats_db"].apply(null, arguments);
});
var _hs_fwk_add_msgtotimer_table = Module["_hs_fwk_add_msgtotimer_table"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_add_msgtotimer_table"].apply(null, arguments);
});
var _hs_fwk_alg_handle_pcscf_change = Module["_hs_fwk_alg_handle_pcscf_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_alg_handle_pcscf_change"].apply(null, arguments);
});
var _hs_fwk_base64_decode = Module["_hs_fwk_base64_decode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_base64_decode"].apply(null, arguments);
});
var _hs_fwk_base64_encode = Module["_hs_fwk_base64_encode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_base64_encode"].apply(null, arguments);
});
var _hs_fwk_base64_encoded_size = Module["_hs_fwk_base64_encoded_size"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_base64_encoded_size"].apply(null, arguments);
});
var _hs_fwk_binstrnstr = Module["_hs_fwk_binstrnstr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_binstrnstr"].apply(null, arguments);
});
var _hs_fwk_build_sip_uri = Module["_hs_fwk_build_sip_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_build_sip_uri"].apply(null, arguments);
});
var _hs_fwk_build_sips_uri = Module["_hs_fwk_build_sips_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_build_sips_uri"].apply(null, arguments);
});
var _hs_fwk_build_siptls_uri = Module["_hs_fwk_build_siptls_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_build_siptls_uri"].apply(null, arguments);
});
var _hs_fwk_build_tel_uri = Module["_hs_fwk_build_tel_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_build_tel_uri"].apply(null, arguments);
});
var _hs_fwk_build_uri_string = Module["_hs_fwk_build_uri_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_build_uri_string"].apply(null, arguments);
});
var _hs_fwk_byte_swap = Module["_hs_fwk_byte_swap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_byte_swap"].apply(null, arguments);
});
var _hs_fwk_check_directory = Module["_hs_fwk_check_directory"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_check_directory"].apply(null, arguments);
});
var _hs_fwk_check_platform_compatibility = Module["_hs_fwk_check_platform_compatibility"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_check_platform_compatibility"].apply(null, arguments);
});
var _hs_fwk_clear_hash = Module["_hs_fwk_clear_hash"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_clear_hash"].apply(null, arguments);
});
var _hs_fwk_clrspace = Module["_hs_fwk_clrspace"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_clrspace"].apply(null, arguments);
});
var _hs_fwk_cond_destroy = Module["_hs_fwk_cond_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_cond_destroy"].apply(null, arguments);
});
var _hs_fwk_cond_init = Module["_hs_fwk_cond_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_cond_init"].apply(null, arguments);
});
var _hs_fwk_cond_signal = Module["_hs_fwk_cond_signal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_cond_signal"].apply(null, arguments);
});
var _hs_fwk_cond_timedwait = Module["_hs_fwk_cond_timedwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_cond_timedwait"].apply(null, arguments);
});
var _hs_fwk_cond_wait = Module["_hs_fwk_cond_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_cond_wait"].apply(null, arguments);
});
var _hs_fwk_convt2sip_uri_str = Module["_hs_fwk_convt2sip_uri_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_convt2sip_uri_str"].apply(null, arguments);
});
var _hs_fwk_convt_tel2sip_uri = Module["_hs_fwk_convt_tel2sip_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_convt_tel2sip_uri"].apply(null, arguments);
});
var _hs_fwk_copy_dir = Module["_hs_fwk_copy_dir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_copy_dir"].apply(null, arguments);
});
var _hs_fwk_copy_dir_contents = Module["_hs_fwk_copy_dir_contents"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_copy_dir_contents"].apply(null, arguments);
});
var _hs_fwk_copy_file = Module["_hs_fwk_copy_file"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_copy_file"].apply(null, arguments);
});
var _hs_fwk_create_directory = Module["_hs_fwk_create_directory"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_create_directory"].apply(null, arguments);
});
var _hs_fwk_create_directory_tree = Module["_hs_fwk_create_directory_tree"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_create_directory_tree"].apply(null, arguments);
});
var _hs_fwk_dec_1123date = Module["_hs_fwk_dec_1123date"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_1123date"].apply(null, arguments);
});
var _hs_fwk_dec_date = Module["_hs_fwk_dec_date"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_date"].apply(null, arguments);
});
var _hs_fwk_dec_globalnumber = Module["_hs_fwk_dec_globalnumber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_globalnumber"].apply(null, arguments);
});
var _hs_fwk_dec_header_param = Module["_hs_fwk_dec_header_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_header_param"].apply(null, arguments);
});
var _hs_fwk_dec_hex4 = Module["_hs_fwk_dec_hex4"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_hex4"].apply(null, arguments);
});
var _hs_fwk_dec_hostaddress = Module["_hs_fwk_dec_hostaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_hostaddress"].apply(null, arguments);
});
var _hs_fwk_dec_hostname = Module["_hs_fwk_dec_hostname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_hostname"].apply(null, arguments);
});
var _hs_fwk_dec_ipv4address = Module["_hs_fwk_dec_ipv4address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_ipv4address"].apply(null, arguments);
});
var _hs_fwk_dec_ipv6address = Module["_hs_fwk_dec_ipv6address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_ipv6address"].apply(null, arguments);
});
var _hs_fwk_dec_localnumber = Module["_hs_fwk_dec_localnumber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_localnumber"].apply(null, arguments);
});
var _hs_fwk_dec_month = Module["_hs_fwk_dec_month"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_month"].apply(null, arguments);
});
var _hs_fwk_dec_time = Module["_hs_fwk_dec_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_time"].apply(null, arguments);
});
var _hs_fwk_dec_timezone = Module["_hs_fwk_dec_timezone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_timezone"].apply(null, arguments);
});
var _hs_fwk_dec_uri = Module["_hs_fwk_dec_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_uri"].apply(null, arguments);
});
var _hs_fwk_dec_uri_ext = Module["_hs_fwk_dec_uri_ext"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_uri_ext"].apply(null, arguments);
});
var _hs_fwk_dec_uri_internal = Module["_hs_fwk_dec_uri_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_uri_internal"].apply(null, arguments);
});
var _hs_fwk_dec_url_parse_headers = Module["_hs_fwk_dec_url_parse_headers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_url_parse_headers"].apply(null, arguments);
});
var _hs_fwk_dec_url_parse_params = Module["_hs_fwk_dec_url_parse_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_url_parse_params"].apply(null, arguments);
});
var _hs_fwk_dec_wkday = Module["_hs_fwk_dec_wkday"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dec_wkday"].apply(null, arguments);
});
var _hs_fwk_del_msgfromtimer_table = Module["_hs_fwk_del_msgfromtimer_table"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_del_msgfromtimer_table"].apply(null, arguments);
});
var _hs_fwk_destroy_uri = Module["_hs_fwk_destroy_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_destroy_uri"].apply(null, arguments);
});
var _hs_fwk_dlist_destroy = Module["_hs_fwk_dlist_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dlist_destroy"].apply(null, arguments);
});
var _hs_fwk_dlist_init = Module["_hs_fwk_dlist_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dlist_init"].apply(null, arguments);
});
var _hs_fwk_dlist_ins_node = Module["_hs_fwk_dlist_ins_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dlist_ins_node"].apply(null, arguments);
});
var _hs_fwk_dlist_rem_node = Module["_hs_fwk_dlist_rem_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dlist_rem_node"].apply(null, arguments);
});
var _hs_fwk_dns_add_a_record_to_cache = Module["_hs_fwk_dns_add_a_record_to_cache"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_add_a_record_to_cache"].apply(null, arguments);
});
var _hs_fwk_dns_add_dns_server = Module["_hs_fwk_dns_add_dns_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_add_dns_server"].apply(null, arguments);
});
var _hs_fwk_dns_add_record_to_cache = Module["_hs_fwk_dns_add_record_to_cache"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_add_record_to_cache"].apply(null, arguments);
});
var _hs_fwk_dns_add_record_to_list = Module["_hs_fwk_dns_add_record_to_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_add_record_to_list"].apply(null, arguments);
});
var _hs_fwk_dns_add_uri_to_list = Module["_hs_fwk_dns_add_uri_to_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_add_uri_to_list"].apply(null, arguments);
});
var _hs_fwk_dns_build_app_response = Module["_hs_fwk_dns_build_app_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_build_app_response"].apply(null, arguments);
});
var _hs_fwk_dns_build_aquery_app_response = Module["_hs_fwk_dns_build_aquery_app_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_build_aquery_app_response"].apply(null, arguments);
});
var _hs_fwk_dns_build_enum_resp_resolve_uri = Module["_hs_fwk_dns_build_enum_resp_resolve_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_build_enum_resp_resolve_uri"].apply(null, arguments);
});
var _hs_fwk_dns_cache_init = Module["_hs_fwk_dns_cache_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_cache_init"].apply(null, arguments);
});
var _hs_fwk_dns_cache_insert_record = Module["_hs_fwk_dns_cache_insert_record"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_cache_insert_record"].apply(null, arguments);
});
var _hs_fwk_dns_cache_lookup = Module["_hs_fwk_dns_cache_lookup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_cache_lookup"].apply(null, arguments);
});
var _hs_fwk_dns_cache_remove_lru_records = Module["_hs_fwk_dns_cache_remove_lru_records"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_cache_remove_lru_records"].apply(null, arguments);
});
var _hs_fwk_dns_cache_shutdown = Module["_hs_fwk_dns_cache_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_cache_shutdown"].apply(null, arguments);
});
var _hs_fwk_dns_cache_update_records = Module["_hs_fwk_dns_cache_update_records"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_cache_update_records"].apply(null, arguments);
});
var _hs_fwk_dns_cache_user_dns_info = Module["_hs_fwk_dns_cache_user_dns_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_cache_user_dns_info"].apply(null, arguments);
});
var _hs_fwk_dns_char_string_parse = Module["_hs_fwk_dns_char_string_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_char_string_parse"].apply(null, arguments);
});
var _hs_fwk_dns_clear_cache = Module["_hs_fwk_dns_clear_cache"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_clear_cache"].apply(null, arguments);
});
var _hs_fwk_dns_clear_dup_arec = Module["_hs_fwk_dns_clear_dup_arec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_clear_dup_arec"].apply(null, arguments);
});
var _hs_fwk_dns_clear_head_entry = Module["_hs_fwk_dns_clear_head_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_clear_head_entry"].apply(null, arguments);
});
var _hs_fwk_dns_delete_dns_server = Module["_hs_fwk_dns_delete_dns_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_delete_dns_server"].apply(null, arguments);
});
var _hs_fwk_dns_delete_node_from_list = Module["_hs_fwk_dns_delete_node_from_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_delete_node_from_list"].apply(null, arguments);
});
var _hs_fwk_dns_domain_name_parse = Module["_hs_fwk_dns_domain_name_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_domain_name_parse"].apply(null, arguments);
});
var _hs_fwk_dns_fill_hints = Module["_hs_fwk_dns_fill_hints"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_fill_hints"].apply(null, arguments);
});
var _hs_fwk_dns_find_records = Module["_hs_fwk_dns_find_records"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_find_records"].apply(null, arguments);
});
var _hs_fwk_dns_get_address_from_cache = Module["_hs_fwk_dns_get_address_from_cache"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_address_from_cache"].apply(null, arguments);
});
var _hs_fwk_dns_get_current_dns_server = Module["_hs_fwk_dns_get_current_dns_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_current_dns_server"].apply(null, arguments);
});
var _hs_fwk_dns_get_current_time = Module["_hs_fwk_dns_get_current_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_current_time"].apply(null, arguments);
});
var _hs_fwk_dns_get_e164_qname = Module["_hs_fwk_dns_get_e164_qname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_e164_qname"].apply(null, arguments);
});
var _hs_fwk_dns_get_ip_addr_records = Module["_hs_fwk_dns_get_ip_addr_records"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_ip_addr_records"].apply(null, arguments);
});
var _hs_fwk_dns_get_naptr_records_for_enum = Module["_hs_fwk_dns_get_naptr_records_for_enum"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_naptr_records_for_enum"].apply(null, arguments);
});
var _hs_fwk_dns_get_records_for_naptr = Module["_hs_fwk_dns_get_records_for_naptr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_records_for_naptr"].apply(null, arguments);
});
var _hs_fwk_dns_get_service = Module["_hs_fwk_dns_get_service"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_service"].apply(null, arguments);
});
var _hs_fwk_dns_get_srv_data = Module["_hs_fwk_dns_get_srv_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_srv_data"].apply(null, arguments);
});
var _hs_fwk_dns_get_srv_qname = Module["_hs_fwk_dns_get_srv_qname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_srv_qname"].apply(null, arguments);
});
var _hs_fwk_dns_get_srv_records = Module["_hs_fwk_dns_get_srv_records"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_srv_records"].apply(null, arguments);
});
var _hs_fwk_dns_get_uri_from_naptr = Module["_hs_fwk_dns_get_uri_from_naptr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_uri_from_naptr"].apply(null, arguments);
});
var _hs_fwk_dns_get_valid_naptr_records = Module["_hs_fwk_dns_get_valid_naptr_records"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_get_valid_naptr_records"].apply(null, arguments);
});
var _hs_fwk_dns_handle_a_response = Module["_hs_fwk_dns_handle_a_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_handle_a_response"].apply(null, arguments);
});
var _hs_fwk_dns_handle_enum_response = Module["_hs_fwk_dns_handle_enum_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_handle_enum_response"].apply(null, arguments);
});
var _hs_fwk_dns_handle_naptr_response = Module["_hs_fwk_dns_handle_naptr_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_handle_naptr_response"].apply(null, arguments);
});
var _hs_fwk_dns_init = Module["_hs_fwk_dns_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_init"].apply(null, arguments);
});
var _hs_fwk_dns_init_response = Module["_hs_fwk_dns_init_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_init_response"].apply(null, arguments);
});
var _hs_fwk_dns_initiate_srv_queries = Module["_hs_fwk_dns_initiate_srv_queries"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_initiate_srv_queries"].apply(null, arguments);
});
var _hs_fwk_dns_insert_node_into_list = Module["_hs_fwk_dns_insert_node_into_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_insert_node_into_list"].apply(null, arguments);
});
var _hs_fwk_dns_is_cache_present = Module["_hs_fwk_dns_is_cache_present"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_is_cache_present"].apply(null, arguments);
});
var _hs_fwk_dns_is_initialized = Module["_hs_fwk_dns_is_initialized"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_is_initialized"].apply(null, arguments);
});
var _hs_fwk_dns_match_requirements = Module["_hs_fwk_dns_match_requirements"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_match_requirements"].apply(null, arguments);
});
var _hs_fwk_dns_message_free = Module["_hs_fwk_dns_message_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_message_free"].apply(null, arguments);
});
var _hs_fwk_dns_msg_build_qname = Module["_hs_fwk_dns_msg_build_qname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_msg_build_qname"].apply(null, arguments);
});
var _hs_fwk_dns_msg_build_request = Module["_hs_fwk_dns_msg_build_request"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_msg_build_request"].apply(null, arguments);
});
var _hs_fwk_dns_msg_parse = Module["_hs_fwk_dns_msg_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_msg_parse"].apply(null, arguments);
});
var _hs_fwk_dns_msg_question_parse = Module["_hs_fwk_dns_msg_question_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_msg_question_parse"].apply(null, arguments);
});
var _hs_fwk_dns_msg_rr_parse = Module["_hs_fwk_dns_msg_rr_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_msg_rr_parse"].apply(null, arguments);
});
var _hs_fwk_dns_msg_validate_header = Module["_hs_fwk_dns_msg_validate_header"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_msg_validate_header"].apply(null, arguments);
});
var _hs_fwk_dns_msg_validate_question = Module["_hs_fwk_dns_msg_validate_question"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_msg_validate_question"].apply(null, arguments);
});
var _hs_fwk_dns_naptr_get_flag_field = Module["_hs_fwk_dns_naptr_get_flag_field"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_naptr_get_flag_field"].apply(null, arguments);
});
var _hs_fwk_dns_naptr_get_service = Module["_hs_fwk_dns_naptr_get_service"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_naptr_get_service"].apply(null, arguments);
});
var _hs_fwk_dns_naptr_get_service_tprotocol = Module["_hs_fwk_dns_naptr_get_service_tprotocol"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_naptr_get_service_tprotocol"].apply(null, arguments);
});
var _hs_fwk_dns_naptr_sort_best_list = Module["_hs_fwk_dns_naptr_sort_best_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_naptr_sort_best_list"].apply(null, arguments);
});
var _hs_fwk_dns_network_init = Module["_hs_fwk_dns_network_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_network_init"].apply(null, arguments);
});
var _hs_fwk_dns_resolve = Module["_hs_fwk_dns_resolve"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_a_query = Module["_hs_fwk_dns_resolve_a_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_a_query"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_address_query = Module["_hs_fwk_dns_resolve_address_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_address_query"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_e164_num = Module["_hs_fwk_dns_resolve_e164_num"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_e164_num"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_enum_query = Module["_hs_fwk_dns_resolve_enum_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_enum_query"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_fqdn = Module["_hs_fwk_dns_resolve_fqdn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_fqdn"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_naptr_query = Module["_hs_fwk_dns_resolve_naptr_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_naptr_query"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_sip_uri = Module["_hs_fwk_dns_resolve_sip_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_sip_uri"].apply(null, arguments);
});
var _hs_fwk_dns_resolve_srv_query = Module["_hs_fwk_dns_resolve_srv_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_resolve_srv_query"].apply(null, arguments);
});
var _hs_fwk_dns_response_handler = Module["_hs_fwk_dns_response_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_response_handler"].apply(null, arguments);
});
var _hs_fwk_dns_send_and_receive = Module["_hs_fwk_dns_send_and_receive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_send_and_receive"].apply(null, arguments);
});
var _hs_fwk_dns_send_query = Module["_hs_fwk_dns_send_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_send_query"].apply(null, arguments);
});
var _hs_fwk_dns_shutdown = Module["_hs_fwk_dns_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_shutdown"].apply(null, arguments);
});
var _hs_fwk_dns_srv_sort_best_list = Module["_hs_fwk_dns_srv_sort_best_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_srv_sort_best_list"].apply(null, arguments);
});
var _hs_fwk_dns_trans_info_free = Module["_hs_fwk_dns_trans_info_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_trans_info_free"].apply(null, arguments);
});
var _hs_fwk_dns_transact_init = Module["_hs_fwk_dns_transact_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_transact_init"].apply(null, arguments);
});
var _hs_fwk_dns_transact_shutdown = Module["_hs_fwk_dns_transact_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_transact_shutdown"].apply(null, arguments);
});
var _hs_fwk_dns_validate_dnserver_info = Module["_hs_fwk_dns_validate_dnserver_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_validate_dnserver_info"].apply(null, arguments);
});
var _hs_fwk_dns_validate_fqdn = Module["_hs_fwk_dns_validate_fqdn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_validate_fqdn"].apply(null, arguments);
});
var _hs_fwk_dns_validate_input_params = Module["_hs_fwk_dns_validate_input_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_validate_input_params"].apply(null, arguments);
});
var _hs_fwk_dns_validate_naptr_for_enum = Module["_hs_fwk_dns_validate_naptr_for_enum"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_validate_naptr_for_enum"].apply(null, arguments);
});
var _hs_fwk_dns_validate_naptr_service = Module["_hs_fwk_dns_validate_naptr_service"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dns_validate_naptr_service"].apply(null, arguments);
});
var _hs_fwk_dtm_add_sockoptions = Module["_hs_fwk_dtm_add_sockoptions"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_add_sockoptions"].apply(null, arguments);
});
var _hs_fwk_dtm_check_sockinfo = Module["_hs_fwk_dtm_check_sockinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_check_sockinfo"].apply(null, arguments);
});
var _hs_fwk_dtm_copy_connparams = Module["_hs_fwk_dtm_copy_connparams"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_copy_connparams"].apply(null, arguments);
});
var _hs_fwk_dtm_create_conn = Module["_hs_fwk_dtm_create_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_create_conn"].apply(null, arguments);
});
var _hs_fwk_dtm_create_loopback_internal = Module["_hs_fwk_dtm_create_loopback_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_create_loopback_internal"].apply(null, arguments);
});
var _hs_fwk_dtm_create_loopback_sockets = Module["_hs_fwk_dtm_create_loopback_sockets"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_create_loopback_sockets"].apply(null, arguments);
});
var _hs_fwk_dtm_create_sockinfo_accptdconn = Module["_hs_fwk_dtm_create_sockinfo_accptdconn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_create_sockinfo_accptdconn"].apply(null, arguments);
});
var _hs_fwk_dtm_del_conn = Module["_hs_fwk_dtm_del_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_del_conn"].apply(null, arguments);
});
var _hs_fwk_dtm_evt_free = Module["_hs_fwk_dtm_evt_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_evt_free"].apply(null, arguments);
});
var _hs_fwk_dtm_free_data = Module["_hs_fwk_dtm_free_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_free_data"].apply(null, arguments);
});
var _hs_fwk_dtm_free_sockinfo = Module["_hs_fwk_dtm_free_sockinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_free_sockinfo"].apply(null, arguments);
});
var _hs_fwk_dtm_get_app_bydata = Module["_hs_fwk_dtm_get_app_bydata"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_get_app_bydata"].apply(null, arguments);
});
var _hs_fwk_dtm_hndle_selerr = Module["_hs_fwk_dtm_hndle_selerr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_hndle_selerr"].apply(null, arguments);
});
var _hs_fwk_dtm_init = Module["_hs_fwk_dtm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_init"].apply(null, arguments);
});
var _hs_fwk_dtm_init_connparams = Module["_hs_fwk_dtm_init_connparams"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_init_connparams"].apply(null, arguments);
});
var _hs_fwk_dtm_is_turn_pkt = Module["_hs_fwk_dtm_is_turn_pkt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_is_turn_pkt"].apply(null, arguments);
});
var _hs_fwk_dtm_post_wasm_evt = Module["_hs_fwk_dtm_post_wasm_evt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_post_wasm_evt"].apply(null, arguments);
});
var _hs_fwk_dtm_process_nwk_event = Module["_hs_fwk_dtm_process_nwk_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_process_nwk_event"].apply(null, arguments);
});
var _hs_fwk_dtm_send_data = Module["_hs_fwk_dtm_send_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_send_data"].apply(null, arguments);
});
var _hs_fwk_dtm_send_data_from_buf = Module["_hs_fwk_dtm_send_data_from_buf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_send_data_from_buf"].apply(null, arguments);
});
var _hs_fwk_dtm_shutdown = Module["_hs_fwk_dtm_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_shutdown"].apply(null, arguments);
});
var _hs_fwk_dtm_sndapp_evt = Module["_hs_fwk_dtm_sndapp_evt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_sndapp_evt"].apply(null, arguments);
});
var _hs_fwk_dtm_sockinfo_add_appctx = Module["_hs_fwk_dtm_sockinfo_add_appctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_sockinfo_add_appctx"].apply(null, arguments);
});
var _hs_fwk_dtm_sockoptions_create = Module["_hs_fwk_dtm_sockoptions_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_sockoptions_create"].apply(null, arguments);
});
var _hs_fwk_dtm_start = Module["_hs_fwk_dtm_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_start"].apply(null, arguments);
});
var _hs_fwk_dtm_stop = Module["_hs_fwk_dtm_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_stop"].apply(null, arguments);
});
var _hs_fwk_dtm_thrd = Module["_hs_fwk_dtm_thrd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_thrd"].apply(null, arguments);
});
var _hs_fwk_dtm_thrd_createconn = Module["_hs_fwk_dtm_thrd_createconn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_thrd_createconn"].apply(null, arguments);
});
var _hs_fwk_dtm_thrd_delconn = Module["_hs_fwk_dtm_thrd_delconn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_thrd_delconn"].apply(null, arguments);
});
var _hs_fwk_dtm_thrd_snddata = Module["_hs_fwk_dtm_thrd_snddata"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_thrd_snddata"].apply(null, arguments);
});
var _hs_fwk_dtm_thrd_udpconn = Module["_hs_fwk_dtm_thrd_udpconn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_thrd_udpconn"].apply(null, arguments);
});
var _hs_fwk_dtm_udp_init_conn = Module["_hs_fwk_dtm_udp_init_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_udp_init_conn"].apply(null, arguments);
});
var _hs_fwk_dtm_update_fd_list = Module["_hs_fwk_dtm_update_fd_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_update_fd_list"].apply(null, arguments);
});
var _hs_fwk_dtm_wasm_change_txproto = Module["_hs_fwk_dtm_wasm_change_txproto"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dtm_wasm_change_txproto"].apply(null, arguments);
});
var _hs_fwk_dyn_array_copy = Module["_hs_fwk_dyn_array_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dyn_array_copy"].apply(null, arguments);
});
var _hs_fwk_dyn_array_free = Module["_hs_fwk_dyn_array_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_dyn_array_free"].apply(null, arguments);
});
var _hs_fwk_encode_uri = Module["_hs_fwk_encode_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_encode_uri"].apply(null, arguments);
});
var _hs_fwk_event_dispatcher = Module["_hs_fwk_event_dispatcher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_event_dispatcher"].apply(null, arguments);
});
var _hs_fwk_evtdisp_create = Module["_hs_fwk_evtdisp_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_create"].apply(null, arguments);
});
var _hs_fwk_evtdisp_dereg_mod = Module["_hs_fwk_evtdisp_dereg_mod"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_dereg_mod"].apply(null, arguments);
});
var _hs_fwk_evtdisp_destroy = Module["_hs_fwk_evtdisp_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_destroy"].apply(null, arguments);
});
var _hs_fwk_evtdisp_free = Module["_hs_fwk_evtdisp_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_free"].apply(null, arguments);
});
var _hs_fwk_evtdisp_get = Module["_hs_fwk_evtdisp_get"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_get"].apply(null, arguments);
});
var _hs_fwk_evtdisp_init = Module["_hs_fwk_evtdisp_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_init"].apply(null, arguments);
});
var _hs_fwk_evtdisp_mod_free = Module["_hs_fwk_evtdisp_mod_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_mod_free"].apply(null, arguments);
});
var _hs_fwk_evtdisp_mod_getid = Module["_hs_fwk_evtdisp_mod_getid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_mod_getid"].apply(null, arguments);
});
var _hs_fwk_evtdisp_mod_getname = Module["_hs_fwk_evtdisp_mod_getname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_mod_getname"].apply(null, arguments);
});
var _hs_fwk_evtdisp_post_evt = Module["_hs_fwk_evtdisp_post_evt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_post_evt"].apply(null, arguments);
});
var _hs_fwk_evtdisp_reg_mod = Module["_hs_fwk_evtdisp_reg_mod"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_reg_mod"].apply(null, arguments);
});
var _hs_fwk_evtdisp_shutdown = Module["_hs_fwk_evtdisp_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_shutdown"].apply(null, arguments);
});
var _hs_fwk_evtdisp_start = Module["_hs_fwk_evtdisp_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_start"].apply(null, arguments);
});
var _hs_fwk_evtdisp_stop = Module["_hs_fwk_evtdisp_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_evtdisp_stop"].apply(null, arguments);
});
var _hs_fwk_generic_param_compare = Module["_hs_fwk_generic_param_compare"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_generic_param_compare"].apply(null, arguments);
});
var _hs_fwk_generic_param_create = Module["_hs_fwk_generic_param_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_generic_param_create"].apply(null, arguments);
});
var _hs_fwk_generic_param_create_copy = Module["_hs_fwk_generic_param_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_generic_param_create_copy"].apply(null, arguments);
});
var _hs_fwk_generic_param_free = Module["_hs_fwk_generic_param_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_generic_param_free"].apply(null, arguments);
});
var _hs_fwk_generic_param_get_value = Module["_hs_fwk_generic_param_get_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_generic_param_get_value"].apply(null, arguments);
});
var _hs_fwk_generic_param_match = Module["_hs_fwk_generic_param_match"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_generic_param_match"].apply(null, arguments);
});
var _hs_fwk_generic_param_remove_node = Module["_hs_fwk_generic_param_remove_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_generic_param_remove_node"].apply(null, arguments);
});
var _hs_fwk_get_addr_family = Module["_hs_fwk_get_addr_family"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_addr_family"].apply(null, arguments);
});
var _hs_fwk_get_celldata_subtype_str = Module["_hs_fwk_get_celldata_subtype_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_celldata_subtype_str"].apply(null, arguments);
});
var _hs_fwk_get_conntype_str = Module["_hs_fwk_get_conntype_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_conntype_str"].apply(null, arguments);
});
var _hs_fwk_get_curtime = Module["_hs_fwk_get_curtime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_curtime"].apply(null, arguments);
});
var _hs_fwk_get_filesize = Module["_hs_fwk_get_filesize"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_filesize"].apply(null, arguments);
});
var _hs_fwk_get_localtime_utc_offset_str = Module["_hs_fwk_get_localtime_utc_offset_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_localtime_utc_offset_str"].apply(null, arguments);
});
var _hs_fwk_get_loopback_address = Module["_hs_fwk_get_loopback_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_loopback_address"].apply(null, arguments);
});
var _hs_fwk_get_sock_name = Module["_hs_fwk_get_sock_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_sock_name"].apply(null, arguments);
});
var _hs_fwk_get_timeoffset = Module["_hs_fwk_get_timeoffset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_get_timeoffset"].apply(null, arguments);
});
var _hs_fwk_if_basicuri_match = Module["_hs_fwk_if_basicuri_match"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_if_basicuri_match"].apply(null, arguments);
});
var _hs_fwk_if_basicuri_match_ext = Module["_hs_fwk_if_basicuri_match_ext"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_if_basicuri_match_ext"].apply(null, arguments);
});
var _hs_fwk_if_tel_urls_match = Module["_hs_fwk_if_tel_urls_match"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_if_tel_urls_match"].apply(null, arguments);
});
var _hs_fwk_init = Module["_hs_fwk_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_init"].apply(null, arguments);
});
var _hs_fwk_init_hash = Module["_hs_fwk_init_hash"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_init_hash"].apply(null, arguments);
});
var _hs_fwk_init_uri = Module["_hs_fwk_init_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_init_uri"].apply(null, arguments);
});
var _hs_fwk_ip_cmp = Module["_hs_fwk_ip_cmp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_ip_cmp"].apply(null, arguments);
});
var _hs_fwk_ipv6mapaddr_2ipv4addr = Module["_hs_fwk_ipv6mapaddr_2ipv4addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_ipv6mapaddr_2ipv4addr"].apply(null, arguments);
});
var _hs_fwk_is_file_present = Module["_hs_fwk_is_file_present"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_is_file_present"].apply(null, arguments);
});
var _hs_fwk_is_phone_nbr = Module["_hs_fwk_is_phone_nbr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_is_phone_nbr"].apply(null, arguments);
});
var _hs_fwk_is_valid_ipaddress = Module["_hs_fwk_is_valid_ipaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_is_valid_ipaddress"].apply(null, arguments);
});
var _hs_fwk_list_append = Module["_hs_fwk_list_append"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_append"].apply(null, arguments);
});
var _hs_fwk_list_deep_copy = Module["_hs_fwk_list_deep_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_deep_copy"].apply(null, arguments);
});
var _hs_fwk_list_destroy = Module["_hs_fwk_list_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_destroy"].apply(null, arguments);
});
var _hs_fwk_list_dir_content = Module["_hs_fwk_list_dir_content"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_dir_content"].apply(null, arguments);
});
var _hs_fwk_list_get_data = Module["_hs_fwk_list_get_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_get_data"].apply(null, arguments);
});
var _hs_fwk_list_init = Module["_hs_fwk_list_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_init"].apply(null, arguments);
});
var _hs_fwk_list_ins_next = Module["_hs_fwk_list_ins_next"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_ins_next"].apply(null, arguments);
});
var _hs_fwk_list_is_equal = Module["_hs_fwk_list_is_equal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_is_equal"].apply(null, arguments);
});
var _hs_fwk_list_rem_next = Module["_hs_fwk_list_rem_next"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_rem_next"].apply(null, arguments);
});
var _hs_fwk_list_rem_node = Module["_hs_fwk_list_rem_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_rem_node"].apply(null, arguments);
});
var _hs_fwk_list_reverse = Module["_hs_fwk_list_reverse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_list_reverse"].apply(null, arguments);
});
var _hs_fwk_lm_get_log_level = Module["_hs_fwk_lm_get_log_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_get_log_level"].apply(null, arguments);
});
var _hs_fwk_lm_init = Module["_hs_fwk_lm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_init"].apply(null, arguments);
});
var _hs_fwk_lm_is_siplog_enabled = Module["_hs_fwk_lm_is_siplog_enabled"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_is_siplog_enabled"].apply(null, arguments);
});
var _hs_fwk_lm_is_sysstats_enabled = Module["_hs_fwk_lm_is_sysstats_enabled"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_is_sysstats_enabled"].apply(null, arguments);
});
var _hs_fwk_lm_set_log_dir_limits = Module["_hs_fwk_lm_set_log_dir_limits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_set_log_dir_limits"].apply(null, arguments);
});
var _hs_fwk_lm_set_log_level = Module["_hs_fwk_lm_set_log_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_set_log_level"].apply(null, arguments);
});
var _hs_fwk_lm_set_siplog = Module["_hs_fwk_lm_set_siplog"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_set_siplog"].apply(null, arguments);
});
var _hs_fwk_lm_shutdown = Module["_hs_fwk_lm_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_lm_shutdown"].apply(null, arguments);
});
var _hs_fwk_log_create_post = Module["_hs_fwk_log_create_post"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_log_create_post"].apply(null, arguments);
});
var _hs_fwk_log_msg = Module["_hs_fwk_log_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_log_msg"].apply(null, arguments);
});
var _hs_fwk_log_sip_msg = Module["_hs_fwk_log_sip_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_log_sip_msg"].apply(null, arguments);
});
var _hs_fwk_log_sys_stats = Module["_hs_fwk_log_sys_stats"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_log_sys_stats"].apply(null, arguments);
});
var _hs_fwk_logger_init = Module["_hs_fwk_logger_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_init"].apply(null, arguments);
});
var _hs_fwk_logger_open_log = Module["_hs_fwk_logger_open_log"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_open_log"].apply(null, arguments);
});
var _hs_fwk_logger_post_msg = Module["_hs_fwk_logger_post_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_post_msg"].apply(null, arguments);
});
var _hs_fwk_logger_prune_logs = Module["_hs_fwk_logger_prune_logs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_prune_logs"].apply(null, arguments);
});
var _hs_fwk_logger_rotate_logfile = Module["_hs_fwk_logger_rotate_logfile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_rotate_logfile"].apply(null, arguments);
});
var _hs_fwk_logger_shutdown = Module["_hs_fwk_logger_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_shutdown"].apply(null, arguments);
});
var _hs_fwk_logger_start = Module["_hs_fwk_logger_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_start"].apply(null, arguments);
});
var _hs_fwk_logger_stop = Module["_hs_fwk_logger_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_stop"].apply(null, arguments);
});
var _hs_fwk_logger_thread = Module["_hs_fwk_logger_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_logger_thread"].apply(null, arguments);
});
var _hs_fwk_map_enumtoptr = Module["_hs_fwk_map_enumtoptr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_map_enumtoptr"].apply(null, arguments);
});
var _hs_fwk_map_enumtostr = Module["_hs_fwk_map_enumtostr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_map_enumtostr"].apply(null, arguments);
});
var _hs_fwk_map_strtoenum = Module["_hs_fwk_map_strtoenum"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_map_strtoenum"].apply(null, arguments);
});
var _hs_fwk_match_international_prefix = Module["_hs_fwk_match_international_prefix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_match_international_prefix"].apply(null, arguments);
});
var _hs_fwk_match_intl_prefix_and_country_code = Module["_hs_fwk_match_intl_prefix_and_country_code"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_match_intl_prefix_and_country_code"].apply(null, arguments);
});
var _hs_fwk_match_trunk_prefix = Module["_hs_fwk_match_trunk_prefix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_match_trunk_prefix"].apply(null, arguments);
});
var _hs_fwk_mem_alloc_copy = Module["_hs_fwk_mem_alloc_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mem_alloc_copy"].apply(null, arguments);
});
var _hs_fwk_mem_malloc_copy = Module["_hs_fwk_mem_malloc_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mem_malloc_copy"].apply(null, arguments);
});
var _hs_fwk_mem_null_free = Module["_hs_fwk_mem_null_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mem_null_free"].apply(null, arguments);
});
var _hs_fwk_mime_alloc = Module["_hs_fwk_mime_alloc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_alloc"].apply(null, arguments);
});
var _hs_fwk_mime_body_query = Module["_hs_fwk_mime_body_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_body_query"].apply(null, arguments);
});
var _hs_fwk_mime_boundary_query = Module["_hs_fwk_mime_boundary_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_boundary_query"].apply(null, arguments);
});
var _hs_fwk_mime_boundary_set = Module["_hs_fwk_mime_boundary_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_boundary_set"].apply(null, arguments);
});
var _hs_fwk_mime_clear = Module["_hs_fwk_mime_clear"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_clear"].apply(null, arguments);
});
var _hs_fwk_mime_clone = Module["_hs_fwk_mime_clone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_clone"].apply(null, arguments);
});
var _hs_fwk_mime_content_disp_query = Module["_hs_fwk_mime_content_disp_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_content_disp_query"].apply(null, arguments);
});
var _hs_fwk_mime_content_disp_set = Module["_hs_fwk_mime_content_disp_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_content_disp_set"].apply(null, arguments);
});
var _hs_fwk_mime_content_id_query = Module["_hs_fwk_mime_content_id_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_content_id_query"].apply(null, arguments);
});
var _hs_fwk_mime_content_id_set = Module["_hs_fwk_mime_content_id_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_content_id_set"].apply(null, arguments);
});
var _hs_fwk_mime_content_type_query = Module["_hs_fwk_mime_content_type_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_content_type_query"].apply(null, arguments);
});
var _hs_fwk_mime_count = Module["_hs_fwk_mime_count"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_count"].apply(null, arguments);
});
var _hs_fwk_mime_create = Module["_hs_fwk_mime_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_create"].apply(null, arguments);
});
var _hs_fwk_mime_destroy_children = Module["_hs_fwk_mime_destroy_children"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_destroy_children"].apply(null, arguments);
});
var _hs_fwk_mime_encode = Module["_hs_fwk_mime_encode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_encode"].apply(null, arguments);
});
var _hs_fwk_mime_filter_on_contype = Module["_hs_fwk_mime_filter_on_contype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_filter_on_contype"].apply(null, arguments);
});
var _hs_fwk_mime_filterlist_node_destroy = Module["_hs_fwk_mime_filterlist_node_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_filterlist_node_destroy"].apply(null, arguments);
});
var _hs_fwk_mime_header_query = Module["_hs_fwk_mime_header_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_header_query"].apply(null, arguments);
});
var _hs_fwk_mime_is_leaf = Module["_hs_fwk_mime_is_leaf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_is_leaf"].apply(null, arguments);
});
var _hs_fwk_mime_leaf_remove = Module["_hs_fwk_mime_leaf_remove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_leaf_remove"].apply(null, arguments);
});
var _hs_fwk_mime_part_add = Module["_hs_fwk_mime_part_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_part_add"].apply(null, arguments);
});
var _hs_fwk_mime_query = Module["_hs_fwk_mime_query"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_query"].apply(null, arguments);
});
var _hs_fwk_mime_root_decode = Module["_hs_fwk_mime_root_decode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_root_decode"].apply(null, arguments);
});
var _hs_fwk_mime_smime_wrapper_decode = Module["_hs_fwk_mime_smime_wrapper_decode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mime_smime_wrapper_decode"].apply(null, arguments);
});
var _hs_fwk_msgq_create = Module["_hs_fwk_msgq_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_msgq_create"].apply(null, arguments);
});
var _hs_fwk_msgq_delete = Module["_hs_fwk_msgq_delete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_msgq_delete"].apply(null, arguments);
});
var _hs_fwk_msgq_receive = Module["_hs_fwk_msgq_receive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_msgq_receive"].apply(null, arguments);
});
var _hs_fwk_msgq_send = Module["_hs_fwk_msgq_send"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_msgq_send"].apply(null, arguments);
});
var _hs_fwk_mutex_create = Module["_hs_fwk_mutex_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mutex_create"].apply(null, arguments);
});
var _hs_fwk_mutex_destroy = Module["_hs_fwk_mutex_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mutex_destroy"].apply(null, arguments);
});
var _hs_fwk_mutex_lock = Module["_hs_fwk_mutex_lock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mutex_lock"].apply(null, arguments);
});
var _hs_fwk_mutex_unlock = Module["_hs_fwk_mutex_unlock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_mutex_unlock"].apply(null, arguments);
});
var _hs_fwk_parse_addr_port = Module["_hs_fwk_parse_addr_port"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_parse_addr_port"].apply(null, arguments);
});
var _hs_fwk_parse_set_host = Module["_hs_fwk_parse_set_host"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_parse_set_host"].apply(null, arguments);
});
var _hs_fwk_random16 = Module["_hs_fwk_random16"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_random16"].apply(null, arguments);
});
var _hs_fwk_random32 = Module["_hs_fwk_random32"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_random32"].apply(null, arguments);
});
var _hs_fwk_readfile_tobuffer = Module["_hs_fwk_readfile_tobuffer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_readfile_tobuffer"].apply(null, arguments);
});
var _hs_fwk_reg_signal_handler = Module["_hs_fwk_reg_signal_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_reg_signal_handler"].apply(null, arguments);
});
var _hs_fwk_rem_dir_tree = Module["_hs_fwk_rem_dir_tree"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_rem_dir_tree"].apply(null, arguments);
});
var _hs_fwk_remove_file = Module["_hs_fwk_remove_file"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_remove_file"].apply(null, arguments);
});
var _hs_fwk_rename_file = Module["_hs_fwk_rename_file"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_rename_file"].apply(null, arguments);
});
var _hs_fwk_sem_create = Module["_hs_fwk_sem_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sem_create"].apply(null, arguments);
});
var _hs_fwk_sem_delete = Module["_hs_fwk_sem_delete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sem_delete"].apply(null, arguments);
});
var _hs_fwk_sem_lock = Module["_hs_fwk_sem_lock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sem_lock"].apply(null, arguments);
});
var _hs_fwk_sem_unlock = Module["_hs_fwk_sem_unlock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sem_unlock"].apply(null, arguments);
});
var _hs_fwk_shutdown = Module["_hs_fwk_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_shutdown"].apply(null, arguments);
});
var _hs_fwk_signal_handler = Module["_hs_fwk_signal_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_signal_handler"].apply(null, arguments);
});
var _hs_fwk_signal_init = Module["_hs_fwk_signal_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_signal_init"].apply(null, arguments);
});
var _hs_fwk_sm_add_action = Module["_hs_fwk_sm_add_action"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_add_action"].apply(null, arguments);
});
var _hs_fwk_sm_add_state = Module["_hs_fwk_sm_add_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_add_state"].apply(null, arguments);
});
var _hs_fwk_sm_assign_action = Module["_hs_fwk_sm_assign_action"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_assign_action"].apply(null, arguments);
});
var _hs_fwk_sm_chng_state = Module["_hs_fwk_sm_chng_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_chng_state"].apply(null, arguments);
});
var _hs_fwk_sm_condeval = Module["_hs_fwk_sm_condeval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_condeval"].apply(null, arguments);
});
var _hs_fwk_sm_enterstate = Module["_hs_fwk_sm_enterstate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_enterstate"].apply(null, arguments);
});
var _hs_fwk_sm_exec = Module["_hs_fwk_sm_exec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_exec"].apply(null, arguments);
});
var _hs_fwk_sm_free = Module["_hs_fwk_sm_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_free"].apply(null, arguments);
});
var _hs_fwk_sm_getvalue = Module["_hs_fwk_sm_getvalue"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_getvalue"].apply(null, arguments);
});
var _hs_fwk_sm_if_action = Module["_hs_fwk_sm_if_action"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_if_action"].apply(null, arguments);
});
var _hs_fwk_sm_init = Module["_hs_fwk_sm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_init"].apply(null, arguments);
});
var _hs_fwk_sm_param_free = Module["_hs_fwk_sm_param_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_param_free"].apply(null, arguments);
});
var _hs_fwk_sm_parse = Module["_hs_fwk_sm_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_parse"].apply(null, arguments);
});
var _hs_fwk_sm_parse_condexpr = Module["_hs_fwk_sm_parse_condexpr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_parse_condexpr"].apply(null, arguments);
});
var _hs_fwk_sm_send_action = Module["_hs_fwk_sm_send_action"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_send_action"].apply(null, arguments);
});
var _hs_fwk_sm_start = Module["_hs_fwk_sm_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_start"].apply(null, arguments);
});
var _hs_fwk_sm_validate = Module["_hs_fwk_sm_validate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sm_validate"].apply(null, arguments);
});
var _hs_fwk_smaction_add_param = Module["_hs_fwk_smaction_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smaction_add_param"].apply(null, arguments);
});
var _hs_fwk_smaction_create = Module["_hs_fwk_smaction_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smaction_create"].apply(null, arguments);
});
var _hs_fwk_smaction_free = Module["_hs_fwk_smaction_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smaction_free"].apply(null, arguments);
});
var _hs_fwk_smdatamodel_adddata = Module["_hs_fwk_smdatamodel_adddata"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smdatamodel_adddata"].apply(null, arguments);
});
var _hs_fwk_smstate_add_trans = Module["_hs_fwk_smstate_add_trans"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smstate_add_trans"].apply(null, arguments);
});
var _hs_fwk_smstate_create = Module["_hs_fwk_smstate_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smstate_create"].apply(null, arguments);
});
var _hs_fwk_smstate_free = Module["_hs_fwk_smstate_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smstate_free"].apply(null, arguments);
});
var _hs_fwk_smtrans_create = Module["_hs_fwk_smtrans_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smtrans_create"].apply(null, arguments);
});
var _hs_fwk_smtrans_free = Module["_hs_fwk_smtrans_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_smtrans_free"].apply(null, arguments);
});
var _hs_fwk_snprintf = Module["_hs_fwk_snprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_snprintf"].apply(null, arguments);
});
var _hs_fwk_socket_getsockopt = Module["_hs_fwk_socket_getsockopt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_socket_getsockopt"].apply(null, arguments);
});
var _hs_fwk_socket_init = Module["_hs_fwk_socket_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_socket_init"].apply(null, arguments);
});
var _hs_fwk_socket_non_blocking = Module["_hs_fwk_socket_non_blocking"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_socket_non_blocking"].apply(null, arguments);
});
var _hs_fwk_socket_select = Module["_hs_fwk_socket_select"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_socket_select"].apply(null, arguments);
});
var _hs_fwk_socket_set_nwk_mode = Module["_hs_fwk_socket_set_nwk_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_socket_set_nwk_mode"].apply(null, arguments);
});
var _hs_fwk_socket_setsockopt = Module["_hs_fwk_socket_setsockopt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_socket_setsockopt"].apply(null, arguments);
});
var _hs_fwk_socket_shutdown = Module["_hs_fwk_socket_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_socket_shutdown"].apply(null, arguments);
});
var _hs_fwk_stack_create = Module["_hs_fwk_stack_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stack_create"].apply(null, arguments);
});
var _hs_fwk_stack_free_internal = Module["_hs_fwk_stack_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stack_free_internal"].apply(null, arguments);
});
var _hs_fwk_stack_init = Module["_hs_fwk_stack_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stack_init"].apply(null, arguments);
});
var _hs_fwk_stack_isempty = Module["_hs_fwk_stack_isempty"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stack_isempty"].apply(null, arguments);
});
var _hs_fwk_stack_pop = Module["_hs_fwk_stack_pop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stack_pop"].apply(null, arguments);
});
var _hs_fwk_stack_push = Module["_hs_fwk_stack_push"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stack_push"].apply(null, arguments);
});
var _hs_fwk_stack_top = Module["_hs_fwk_stack_top"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stack_top"].apply(null, arguments);
});
var _hs_fwk_start = Module["_hs_fwk_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_start"].apply(null, arguments);
});
var _hs_fwk_stop = Module["_hs_fwk_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stop"].apply(null, arguments);
});
var _hs_fwk_str_alloc_copy = Module["_hs_fwk_str_alloc_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_alloc_copy"].apply(null, arguments);
});
var _hs_fwk_str_array_copy = Module["_hs_fwk_str_array_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_array_copy"].apply(null, arguments);
});
var _hs_fwk_str_create_copy = Module["_hs_fwk_str_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_create_copy"].apply(null, arguments);
});
var _hs_fwk_str_is_equal = Module["_hs_fwk_str_is_equal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_is_equal"].apply(null, arguments);
});
var _hs_fwk_str_ltrim = Module["_hs_fwk_str_ltrim"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_ltrim"].apply(null, arguments);
});
var _hs_fwk_str_malloc_copy = Module["_hs_fwk_str_malloc_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_malloc_copy"].apply(null, arguments);
});
var _hs_fwk_str_rtrim = Module["_hs_fwk_str_rtrim"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_rtrim"].apply(null, arguments);
});
var _hs_fwk_str_tolower = Module["_hs_fwk_str_tolower"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_str_tolower"].apply(null, arguments);
});
var _hs_fwk_strcmp_x = Module["_hs_fwk_strcmp_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_strcmp_x"].apply(null, arguments);
});
var _hs_fwk_strcpy = Module["_hs_fwk_strcpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_strcpy"].apply(null, arguments);
});
var _hs_fwk_stricmp = Module["_hs_fwk_stricmp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stricmp"].apply(null, arguments);
});
var _hs_fwk_stristr = Module["_hs_fwk_stristr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_stristr"].apply(null, arguments);
});
var _hs_fwk_strn_alloc_copy = Module["_hs_fwk_strn_alloc_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_strn_alloc_copy"].apply(null, arguments);
});
var _hs_fwk_strncpy = Module["_hs_fwk_strncpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_strncpy"].apply(null, arguments);
});
var _hs_fwk_strnicmp = Module["_hs_fwk_strnicmp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_strnicmp"].apply(null, arguments);
});
var _hs_fwk_strrstr = Module["_hs_fwk_strrstr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_strrstr"].apply(null, arguments);
});
var _hs_fwk_strtok = Module["_hs_fwk_strtok"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_strtok"].apply(null, arguments);
});
var _hs_fwk_sys_calc_elapsed_time = Module["_hs_fwk_sys_calc_elapsed_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_calc_elapsed_time"].apply(null, arguments);
});
var _hs_fwk_sys_freeaddrinfo = Module["_hs_fwk_sys_freeaddrinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_freeaddrinfo"].apply(null, arguments);
});
var _hs_fwk_sys_get_appdata_dir = Module["_hs_fwk_sys_get_appdata_dir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_get_appdata_dir"].apply(null, arguments);
});
var _hs_fwk_sys_get_datetime = Module["_hs_fwk_sys_get_datetime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_get_datetime"].apply(null, arguments);
});
var _hs_fwk_sys_get_datetime_rfc1123_str = Module["_hs_fwk_sys_get_datetime_rfc1123_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_get_datetime_rfc1123_str"].apply(null, arguments);
});
var _hs_fwk_sys_get_month_name = Module["_hs_fwk_sys_get_month_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_get_month_name"].apply(null, arguments);
});
var _hs_fwk_sys_get_timeofday = Module["_hs_fwk_sys_get_timeofday"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_get_timeofday"].apply(null, arguments);
});
var _hs_fwk_sys_getaddrinfo = Module["_hs_fwk_sys_getaddrinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_getaddrinfo"].apply(null, arguments);
});
var _hs_fwk_sys_getdnssrvrs = Module["_hs_fwk_sys_getdnssrvrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_getdnssrvrs"].apply(null, arguments);
});
var _hs_fwk_sys_gethostname = Module["_hs_fwk_sys_gethostname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_gethostname"].apply(null, arguments);
});
var _hs_fwk_sys_getpid = Module["_hs_fwk_sys_getpid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_getpid"].apply(null, arguments);
});
var _hs_fwk_sys_getsystime = Module["_hs_fwk_sys_getsystime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_getsystime"].apply(null, arguments);
});
var _hs_fwk_sys_htons = Module["_hs_fwk_sys_htons"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_htons"].apply(null, arguments);
});
var _hs_fwk_sys_inet_ntop = Module["_hs_fwk_sys_inet_ntop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_inet_ntop"].apply(null, arguments);
});
var _hs_fwk_sys_inet_pton = Module["_hs_fwk_sys_inet_pton"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_inet_pton"].apply(null, arguments);
});
var _hs_fwk_sys_init = Module["_hs_fwk_sys_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_init"].apply(null, arguments);
});
var _hs_fwk_sys_is_routable_ip = Module["_hs_fwk_sys_is_routable_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_is_routable_ip"].apply(null, arguments);
});
var _hs_fwk_sys_ntohl = Module["_hs_fwk_sys_ntohl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_ntohl"].apply(null, arguments);
});
var _hs_fwk_sys_ntohs = Module["_hs_fwk_sys_ntohs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_ntohs"].apply(null, arguments);
});
var _hs_fwk_sys_set_appdata_dir = Module["_hs_fwk_sys_set_appdata_dir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_set_appdata_dir"].apply(null, arguments);
});
var _hs_fwk_sys_shutdown = Module["_hs_fwk_sys_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_shutdown"].apply(null, arguments);
});
var _hs_fwk_sys_sleep = Module["_hs_fwk_sys_sleep"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_sys_sleep"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_accept = Module["_hs_fwk_tcp_socket_accept"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_accept"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_bind = Module["_hs_fwk_tcp_socket_bind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_bind"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_connect = Module["_hs_fwk_tcp_socket_connect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_connect"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_create = Module["_hs_fwk_tcp_socket_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_create"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_delete = Module["_hs_fwk_tcp_socket_delete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_delete"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_isconnected = Module["_hs_fwk_tcp_socket_isconnected"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_isconnected"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_listen = Module["_hs_fwk_tcp_socket_listen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_listen"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_recv = Module["_hs_fwk_tcp_socket_recv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_recv"].apply(null, arguments);
});
var _hs_fwk_tcp_socket_send = Module["_hs_fwk_tcp_socket_send"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tcp_socket_send"].apply(null, arguments);
});
var _hs_fwk_thread_create = Module["_hs_fwk_thread_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_thread_create"].apply(null, arguments);
});
var _hs_fwk_thread_exit = Module["_hs_fwk_thread_exit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_thread_exit"].apply(null, arguments);
});
var _hs_fwk_thread_join = Module["_hs_fwk_thread_join"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_thread_join"].apply(null, arguments);
});
var _hs_fwk_thread_self = Module["_hs_fwk_thread_self"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_thread_self"].apply(null, arguments);
});
var _hs_fwk_timer_create = Module["_hs_fwk_timer_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_create"].apply(null, arguments);
});
var _hs_fwk_timer_create_internal = Module["_hs_fwk_timer_create_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_create_internal"].apply(null, arguments);
});
var _hs_fwk_timer_create_with_cb = Module["_hs_fwk_timer_create_with_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_create_with_cb"].apply(null, arguments);
});
var _hs_fwk_timer_delete = Module["_hs_fwk_timer_delete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_delete"].apply(null, arguments);
});
var _hs_fwk_timer_delete_with_cb = Module["_hs_fwk_timer_delete_with_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_delete_with_cb"].apply(null, arguments);
});
var _hs_fwk_timer_init = Module["_hs_fwk_timer_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_init"].apply(null, arguments);
});
var _hs_fwk_timer_send = Module["_hs_fwk_timer_send"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_send"].apply(null, arguments);
});
var _hs_fwk_timer_shutdown = Module["_hs_fwk_timer_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_shutdown"].apply(null, arguments);
});
var _hs_fwk_timer_start = Module["_hs_fwk_timer_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_start"].apply(null, arguments);
});
var _hs_fwk_timer_stop = Module["_hs_fwk_timer_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_stop"].apply(null, arguments);
});
var _hs_fwk_timer_thread = Module["_hs_fwk_timer_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_thread"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_add_ctxt = Module["_hs_fwk_timer_wrap_add_ctxt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_add_ctxt"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_ctxt_free = Module["_hs_fwk_timer_wrap_ctxt_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_ctxt_free"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_db_destroy = Module["_hs_fwk_timer_wrap_db_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_db_destroy"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_db_init = Module["_hs_fwk_timer_wrap_db_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_db_init"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_fired = Module["_hs_fwk_timer_wrap_fired"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_fired"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_get_name = Module["_hs_fwk_timer_wrap_get_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_get_name"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_reset = Module["_hs_fwk_timer_wrap_reset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_reset"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_start = Module["_hs_fwk_timer_wrap_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_start"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_stop = Module["_hs_fwk_timer_wrap_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_stop"].apply(null, arguments);
});
var _hs_fwk_timer_wrap_update_ctxt = Module["_hs_fwk_timer_wrap_update_ctxt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_timer_wrap_update_ctxt"].apply(null, arguments);
});
var _hs_fwk_tokenize_str = Module["_hs_fwk_tokenize_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tokenize_str"].apply(null, arguments);
});
var _hs_fwk_tree_del_subtree = Module["_hs_fwk_tree_del_subtree"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tree_del_subtree"].apply(null, arguments);
});
var _hs_fwk_tree_free_internal = Module["_hs_fwk_tree_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tree_free_internal"].apply(null, arguments);
});
var _hs_fwk_tree_init = Module["_hs_fwk_tree_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tree_init"].apply(null, arguments);
});
var _hs_fwk_tree_insert_node = Module["_hs_fwk_tree_insert_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_tree_insert_node"].apply(null, arguments);
});
var _hs_fwk_udp_socket_bind = Module["_hs_fwk_udp_socket_bind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_udp_socket_bind"].apply(null, arguments);
});
var _hs_fwk_udp_socket_connect = Module["_hs_fwk_udp_socket_connect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_udp_socket_connect"].apply(null, arguments);
});
var _hs_fwk_udp_socket_create = Module["_hs_fwk_udp_socket_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_udp_socket_create"].apply(null, arguments);
});
var _hs_fwk_udp_socket_delete = Module["_hs_fwk_udp_socket_delete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_udp_socket_delete"].apply(null, arguments);
});
var _hs_fwk_udp_socket_recvfrom = Module["_hs_fwk_udp_socket_recvfrom"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_udp_socket_recvfrom"].apply(null, arguments);
});
var _hs_fwk_udp_socket_sendto = Module["_hs_fwk_udp_socket_sendto"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_udp_socket_sendto"].apply(null, arguments);
});
var _hs_fwk_update_timefortimer_table = Module["_hs_fwk_update_timefortimer_table"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_update_timefortimer_table"].apply(null, arguments);
});
var _hs_fwk_uri_add_header = Module["_hs_fwk_uri_add_header"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_uri_add_header"].apply(null, arguments);
});
var _hs_fwk_uri_escape = Module["_hs_fwk_uri_escape"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_uri_escape"].apply(null, arguments);
});
var _hs_fwk_uri_params_escape = Module["_hs_fwk_uri_params_escape"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_uri_params_escape"].apply(null, arguments);
});
var _hs_fwk_uri_user_escape_encoding = Module["_hs_fwk_uri_user_escape_encoding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_uri_user_escape_encoding"].apply(null, arguments);
});
var _hs_fwk_url_unescape = Module["_hs_fwk_url_unescape"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_url_unescape"].apply(null, arguments);
});
var _hs_fwk_validate_sippassword = Module["_hs_fwk_validate_sippassword"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_validate_sippassword"].apply(null, arguments);
});
var _hs_fwk_validate_user_name = Module["_hs_fwk_validate_user_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_validate_user_name"].apply(null, arguments);
});
var _hs_fwk_verify_address = Module["_hs_fwk_verify_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_verify_address"].apply(null, arguments);
});
var _hs_fwk_verify_fqdn = Module["_hs_fwk_verify_fqdn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_verify_fqdn"].apply(null, arguments);
});
var _hs_fwk_verify_isdn_subaddr = Module["_hs_fwk_verify_isdn_subaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_verify_isdn_subaddr"].apply(null, arguments);
});
var _hs_fwk_verify_tel_uri_params = Module["_hs_fwk_verify_tel_uri_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_verify_tel_uri_params"].apply(null, arguments);
});
var _hs_fwk_verify_zero_ipaddress = Module["_hs_fwk_verify_zero_ipaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_fwk_verify_zero_ipaddress"].apply(null, arguments);
});
var _hs_get_application_params = Module["_hs_get_application_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_get_application_params"].apply(null, arguments);
});
var _hs_get_utf8len = Module["_hs_get_utf8len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_get_utf8len"].apply(null, arguments);
});
var _hs_hoff_alg_adapt_info_add_new = Module["_hs_hoff_alg_adapt_info_add_new"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_adapt_info_add_new"].apply(null, arguments);
});
var _hs_hoff_alg_adpt_get_dualmodeip = Module["_hs_hoff_alg_adpt_get_dualmodeip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_adpt_get_dualmodeip"].apply(null, arguments);
});
var _hs_hoff_alg_adpt_info_remove = Module["_hs_hoff_alg_adpt_info_remove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_adpt_info_remove"].apply(null, arguments);
});
var _hs_hoff_alg_adpt_list_free = Module["_hs_hoff_alg_adpt_list_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_adpt_list_free"].apply(null, arguments);
});
var _hs_hoff_alg_adptr_free = Module["_hs_hoff_alg_adptr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_adptr_free"].apply(null, arguments);
});
var _hs_hoff_alg_adptr_malloc_copy = Module["_hs_hoff_alg_adptr_malloc_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_adptr_malloc_copy"].apply(null, arguments);
});
var _hs_hoff_alg_block_adapter = Module["_hs_hoff_alg_block_adapter"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_block_adapter"].apply(null, arguments);
});
var _hs_hoff_alg_compare_adptrlist = Module["_hs_hoff_alg_compare_adptrlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_compare_adptrlist"].apply(null, arguments);
});
var _hs_hoff_alg_cs_mode_evaluate_and_trigger_hoff = Module["_hs_hoff_alg_cs_mode_evaluate_and_trigger_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_cs_mode_evaluate_and_trigger_hoff"].apply(null, arguments);
});
var _hs_hoff_alg_cs_mode_process_adpt_list = Module["_hs_hoff_alg_cs_mode_process_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_cs_mode_process_adpt_list"].apply(null, arguments);
});
var _hs_hoff_alg_cs_mode_select_startup_if = Module["_hs_hoff_alg_cs_mode_select_startup_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_cs_mode_select_startup_if"].apply(null, arguments);
});
var _hs_hoff_alg_cs_mode_ss_handling = Module["_hs_hoff_alg_cs_mode_ss_handling"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_cs_mode_ss_handling"].apply(null, arguments);
});
var _hs_hoff_alg_dereg_nonconfig_adapters = Module["_hs_hoff_alg_dereg_nonconfig_adapters"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_dereg_nonconfig_adapters"].apply(null, arguments);
});
var _hs_hoff_alg_ev_get_high_pri_voip_adpt = Module["_hs_hoff_alg_ev_get_high_pri_voip_adpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_ev_get_high_pri_voip_adpt"].apply(null, arguments);
});
var _hs_hoff_alg_ev_send_to_app = Module["_hs_hoff_alg_ev_send_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_ev_send_to_app"].apply(null, arguments);
});
var _hs_hoff_alg_find_diff_list = Module["_hs_hoff_alg_find_diff_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_find_diff_list"].apply(null, arguments);
});
var _hs_hoff_alg_get_adpt_context = Module["_hs_hoff_alg_get_adpt_context"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_get_adpt_context"].apply(null, arguments);
});
var _hs_hoff_alg_get_adpt_list = Module["_hs_hoff_alg_get_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_get_adpt_list"].apply(null, arguments);
});
var _hs_hoff_alg_get_adpt_priority = Module["_hs_hoff_alg_get_adpt_priority"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_get_adpt_priority"].apply(null, arguments);
});
var _hs_hoff_alg_get_mq_band = Module["_hs_hoff_alg_get_mq_band"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_get_mq_band"].apply(null, arguments);
});
var _hs_hoff_alg_get_preffered_cs_nwk = Module["_hs_hoff_alg_get_preffered_cs_nwk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_get_preffered_cs_nwk"].apply(null, arguments);
});
var _hs_hoff_alg_get_ss_band = Module["_hs_hoff_alg_get_ss_band"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_get_ss_band"].apply(null, arguments);
});
var _hs_hoff_alg_hard_hoff_blockreason = Module["_hs_hoff_alg_hard_hoff_blockreason"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_hard_hoff_blockreason"].apply(null, arguments);
});
var _hs_hoff_alg_hoff_blockreason = Module["_hs_hoff_alg_hoff_blockreason"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_hoff_blockreason"].apply(null, arguments);
});
var _hs_hoff_alg_initiate_dereg = Module["_hs_hoff_alg_initiate_dereg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_initiate_dereg"].apply(null, arguments);
});
var _hs_hoff_alg_is_adpt_hit_entry_trigger = Module["_hs_hoff_alg_is_adpt_hit_entry_trigger"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_adpt_hit_entry_trigger"].apply(null, arguments);
});
var _hs_hoff_alg_is_adpt_hit_hoff_trigger = Module["_hs_hoff_alg_is_adpt_hit_hoff_trigger"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_adpt_hit_hoff_trigger"].apply(null, arguments);
});
var _hs_hoff_alg_is_adpt_hit_reentry_trigger = Module["_hs_hoff_alg_is_adpt_hit_reentry_trigger"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_adpt_hit_reentry_trigger"].apply(null, arguments);
});
var _hs_hoff_alg_is_adpt_hit_scan_trigger = Module["_hs_hoff_alg_is_adpt_hit_scan_trigger"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_adpt_hit_scan_trigger"].apply(null, arguments);
});
var _hs_hoff_alg_is_config_voip_adpt = Module["_hs_hoff_alg_is_config_voip_adpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_config_voip_adpt"].apply(null, arguments);
});
var _hs_hoff_alg_is_hard_hoff_allowed = Module["_hs_hoff_alg_is_hard_hoff_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_hard_hoff_allowed"].apply(null, arguments);
});
var _hs_hoff_alg_is_list_process_allowed = Module["_hs_hoff_alg_is_list_process_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_list_process_allowed"].apply(null, arguments);
});
var _hs_hoff_alg_is_nwk_avaiable = Module["_hs_hoff_alg_is_nwk_avaiable"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_nwk_avaiable"].apply(null, arguments);
});
var _hs_hoff_alg_is_viable_adapter = Module["_hs_hoff_alg_is_viable_adapter"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_is_viable_adapter"].apply(null, arguments);
});
var _hs_hoff_alg_perform_hoff = Module["_hs_hoff_alg_perform_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_perform_hoff"].apply(null, arguments);
});
var _hs_hoff_alg_process_iplist_change = Module["_hs_hoff_alg_process_iplist_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_process_iplist_change"].apply(null, arguments);
});
var _hs_hoff_alg_process_pcscf_list = Module["_hs_hoff_alg_process_pcscf_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_process_pcscf_list"].apply(null, arguments);
});
var _hs_hoff_alg_send_hoff_ev_to_app = Module["_hs_hoff_alg_send_hoff_ev_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_send_hoff_ev_to_app"].apply(null, arguments);
});
var _hs_hoff_alg_set_all_adapters_required = Module["_hs_hoff_alg_set_all_adapters_required"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_set_all_adapters_required"].apply(null, arguments);
});
var _hs_hoff_alg_switch_mode = Module["_hs_hoff_alg_switch_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_switch_mode"].apply(null, arguments);
});
var _hs_hoff_alg_trigger_simulated_auto_handoff = Module["_hs_hoff_alg_trigger_simulated_auto_handoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_trigger_simulated_auto_handoff"].apply(null, arguments);
});
var _hs_hoff_alg_unblock_adapter = Module["_hs_hoff_alg_unblock_adapter"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_unblock_adapter"].apply(null, arguments);
});
var _hs_hoff_alg_update_context_for_no_nwk = Module["_hs_hoff_alg_update_context_for_no_nwk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_update_context_for_no_nwk"].apply(null, arguments);
});
var _hs_hoff_alg_user_mode_evaluate_and_trigger_hoff = Module["_hs_hoff_alg_user_mode_evaluate_and_trigger_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_user_mode_evaluate_and_trigger_hoff"].apply(null, arguments);
});
var _hs_hoff_alg_user_mode_process_adpt_list = Module["_hs_hoff_alg_user_mode_process_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_user_mode_process_adpt_list"].apply(null, arguments);
});
var _hs_hoff_alg_user_mode_select_startup_if = Module["_hs_hoff_alg_user_mode_select_startup_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_user_mode_select_startup_if"].apply(null, arguments);
});
var _hs_hoff_alg_user_mode_ss_handling = Module["_hs_hoff_alg_user_mode_ss_handling"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_user_mode_ss_handling"].apply(null, arguments);
});
var _hs_hoff_alg_vcc_mode_evaluate_and_trigger_hoff = Module["_hs_hoff_alg_vcc_mode_evaluate_and_trigger_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_vcc_mode_evaluate_and_trigger_hoff"].apply(null, arguments);
});
var _hs_hoff_alg_vcc_mode_process_adpt_list = Module["_hs_hoff_alg_vcc_mode_process_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_vcc_mode_process_adpt_list"].apply(null, arguments);
});
var _hs_hoff_alg_vcc_mode_select_startup_if = Module["_hs_hoff_alg_vcc_mode_select_startup_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_vcc_mode_select_startup_if"].apply(null, arguments);
});
var _hs_hoff_alg_vcc_mode_ss_handling = Module["_hs_hoff_alg_vcc_mode_ss_handling"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_vcc_mode_ss_handling"].apply(null, arguments);
});
var _hs_hoff_alg_voip_evdo_mode_evaluate_and_trigger_hoff = Module["_hs_hoff_alg_voip_evdo_mode_evaluate_and_trigger_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_evdo_mode_evaluate_and_trigger_hoff"].apply(null, arguments);
});
var _hs_hoff_alg_voip_evdo_mode_process_adpt_list = Module["_hs_hoff_alg_voip_evdo_mode_process_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_evdo_mode_process_adpt_list"].apply(null, arguments);
});
var _hs_hoff_alg_voip_evdo_mode_select_startup_if = Module["_hs_hoff_alg_voip_evdo_mode_select_startup_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_evdo_mode_select_startup_if"].apply(null, arguments);
});
var _hs_hoff_alg_voip_evdo_mode_ss_handling = Module["_hs_hoff_alg_voip_evdo_mode_ss_handling"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_evdo_mode_ss_handling"].apply(null, arguments);
});
var _hs_hoff_alg_voip_mode_evaluate_and_trigger_hoff = Module["_hs_hoff_alg_voip_mode_evaluate_and_trigger_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_mode_evaluate_and_trigger_hoff"].apply(null, arguments);
});
var _hs_hoff_alg_voip_mode_process_adpt_list = Module["_hs_hoff_alg_voip_mode_process_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_mode_process_adpt_list"].apply(null, arguments);
});
var _hs_hoff_alg_voip_mode_select_startup_if = Module["_hs_hoff_alg_voip_mode_select_startup_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_mode_select_startup_if"].apply(null, arguments);
});
var _hs_hoff_alg_voip_mode_ss_handling = Module["_hs_hoff_alg_voip_mode_ss_handling"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_alg_voip_mode_ss_handling"].apply(null, arguments);
});
var _hs_hoff_celldata_conn_manage = Module["_hs_hoff_celldata_conn_manage"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_celldata_conn_manage"].apply(null, arguments);
});
var _hs_hoff_cs_mode_gen_alt_radio_rp_ev = Module["_hs_hoff_cs_mode_gen_alt_radio_rp_ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_cs_mode_gen_alt_radio_rp_ev"].apply(null, arguments);
});
var _hs_hoff_get_all_nwk_status = Module["_hs_hoff_get_all_nwk_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_all_nwk_status"].apply(null, arguments);
});
var _hs_hoff_get_badmedia_adpt_block_time = Module["_hs_hoff_get_badmedia_adpt_block_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_badmedia_adpt_block_time"].apply(null, arguments);
});
var _hs_hoff_get_celldata_subtype = Module["_hs_hoff_get_celldata_subtype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_celldata_subtype"].apply(null, arguments);
});
var _hs_hoff_get_cur_nwk = Module["_hs_hoff_get_cur_nwk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_cur_nwk"].apply(null, arguments);
});
var _hs_hoff_get_dns_client_opt = Module["_hs_hoff_get_dns_client_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_dns_client_opt"].apply(null, arguments);
});
var _hs_hoff_get_dns_ip = Module["_hs_hoff_get_dns_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_dns_ip"].apply(null, arguments);
});
var _hs_hoff_get_hard_hoff_wait_time = Module["_hs_hoff_get_hard_hoff_wait_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_hard_hoff_wait_time"].apply(null, arguments);
});
var _hs_hoff_get_hoff_intvl = Module["_hs_hoff_get_hoff_intvl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_hoff_intvl"].apply(null, arguments);
});
var _hs_hoff_get_if_status = Module["_hs_hoff_get_if_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_if_status"].apply(null, arguments);
});
var _hs_hoff_get_if_status_byaddr = Module["_hs_hoff_get_if_status_byaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_if_status_byaddr"].apply(null, arguments);
});
var _hs_hoff_get_if_status_byname = Module["_hs_hoff_get_if_status_byname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_if_status_byname"].apply(null, arguments);
});
var _hs_hoff_get_if_type_byaddr = Module["_hs_hoff_get_if_type_byaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_if_type_byaddr"].apply(null, arguments);
});
var _hs_hoff_get_max_adpt_block_time = Module["_hs_hoff_get_max_adpt_block_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_max_adpt_block_time"].apply(null, arguments);
});
var _hs_hoff_get_min_adpt_block_time = Module["_hs_hoff_get_min_adpt_block_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_min_adpt_block_time"].apply(null, arguments);
});
var _hs_hoff_get_min_cs_on_time = Module["_hs_hoff_get_min_cs_on_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_min_cs_on_time"].apply(null, arguments);
});
var _hs_hoff_get_opmode = Module["_hs_hoff_get_opmode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_opmode"].apply(null, arguments);
});
var _hs_hoff_get_opmode_csoption = Module["_hs_hoff_get_opmode_csoption"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_opmode_csoption"].apply(null, arguments);
});
var _hs_hoff_get_opmode_nwadpts = Module["_hs_hoff_get_opmode_nwadpts"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_opmode_nwadpts"].apply(null, arguments);
});
var _hs_hoff_get_opmode_nwadpts_cfg_param_str = Module["_hs_hoff_get_opmode_nwadpts_cfg_param_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_get_opmode_nwadpts_cfg_param_str"].apply(null, arguments);
});
var _hs_hoff_is_adpter_has_valid_dnsip = Module["_hs_hoff_is_adpter_has_valid_dnsip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_adpter_has_valid_dnsip"].apply(null, arguments);
});
var _hs_hoff_is_cs_nwk = Module["_hs_hoff_is_cs_nwk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_cs_nwk"].apply(null, arguments);
});
var _hs_hoff_is_cs_usable = Module["_hs_hoff_is_cs_usable"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_cs_usable"].apply(null, arguments);
});
var _hs_hoff_is_mq_eval_required = Module["_hs_hoff_is_mq_eval_required"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_mq_eval_required"].apply(null, arguments);
});
var _hs_hoff_is_reg_retry_in_hoff_mngr = Module["_hs_hoff_is_reg_retry_in_hoff_mngr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_reg_retry_in_hoff_mngr"].apply(null, arguments);
});
var _hs_hoff_is_sip_registered = Module["_hs_hoff_is_sip_registered"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_sip_registered"].apply(null, arguments);
});
var _hs_hoff_is_soft_hoff_allowed = Module["_hs_hoff_is_soft_hoff_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_soft_hoff_allowed"].apply(null, arguments);
});
var _hs_hoff_is_sq_eval_required = Module["_hs_hoff_is_sq_eval_required"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_sq_eval_required"].apply(null, arguments);
});
var _hs_hoff_is_ss_eval_required = Module["_hs_hoff_is_ss_eval_required"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_ss_eval_required"].apply(null, arguments);
});
var _hs_hoff_is_viability_check_configured = Module["_hs_hoff_is_viability_check_configured"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_is_viability_check_configured"].apply(null, arguments);
});
var _hs_hoff_mngr_create_turnon_timer = Module["_hs_hoff_mngr_create_turnon_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_create_turnon_timer"].apply(null, arguments);
});
var _hs_hoff_mngr_eval_and_trigger_hoff = Module["_hs_hoff_mngr_eval_and_trigger_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_eval_and_trigger_hoff"].apply(null, arguments);
});
var _hs_hoff_mngr_free_event_msg = Module["_hs_hoff_mngr_free_event_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_free_event_msg"].apply(null, arguments);
});
var _hs_hoff_mngr_gen_alt_radio_rp_event = Module["_hs_hoff_mngr_gen_alt_radio_rp_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_gen_alt_radio_rp_event"].apply(null, arguments);
});
var _hs_hoff_mngr_gen_cur_radio_rp_event = Module["_hs_hoff_mngr_gen_cur_radio_rp_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_gen_cur_radio_rp_event"].apply(null, arguments);
});
var _hs_hoff_mngr_gen_startup_to_rp = Module["_hs_hoff_mngr_gen_startup_to_rp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_gen_startup_to_rp"].apply(null, arguments);
});
var _hs_hoff_mngr_get_celldata_usage_flag = Module["_hs_hoff_mngr_get_celldata_usage_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_get_celldata_usage_flag"].apply(null, arguments);
});
var _hs_hoff_mngr_get_eval_pending = Module["_hs_hoff_mngr_get_eval_pending"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_get_eval_pending"].apply(null, arguments);
});
var _hs_hoff_mngr_hard_hoff_on_down = Module["_hs_hoff_mngr_hard_hoff_on_down"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_hard_hoff_on_down"].apply(null, arguments);
});
var _hs_hoff_mngr_init = Module["_hs_hoff_mngr_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_init"].apply(null, arguments);
});
var _hs_hoff_mngr_is_sys_signedin = Module["_hs_hoff_mngr_is_sys_signedin"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_is_sys_signedin"].apply(null, arguments);
});
var _hs_hoff_mngr_ncm_ind_callback = Module["_hs_hoff_mngr_ncm_ind_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_ncm_ind_callback"].apply(null, arguments);
});
var _hs_hoff_mngr_post_event = Module["_hs_hoff_mngr_post_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_post_event"].apply(null, arguments);
});
var _hs_hoff_mngr_proc_adpt_timer_event = Module["_hs_hoff_mngr_proc_adpt_timer_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_proc_adpt_timer_event"].apply(null, arguments);
});
var _hs_hoff_mngr_proc_config_change_ev = Module["_hs_hoff_mngr_proc_config_change_ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_proc_config_change_ev"].apply(null, arguments);
});
var _hs_hoff_mngr_proc_timer_event = Module["_hs_hoff_mngr_proc_timer_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_proc_timer_event"].apply(null, arguments);
});
var _hs_hoff_mngr_proc_viability_test_resp = Module["_hs_hoff_mngr_proc_viability_test_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_proc_viability_test_resp"].apply(null, arguments);
});
var _hs_hoff_mngr_process_adpt_events = Module["_hs_hoff_mngr_process_adpt_events"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_process_adpt_events"].apply(null, arguments);
});
var _hs_hoff_mngr_process_nwk_quality_ev = Module["_hs_hoff_mngr_process_nwk_quality_ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_process_nwk_quality_ev"].apply(null, arguments);
});
var _hs_hoff_mngr_process_ss_ev = Module["_hs_hoff_mngr_process_ss_ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_process_ss_ev"].apply(null, arguments);
});
var _hs_hoff_mngr_set_eval_pending = Module["_hs_hoff_mngr_set_eval_pending"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_set_eval_pending"].apply(null, arguments);
});
var _hs_hoff_mngr_shutdown = Module["_hs_hoff_mngr_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_shutdown"].apply(null, arguments);
});
var _hs_hoff_mngr_start = Module["_hs_hoff_mngr_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_start"].apply(null, arguments);
});
var _hs_hoff_mngr_start_viability_test = Module["_hs_hoff_mngr_start_viability_test"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_start_viability_test"].apply(null, arguments);
});
var _hs_hoff_mngr_stop = Module["_hs_hoff_mngr_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_stop"].apply(null, arguments);
});
var _hs_hoff_mngr_thread = Module["_hs_hoff_mngr_thread"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_mngr_thread"].apply(null, arguments);
});
var _hs_hoff_raise_viability_event = Module["_hs_hoff_raise_viability_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_raise_viability_event"].apply(null, arguments);
});
var _hs_hoff_select_startup_if = Module["_hs_hoff_select_startup_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_select_startup_if"].apply(null, arguments);
});
var _hs_hoff_set_opmode_nwadpts = Module["_hs_hoff_set_opmode_nwadpts"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_set_opmode_nwadpts"].apply(null, arguments);
});
var _hs_hoff_sys_ip_eval_hoff = Module["_hs_hoff_sys_ip_eval_hoff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_sys_ip_eval_hoff"].apply(null, arguments);
});
var _hs_hoff_sys_ip_handle_events = Module["_hs_hoff_sys_ip_handle_events"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_sys_ip_handle_events"].apply(null, arguments);
});
var _hs_hoff_sys_ip_hard_hoff_on_down = Module["_hs_hoff_sys_ip_hard_hoff_on_down"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_sys_ip_hard_hoff_on_down"].apply(null, arguments);
});
var _hs_hoff_sys_ip_process_no_nwk = Module["_hs_hoff_sys_ip_process_no_nwk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_sys_ip_process_no_nwk"].apply(null, arguments);
});
var _hs_hoff_sysip_select_startup_if = Module["_hs_hoff_sysip_select_startup_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_sysip_select_startup_if"].apply(null, arguments);
});
var _hs_hoff_vcc_mode_gen_alt_radio_rp_ev = Module["_hs_hoff_vcc_mode_gen_alt_radio_rp_ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_vcc_mode_gen_alt_radio_rp_ev"].apply(null, arguments);
});
var _hs_hoff_voip_evdo_mode_gen_alt_radio_rp_ev = Module["_hs_hoff_voip_evdo_mode_gen_alt_radio_rp_ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_voip_evdo_mode_gen_alt_radio_rp_ev"].apply(null, arguments);
});
var _hs_hoff_voip_mode_gen_alt_radio_rp_ev = Module["_hs_hoff_voip_mode_gen_alt_radio_rp_ev"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_hoff_voip_mode_gen_alt_radio_rp_ev"].apply(null, arguments);
});
var _hs_http_async_decode_chunkdata = Module["_hs_http_async_decode_chunkdata"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_async_decode_chunkdata"].apply(null, arguments);
});
var _hs_http_async_send_req = Module["_hs_http_async_send_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_async_send_req"].apply(null, arguments);
});
var _hs_http_build_auth_headers = Module["_hs_http_build_auth_headers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_build_auth_headers"].apply(null, arguments);
});
var _hs_http_build_msg_from_ctxt = Module["_hs_http_build_msg_from_ctxt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_build_msg_from_ctxt"].apply(null, arguments);
});
var _hs_http_calc_basic_response = Module["_hs_http_calc_basic_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_calc_basic_response"].apply(null, arguments);
});
var _hs_http_calc_md5resp = Module["_hs_http_calc_md5resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_calc_md5resp"].apply(null, arguments);
});
var _hs_http_cont_copy = Module["_hs_http_cont_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_cont_copy"].apply(null, arguments);
});
var _hs_http_copy_add_cookie_hdrs = Module["_hs_http_copy_add_cookie_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_copy_add_cookie_hdrs"].apply(null, arguments);
});
var _hs_http_copy_etag_tohdrs = Module["_hs_http_copy_etag_tohdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_copy_etag_tohdrs"].apply(null, arguments);
});
var _hs_http_ctxt_info_free = Module["_hs_http_ctxt_info_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_ctxt_info_free"].apply(null, arguments);
});
var _hs_http_dec_authenticate_hdrs = Module["_hs_http_dec_authenticate_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dec_authenticate_hdrs"].apply(null, arguments);
});
var _hs_http_dec_digest_algorithm = Module["_hs_http_dec_digest_algorithm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dec_digest_algorithm"].apply(null, arguments);
});
var _hs_http_dec_digest_fields = Module["_hs_http_dec_digest_fields"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dec_digest_fields"].apply(null, arguments);
});
var _hs_http_dec_digest_stale = Module["_hs_http_dec_digest_stale"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dec_digest_stale"].apply(null, arguments);
});
var _hs_http_dec_msgbody = Module["_hs_http_dec_msgbody"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dec_msgbody"].apply(null, arguments);
});
var _hs_http_dec_msgheaders = Module["_hs_http_dec_msgheaders"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dec_msgheaders"].apply(null, arguments);
});
var _hs_http_dec_resp_startline = Module["_hs_http_dec_resp_startline"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dec_resp_startline"].apply(null, arguments);
});
var _hs_http_digest_challenge_free = Module["_hs_http_digest_challenge_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_digest_challenge_free"].apply(null, arguments);
});
var _hs_http_digest_response_free = Module["_hs_http_digest_response_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_digest_response_free"].apply(null, arguments);
});
var _hs_http_dtm_callbkfn = Module["_hs_http_dtm_callbkfn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_dtm_callbkfn"].apply(null, arguments);
});
var _hs_http_encode_auth_ext_params = Module["_hs_http_encode_auth_ext_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_encode_auth_ext_params"].apply(null, arguments);
});
var _hs_http_encode_auth_hdrs = Module["_hs_http_encode_auth_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_encode_auth_hdrs"].apply(null, arguments);
});
var _hs_http_encode_authrz_element = Module["_hs_http_encode_authrz_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_encode_authrz_element"].apply(null, arguments);
});
var _hs_http_encode_basic_element = Module["_hs_http_encode_basic_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_encode_basic_element"].apply(null, arguments);
});
var _hs_http_encode_msghdrs = Module["_hs_http_encode_msghdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_encode_msghdrs"].apply(null, arguments);
});
var _hs_http_extract_digest_fields = Module["_hs_http_extract_digest_fields"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_extract_digest_fields"].apply(null, arguments);
});
var _hs_http_extract_gen_hdrs = Module["_hs_http_extract_gen_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_extract_gen_hdrs"].apply(null, arguments);
});
var _hs_http_extract_gen_hdrvalue = Module["_hs_http_extract_gen_hdrvalue"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_extract_gen_hdrvalue"].apply(null, arguments);
});
var _hs_http_fill_cb_parms = Module["_hs_http_fill_cb_parms"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_fill_cb_parms"].apply(null, arguments);
});
var _hs_http_free_cb_params = Module["_hs_http_free_cb_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_free_cb_params"].apply(null, arguments);
});
var _hs_http_get_genhdr_val = Module["_hs_http_get_genhdr_val"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_get_genhdr_val"].apply(null, arguments);
});
var _hs_http_get_method_str = Module["_hs_http_get_method_str"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_get_method_str"].apply(null, arguments);
});
var _hs_http_if_msg_free = Module["_hs_http_if_msg_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_if_msg_free"].apply(null, arguments);
});
var _hs_http_init = Module["_hs_http_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_init"].apply(null, arguments);
});
var _hs_http_initiate_async_xact = Module["_hs_http_initiate_async_xact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_initiate_async_xact"].apply(null, arguments);
});
var _hs_http_map_resp_code = Module["_hs_http_map_resp_code"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_map_resp_code"].apply(null, arguments);
});
var _hs_http_msg_create_default = Module["_hs_http_msg_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_msg_create_default"].apply(null, arguments);
});
var _hs_http_msg_decoder = Module["_hs_http_msg_decoder"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_msg_decoder"].apply(null, arguments);
});
var _hs_http_msg_free = Module["_hs_http_msg_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_msg_free"].apply(null, arguments);
});
var _hs_http_proc_dtmcb = Module["_hs_http_proc_dtmcb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_proc_dtmcb"].apply(null, arguments);
});
var _hs_http_proc_timer_msg = Module["_hs_http_proc_timer_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_proc_timer_msg"].apply(null, arguments);
});
var _hs_http_req_msg_create = Module["_hs_http_req_msg_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_req_msg_create"].apply(null, arguments);
});
var _hs_http_req_msg_free = Module["_hs_http_req_msg_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_req_msg_free"].apply(null, arguments);
});
var _hs_http_resolve_hostname = Module["_hs_http_resolve_hostname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_resolve_hostname"].apply(null, arguments);
});
var _hs_http_shutdown = Module["_hs_http_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_shutdown"].apply(null, arguments);
});
var _hs_http_skip_chunk_len = Module["_hs_http_skip_chunk_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_skip_chunk_len"].apply(null, arguments);
});
var _hs_http_start = Module["_hs_http_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_start"].apply(null, arguments);
});
var _hs_http_stop = Module["_hs_http_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_stop"].apply(null, arguments);
});
var _hs_http_synt_verf_qop_options = Module["_hs_http_synt_verf_qop_options"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_synt_verf_qop_options"].apply(null, arguments);
});
var _hs_http_synt_verf_quoted_stringval = Module["_hs_http_synt_verf_quoted_stringval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_synt_verf_quoted_stringval"].apply(null, arguments);
});
var _hs_http_synt_verf_tokenval = Module["_hs_http_synt_verf_tokenval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_synt_verf_tokenval"].apply(null, arguments);
});
var _hs_http_syntverf_dec_headers = Module["_hs_http_syntverf_dec_headers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_syntverf_dec_headers"].apply(null, arguments);
});
var _hs_http_thrd = Module["_hs_http_thrd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_thrd"].apply(null, arguments);
});
var _hs_http_uri_escape_encoding = Module["_hs_http_uri_escape_encoding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_uri_escape_encoding"].apply(null, arguments);
});
var _hs_http_wasm_failure_cb = Module["_hs_http_wasm_failure_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_wasm_failure_cb"].apply(null, arguments);
});
var _hs_http_wasm_progress_cb = Module["_hs_http_wasm_progress_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_wasm_progress_cb"].apply(null, arguments);
});
var _hs_http_wasm_success_cb = Module["_hs_http_wasm_success_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_http_wasm_success_cb"].apply(null, arguments);
});
var _hs_httpprov_dec_set_cookie_parms = Module["_hs_httpprov_dec_set_cookie_parms"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_httpprov_dec_set_cookie_parms"].apply(null, arguments);
});
var _hs_https_async_get_data = Module["_hs_https_async_get_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_https_async_get_data"].apply(null, arguments);
});
var _hs_ims_build_configdomain_from_user = Module["_hs_ims_build_configdomain_from_user"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_build_configdomain_from_user"].apply(null, arguments);
});
var _hs_ims_build_contact = Module["_hs_ims_build_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_build_contact"].apply(null, arguments);
});
var _hs_ims_build_contact_list = Module["_hs_ims_build_contact_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_build_contact_list"].apply(null, arguments);
});
var _hs_ims_build_pidf_buf = Module["_hs_ims_build_pidf_buf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_build_pidf_buf"].apply(null, arguments);
});
var _hs_ims_build_uri = Module["_hs_ims_build_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_build_uri"].apply(null, arguments);
});
var _hs_ims_capab_add_listparam = Module["_hs_ims_capab_add_listparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_add_listparam"].apply(null, arguments);
});
var _hs_ims_capab_build_opt_paramslist = Module["_hs_ims_capab_build_opt_paramslist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_build_opt_paramslist"].apply(null, arguments);
});
var _hs_ims_capab_build_reg_paramslist = Module["_hs_ims_capab_build_reg_paramslist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_build_reg_paramslist"].apply(null, arguments);
});
var _hs_ims_capab_ctxt_free = Module["_hs_ims_capab_ctxt_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_ctxt_free"].apply(null, arguments);
});
var _hs_ims_capab_decode_paramlist = Module["_hs_ims_capab_decode_paramlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_decode_paramlist"].apply(null, arguments);
});
var _hs_ims_capab_init = Module["_hs_ims_capab_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_init"].apply(null, arguments);
});
var _hs_ims_capab_shutdown = Module["_hs_ims_capab_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_shutdown"].apply(null, arguments);
});
var _hs_ims_capab_sip_cb = Module["_hs_ims_capab_sip_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_sip_cb"].apply(null, arguments);
});
var _hs_ims_capab_start = Module["_hs_ims_capab_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_start"].apply(null, arguments);
});
var _hs_ims_capab_stop = Module["_hs_ims_capab_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_capab_stop"].apply(null, arguments);
});
var _hs_ims_ccm_vs_stop = Module["_hs_ims_ccm_vs_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_ccm_vs_stop"].apply(null, arguments);
});
var _hs_ims_check_timerid = Module["_hs_ims_check_timerid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_check_timerid"].apply(null, arguments);
});
var _hs_ims_check_txid = Module["_hs_ims_check_txid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_check_txid"].apply(null, arguments);
});
var _hs_ims_conf_avb_media_free = Module["_hs_ims_conf_avb_media_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_avb_media_free"].apply(null, arguments);
});
var _hs_ims_conf_copy_avb_media = Module["_hs_ims_conf_copy_avb_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_copy_avb_media"].apply(null, arguments);
});
var _hs_ims_conf_copy_endpoint = Module["_hs_ims_conf_copy_endpoint"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_copy_endpoint"].apply(null, arguments);
});
var _hs_ims_conf_copy_media = Module["_hs_ims_conf_copy_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_copy_media"].apply(null, arguments);
});
var _hs_ims_conf_copy_user = Module["_hs_ims_conf_copy_user"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_copy_user"].apply(null, arguments);
});
var _hs_ims_conf_created = Module["_hs_ims_conf_created"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_created"].apply(null, arguments);
});
var _hs_ims_conf_doc_end = Module["_hs_ims_conf_doc_end"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_doc_end"].apply(null, arguments);
});
var _hs_ims_conf_doc_parse = Module["_hs_ims_conf_doc_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_doc_parse"].apply(null, arguments);
});
var _hs_ims_conf_doc_start = Module["_hs_ims_conf_doc_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_doc_start"].apply(null, arguments);
});
var _hs_ims_conf_ep_free = Module["_hs_ims_conf_ep_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_ep_free"].apply(null, arguments);
});
var _hs_ims_conf_free_internal = Module["_hs_ims_conf_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_free_internal"].apply(null, arguments);
});
var _hs_ims_conf_init = Module["_hs_ims_conf_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_init"].apply(null, arguments);
});
var _hs_ims_conf_media_free = Module["_hs_ims_conf_media_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_media_free"].apply(null, arguments);
});
var _hs_ims_conf_skip_node_data = Module["_hs_ims_conf_skip_node_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_skip_node_data"].apply(null, arguments);
});
var _hs_ims_conf_tag_data = Module["_hs_ims_conf_tag_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_tag_data"].apply(null, arguments);
});
var _hs_ims_conf_tag_end = Module["_hs_ims_conf_tag_end"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_tag_end"].apply(null, arguments);
});
var _hs_ims_conf_tag_start = Module["_hs_ims_conf_tag_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_tag_start"].apply(null, arguments);
});
var _hs_ims_conf_user_free = Module["_hs_ims_conf_user_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_conf_user_free"].apply(null, arguments);
});
var _hs_ims_create_urn = Module["_hs_ims_create_urn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_create_urn"].apply(null, arguments);
});
var _hs_ims_create_v1_uuid = Module["_hs_ims_create_v1_uuid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_create_v1_uuid"].apply(null, arguments);
});
var _hs_ims_create_v3_uuid = Module["_hs_ims_create_v3_uuid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_create_v3_uuid"].apply(null, arguments);
});
var _hs_ims_dereg = Module["_hs_ims_dereg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_dereg"].apply(null, arguments);
});
var _hs_ims_destroy_msg = Module["_hs_ims_destroy_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_destroy_msg"].apply(null, arguments);
});
var _hs_ims_encode_date_time = Module["_hs_ims_encode_date_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_encode_date_time"].apply(null, arguments);
});
var _hs_ims_fill_c002_msg = Module["_hs_ims_fill_c002_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_fill_c002_msg"].apply(null, arguments);
});
var _hs_ims_fill_event_msg = Module["_hs_ims_fill_event_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_fill_event_msg"].apply(null, arguments);
});
var _hs_ims_fill_prov_params = Module["_hs_ims_fill_prov_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_fill_prov_params"].apply(null, arguments);
});
var _hs_ims_free_app_msg = Module["_hs_ims_free_app_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_free_app_msg"].apply(null, arguments);
});
var _hs_ims_free_reg = Module["_hs_ims_free_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_free_reg"].apply(null, arguments);
});
var _hs_ims_geoloc_build_device_elmt = Module["_hs_ims_geoloc_build_device_elmt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_geoloc_build_device_elmt"].apply(null, arguments);
});
var _hs_ims_geoloc_build_mime = Module["_hs_ims_geoloc_build_mime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_geoloc_build_mime"].apply(null, arguments);
});
var _hs_ims_geoloc_build_person_elmt = Module["_hs_ims_geoloc_build_person_elmt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_geoloc_build_person_elmt"].apply(null, arguments);
});
var _hs_ims_geoloc_create_mime = Module["_hs_ims_geoloc_create_mime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_geoloc_create_mime"].apply(null, arguments);
});
var _hs_ims_geoloc_init = Module["_hs_ims_geoloc_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_geoloc_init"].apply(null, arguments);
});
var _hs_ims_geopriv_node_encode = Module["_hs_ims_geopriv_node_encode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_geopriv_node_encode"].apply(null, arguments);
});
var _hs_ims_get_characterstics = Module["_hs_ims_get_characterstics"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_get_characterstics"].apply(null, arguments);
});
var _hs_ims_get_preferred_localaor = Module["_hs_ims_get_preferred_localaor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_get_preferred_localaor"].apply(null, arguments);
});
var _hs_ims_get_refresh_timeout = Module["_hs_ims_get_refresh_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_get_refresh_timeout"].apply(null, arguments);
});
var _hs_ims_get_reg_status = Module["_hs_ims_get_reg_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_get_reg_status"].apply(null, arguments);
});
var _hs_ims_get_url_addr = Module["_hs_ims_get_url_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_get_url_addr"].apply(null, arguments);
});
var _hs_ims_httpprov_build_requri = Module["_hs_ims_httpprov_build_requri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_build_requri"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_apn = Module["_hs_ims_httpprov_dec_param_apn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_apn"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_appauth = Module["_hs_ims_httpprov_dec_param_appauth"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_appauth"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_application = Module["_hs_ims_httpprov_dec_param_application"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_application"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_capdiscovery = Module["_hs_ims_httpprov_dec_param_capdiscovery"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_capdiscovery"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_chat = Module["_hs_ims_httpprov_dec_param_chat"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_chat"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_chatbot = Module["_hs_ims_httpprov_dec_param_chatbot"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_chatbot"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_confref = Module["_hs_ims_httpprov_dec_param_confref"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_confref"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_ext = Module["_hs_ims_httpprov_dec_param_ext"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_ext"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_favlink = Module["_hs_ims_httpprov_dec_param_favlink"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_favlink"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_flowtalk = Module["_hs_ims_httpprov_dec_param_flowtalk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_flowtalk"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_ft = Module["_hs_ims_httpprov_dec_param_ft"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_ft"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_icsi = Module["_hs_ims_httpprov_dec_param_icsi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_icsi"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_links = Module["_hs_ims_httpprov_dec_param_links"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_links"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_location = Module["_hs_ims_httpprov_dec_param_location"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_location"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_msgstore = Module["_hs_ims_httpprov_dec_param_msgstore"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_msgstore"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_msrprelay_addr = Module["_hs_ims_httpprov_dec_param_msrprelay_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_msrprelay_addr"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_others = Module["_hs_ims_httpprov_dec_param_others"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_others"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_pcscfaddr = Module["_hs_ims_httpprov_dec_param_pcscfaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_pcscfaddr"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_phnctxt = Module["_hs_ims_httpprov_dec_param_phnctxt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_phnctxt"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_presence = Module["_hs_ims_httpprov_dec_param_presence"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_presence"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_pubid = Module["_hs_ims_httpprov_dec_param_pubid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_pubid"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_secondarydevice = Module["_hs_ims_httpprov_dec_param_secondarydevice"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_secondarydevice"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_services = Module["_hs_ims_httpprov_dec_param_services"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_services"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_standalone = Module["_hs_ims_httpprov_dec_param_standalone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_standalone"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_stunaddress = Module["_hs_ims_httpprov_dec_param_stunaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_stunaddress"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_suppl = Module["_hs_ims_httpprov_dec_param_suppl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_suppl"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_turnaddress = Module["_hs_ims_httpprov_dec_param_turnaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_turnaddress"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_usrmsg = Module["_hs_ims_httpprov_dec_param_usrmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_usrmsg"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_vers = Module["_hs_ims_httpprov_dec_param_vers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_vers"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_vipcontacts = Module["_hs_ims_httpprov_dec_param_vipcontacts"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_vipcontacts"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_xdms = Module["_hs_ims_httpprov_dec_param_xdms"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_xdms"].apply(null, arguments);
});
var _hs_ims_httpprov_dec_param_xport = Module["_hs_ims_httpprov_dec_param_xport"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_dec_param_xport"].apply(null, arguments);
});
var _hs_ims_httpprov_get_autoconf = Module["_hs_ims_httpprov_get_autoconf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_get_autoconf"].apply(null, arguments);
});
var _hs_ims_httpprov_get_cookie_hdr = Module["_hs_ims_httpprov_get_cookie_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_get_cookie_hdr"].apply(null, arguments);
});
var _hs_ims_httpprov_hndle_dnsfail = Module["_hs_ims_httpprov_hndle_dnsfail"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_hndle_dnsfail"].apply(null, arguments);
});
var _hs_ims_httpprov_parse_configfile = Module["_hs_ims_httpprov_parse_configfile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_parse_configfile"].apply(null, arguments);
});
var _hs_ims_httpprov_parse_configxml = Module["_hs_ims_httpprov_parse_configxml"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_httpprov_parse_configxml"].apply(null, arguments);
});
var _hs_ims_identity_create = Module["_hs_ims_identity_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_identity_create"].apply(null, arguments);
});
var _hs_ims_identity_create_copy = Module["_hs_ims_identity_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_identity_create_copy"].apply(null, arguments);
});
var _hs_ims_identity_free = Module["_hs_ims_identity_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_identity_free"].apply(null, arguments);
});
var _hs_ims_match_basicuri = Module["_hs_ims_match_basicuri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_match_basicuri"].apply(null, arguments);
});
var _hs_ims_match_local_uri = Module["_hs_ims_match_local_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_match_local_uri"].apply(null, arguments);
});
var _hs_ims_oam_dec_pub_id = Module["_hs_ims_oam_dec_pub_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_dec_pub_id"].apply(null, arguments);
});
var _hs_ims_oam_http_cb = Module["_hs_ims_oam_http_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_http_cb"].apply(null, arguments);
});
var _hs_ims_oam_httpmsg_free_internal = Module["_hs_ims_oam_httpmsg_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_httpmsg_free_internal"].apply(null, arguments);
});
var _hs_ims_oam_prov_autoconf_internal = Module["_hs_ims_oam_prov_autoconf_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_autoconf_internal"].apply(null, arguments);
});
var _hs_ims_oam_prov_get_autoconf_by_msisdn = Module["_hs_ims_oam_prov_get_autoconf_by_msisdn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_get_autoconf_by_msisdn"].apply(null, arguments);
});
var _hs_ims_oam_prov_get_backupfile = Module["_hs_ims_oam_prov_get_backupfile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_get_backupfile"].apply(null, arguments);
});
var _hs_ims_oam_prov_init = Module["_hs_ims_oam_prov_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_init"].apply(null, arguments);
});
var _hs_ims_oam_prov_proccess_http_finalresp = Module["_hs_ims_oam_prov_proccess_http_finalresp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_proccess_http_finalresp"].apply(null, arguments);
});
var _hs_ims_oam_prov_shutdown = Module["_hs_ims_oam_prov_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_shutdown"].apply(null, arguments);
});
var _hs_ims_oam_prov_timer_cb = Module["_hs_ims_oam_prov_timer_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_timer_cb"].apply(null, arguments);
});
var _hs_ims_oam_prov_update_domain_profile = Module["_hs_ims_oam_prov_update_domain_profile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_update_domain_profile"].apply(null, arguments);
});
var _hs_ims_oam_prov_use_localcfg = Module["_hs_ims_oam_prov_use_localcfg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oam_prov_use_localcfg"].apply(null, arguments);
});
var _hs_ims_oamprov_process_msg = Module["_hs_ims_oamprov_process_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_oamprov_process_msg"].apply(null, arguments);
});
var _hs_ims_parse_param = Module["_hs_ims_parse_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_parse_param"].apply(null, arguments);
});
var _hs_ims_post_sipreg_clear = Module["_hs_ims_post_sipreg_clear"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_post_sipreg_clear"].apply(null, arguments);
});
var _hs_ims_process_app_msg = Module["_hs_ims_process_app_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_process_app_msg"].apply(null, arguments);
});
var _hs_ims_process_nw_event = Module["_hs_ims_process_nw_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_process_nw_event"].apply(null, arguments);
});
var _hs_ims_process_nw_msg = Module["_hs_ims_process_nw_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_process_nw_msg"].apply(null, arguments);
});
var _hs_ims_process_sub_status = Module["_hs_ims_process_sub_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_process_sub_status"].apply(null, arguments);
});
var _hs_ims_process_timer_msg = Module["_hs_ims_process_timer_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_process_timer_msg"].apply(null, arguments);
});
var _hs_ims_prov_add_node = Module["_hs_ims_prov_add_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_add_node"].apply(null, arguments);
});
var _hs_ims_prov_ind_copy = Module["_hs_ims_prov_ind_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_ind_copy"].apply(null, arguments);
});
var _hs_ims_prov_ind_free_internal = Module["_hs_ims_prov_ind_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_ind_free_internal"].apply(null, arguments);
});
var _hs_ims_prov_node_free = Module["_hs_ims_prov_node_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_node_free"].apply(null, arguments);
});
var _hs_ims_prov_params_create_copy = Module["_hs_ims_prov_params_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_params_create_copy"].apply(null, arguments);
});
var _hs_ims_prov_params_free = Module["_hs_ims_prov_params_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_params_free"].apply(null, arguments);
});
var _hs_ims_prov_rcs_config_free = Module["_hs_ims_prov_rcs_config_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_rcs_config_free"].apply(null, arguments);
});
var _hs_ims_prov_rcs_config_init = Module["_hs_ims_prov_rcs_config_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_rcs_config_init"].apply(null, arguments);
});
var _hs_ims_prov_update_autoconfig = Module["_hs_ims_prov_update_autoconfig"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_update_autoconfig"].apply(null, arguments);
});
var _hs_ims_prov_update_rcs_capabs = Module["_hs_ims_prov_update_rcs_capabs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_prov_update_rcs_capabs"].apply(null, arguments);
});
var _hs_ims_provision_update_param = Module["_hs_ims_provision_update_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_provision_update_param"].apply(null, arguments);
});
var _hs_ims_reg = Module["_hs_ims_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg"].apply(null, arguments);
});
var _hs_ims_reg_build_uri = Module["_hs_ims_reg_build_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_build_uri"].apply(null, arguments);
});
var _hs_ims_reg_calc_nextreg_waittime = Module["_hs_ims_reg_calc_nextreg_waittime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_calc_nextreg_waittime"].apply(null, arguments);
});
var _hs_ims_reg_copy_create_params = Module["_hs_ims_reg_copy_create_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_copy_create_params"].apply(null, arguments);
});
var _hs_ims_reg_copy_reg_capabilities = Module["_hs_ims_reg_copy_reg_capabilities"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_copy_reg_capabilities"].apply(null, arguments);
});
var _hs_ims_reg_copy_resp_event = Module["_hs_ims_reg_copy_resp_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_copy_resp_event"].apply(null, arguments);
});
var _hs_ims_reg_create_copy_event = Module["_hs_ims_reg_create_copy_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_create_copy_event"].apply(null, arguments);
});
var _hs_ims_reg_dispatcher = Module["_hs_ims_reg_dispatcher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_dispatcher"].apply(null, arguments);
});
var _hs_ims_reg_fill_secure_settings = Module["_hs_ims_reg_fill_secure_settings"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_fill_secure_settings"].apply(null, arguments);
});
var _hs_ims_reg_free_binding = Module["_hs_ims_reg_free_binding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_free_binding"].apply(null, arguments);
});
var _hs_ims_reg_free_callback = Module["_hs_ims_reg_free_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_free_callback"].apply(null, arguments);
});
var _hs_ims_reg_free_event = Module["_hs_ims_reg_free_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_free_event"].apply(null, arguments);
});
var _hs_ims_reg_free_params = Module["_hs_ims_reg_free_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_free_params"].apply(null, arguments);
});
var _hs_ims_reg_free_resp_event = Module["_hs_ims_reg_free_resp_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_free_resp_event"].apply(null, arguments);
});
var _hs_ims_reg_free_status = Module["_hs_ims_reg_free_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_free_status"].apply(null, arguments);
});
var _hs_ims_reg_get_alt_server = Module["_hs_ims_reg_get_alt_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_get_alt_server"].apply(null, arguments);
});
var _hs_ims_reg_get_event_callback = Module["_hs_ims_reg_get_event_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_get_event_callback"].apply(null, arguments);
});
var _hs_ims_reg_get_refresh_time = Module["_hs_ims_reg_get_refresh_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_get_refresh_time"].apply(null, arguments);
});
var _hs_ims_reg_get_reg_capabilities = Module["_hs_ims_reg_get_reg_capabilities"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_get_reg_capabilities"].apply(null, arguments);
});
var _hs_ims_reg_get_registertimeout = Module["_hs_ims_reg_get_registertimeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_get_registertimeout"].apply(null, arguments);
});
var _hs_ims_reg_get_status_callback = Module["_hs_ims_reg_get_status_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_get_status_callback"].apply(null, arguments);
});
var _hs_ims_reg_inform_event = Module["_hs_ims_reg_inform_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_inform_event"].apply(null, arguments);
});
var _hs_ims_reg_inform_status = Module["_hs_ims_reg_inform_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_inform_status"].apply(null, arguments);
});
var _hs_ims_reg_init = Module["_hs_ims_reg_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_init"].apply(null, arguments);
});
var _hs_ims_reg_reset_cb = Module["_hs_ims_reg_reset_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_reset_cb"].apply(null, arguments);
});
var _hs_ims_reg_resetall_cb = Module["_hs_ims_reg_resetall_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_resetall_cb"].apply(null, arguments);
});
var _hs_ims_reg_set_cb = Module["_hs_ims_reg_set_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_set_cb"].apply(null, arguments);
});
var _hs_ims_reg_shutdown = Module["_hs_ims_reg_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_shutdown"].apply(null, arguments);
});
var _hs_ims_reg_sip_cb = Module["_hs_ims_reg_sip_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_sip_cb"].apply(null, arguments);
});
var _hs_ims_reg_start = Module["_hs_ims_reg_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_start"].apply(null, arguments);
});
var _hs_ims_reg_stop = Module["_hs_ims_reg_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_stop"].apply(null, arguments);
});
var _hs_ims_reg_timer_create = Module["_hs_ims_reg_timer_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_timer_create"].apply(null, arguments);
});
var _hs_ims_reg_timer_delete = Module["_hs_ims_reg_timer_delete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_reg_timer_delete"].apply(null, arguments);
});
var _hs_ims_regapp_create_primary_flow = Module["_hs_ims_regapp_create_primary_flow"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_create_primary_flow"].apply(null, arguments);
});
var _hs_ims_regapp_create_secondary_flow = Module["_hs_ims_regapp_create_secondary_flow"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_create_secondary_flow"].apply(null, arguments);
});
var _hs_ims_regapp_dereg = Module["_hs_ims_regapp_dereg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_dereg"].apply(null, arguments);
});
var _hs_ims_regapp_event_cb = Module["_hs_ims_regapp_event_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_event_cb"].apply(null, arguments);
});
var _hs_ims_regapp_fill_event = Module["_hs_ims_regapp_fill_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_fill_event"].apply(null, arguments);
});
var _hs_ims_regapp_free_cb = Module["_hs_ims_regapp_free_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_free_cb"].apply(null, arguments);
});
var _hs_ims_regapp_free_msg = Module["_hs_ims_regapp_free_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_free_msg"].apply(null, arguments);
});
var _hs_ims_regapp_free_tx = Module["_hs_ims_regapp_free_tx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_free_tx"].apply(null, arguments);
});
var _hs_ims_regapp_get_if_regstatus = Module["_hs_ims_regapp_get_if_regstatus"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_get_if_regstatus"].apply(null, arguments);
});
var _hs_ims_regapp_handle_reset_cb = Module["_hs_ims_regapp_handle_reset_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_handle_reset_cb"].apply(null, arguments);
});
var _hs_ims_regapp_handle_resetall_cb = Module["_hs_ims_regapp_handle_resetall_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_handle_resetall_cb"].apply(null, arguments);
});
var _hs_ims_regapp_inform_event = Module["_hs_ims_regapp_inform_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_inform_event"].apply(null, arguments);
});
var _hs_ims_regapp_init = Module["_hs_ims_regapp_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_init"].apply(null, arguments);
});
var _hs_ims_regapp_ipchange_penddereg = Module["_hs_ims_regapp_ipchange_penddereg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_ipchange_penddereg"].apply(null, arguments);
});
var _hs_ims_regapp_ipchange_pendreg = Module["_hs_ims_regapp_ipchange_pendreg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_ipchange_pendreg"].apply(null, arguments);
});
var _hs_ims_regapp_is_if_registered = Module["_hs_ims_regapp_is_if_registered"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_is_if_registered"].apply(null, arguments);
});
var _hs_ims_regapp_logout_complete = Module["_hs_ims_regapp_logout_complete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_logout_complete"].apply(null, arguments);
});
var _hs_ims_regapp_nwevent_cb = Module["_hs_ims_regapp_nwevent_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_nwevent_cb"].apply(null, arguments);
});
var _hs_ims_regapp_proc_nwevent = Module["_hs_ims_regapp_proc_nwevent"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_proc_nwevent"].apply(null, arguments);
});
var _hs_ims_regapp_proc_regevent = Module["_hs_ims_regapp_proc_regevent"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_proc_regevent"].apply(null, arguments);
});
var _hs_ims_regapp_proc_regstatus = Module["_hs_ims_regapp_proc_regstatus"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_proc_regstatus"].apply(null, arguments);
});
var _hs_ims_regapp_reg = Module["_hs_ims_regapp_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_reg"].apply(null, arguments);
});
var _hs_ims_regapp_reg_without_ob = Module["_hs_ims_regapp_reg_without_ob"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_reg_without_ob"].apply(null, arguments);
});
var _hs_ims_regapp_regbyIf = Module["_hs_ims_regapp_regbyIf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_regbyIf"].apply(null, arguments);
});
var _hs_ims_regapp_regrefresh = Module["_hs_ims_regapp_regrefresh"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_regrefresh"].apply(null, arguments);
});
var _hs_ims_regapp_resetall_cb = Module["_hs_ims_regapp_resetall_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_resetall_cb"].apply(null, arguments);
});
var _hs_ims_regapp_sendtoq = Module["_hs_ims_regapp_sendtoq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_sendtoq"].apply(null, arguments);
});
var _hs_ims_regapp_set_cb = Module["_hs_ims_regapp_set_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_set_cb"].apply(null, arguments);
});
var _hs_ims_regapp_shutdown = Module["_hs_ims_regapp_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_shutdown"].apply(null, arguments);
});
var _hs_ims_regapp_status_cb = Module["_hs_ims_regapp_status_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_regapp_status_cb"].apply(null, arguments);
});
var _hs_ims_retry_reg = Module["_hs_ims_retry_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_retry_reg"].apply(null, arguments);
});
var _hs_ims_sipext_add_hdr = Module["_hs_ims_sipext_add_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_add_hdr"].apply(null, arguments);
});
var _hs_ims_sipext_add_hdrparam = Module["_hs_ims_sipext_add_hdrparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_add_hdrparam"].apply(null, arguments);
});
var _hs_ims_sipext_create_hdr = Module["_hs_ims_sipext_create_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_create_hdr"].apply(null, arguments);
});
var _hs_ims_sipext_get_hdr = Module["_hs_ims_sipext_get_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_get_hdr"].apply(null, arguments);
});
var _hs_ims_sipext_get_hdrparam_val = Module["_hs_ims_sipext_get_hdrparam_val"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_get_hdrparam_val"].apply(null, arguments);
});
var _hs_ims_sipext_get_mthd = Module["_hs_ims_sipext_get_mthd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_get_mthd"].apply(null, arguments);
});
var _hs_ims_sipext_getnxt_hdr = Module["_hs_ims_sipext_getnxt_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_getnxt_hdr"].apply(null, arguments);
});
var _hs_ims_sipext_hdr_free = Module["_hs_ims_sipext_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_hdr_free"].apply(null, arguments);
});
var _hs_ims_sipext_hdr_list_create_copy = Module["_hs_ims_sipext_hdr_list_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_hdr_list_create_copy"].apply(null, arguments);
});
var _hs_ims_sipext_hdrcpy = Module["_hs_ims_sipext_hdrcpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_hdrcpy"].apply(null, arguments);
});
var _hs_ims_sipext_mthd_free = Module["_hs_ims_sipext_mthd_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_sipext_mthd_free"].apply(null, arguments);
});
var _hs_ims_suppserv_allservs_free_internal = Module["_hs_ims_suppserv_allservs_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_allservs_free_internal"].apply(null, arguments);
});
var _hs_ims_suppserv_cbrule_create = Module["_hs_ims_suppserv_cbrule_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_cbrule_create"].apply(null, arguments);
});
var _hs_ims_suppserv_cbrule_create_copy = Module["_hs_ims_suppserv_cbrule_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_cbrule_create_copy"].apply(null, arguments);
});
var _hs_ims_suppserv_cbrule_free = Module["_hs_ims_suppserv_cbrule_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_cbrule_free"].apply(null, arguments);
});
var _hs_ims_suppserv_cdivrule_create = Module["_hs_ims_suppserv_cdivrule_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_cdivrule_create"].apply(null, arguments);
});
var _hs_ims_suppserv_cdivrule_create_copy = Module["_hs_ims_suppserv_cdivrule_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_cdivrule_create_copy"].apply(null, arguments);
});
var _hs_ims_suppserv_cdivrule_free = Module["_hs_ims_suppserv_cdivrule_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_cdivrule_free"].apply(null, arguments);
});
var _hs_ims_suppserv_cmp_xactid = Module["_hs_ims_suppserv_cmp_xactid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_cmp_xactid"].apply(null, arguments);
});
var _hs_ims_suppserv_init = Module["_hs_ims_suppserv_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_init"].apply(null, arguments);
});
var _hs_ims_suppserv_node_free = Module["_hs_ims_suppserv_node_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_node_free"].apply(null, arguments);
});
var _hs_ims_suppserv_param_free_internal = Module["_hs_ims_suppserv_param_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_param_free_internal"].apply(null, arguments);
});
var _hs_ims_suppserv_parse_xml_doc = Module["_hs_ims_suppserv_parse_xml_doc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_parse_xml_doc"].apply(null, arguments);
});
var _hs_ims_suppserv_proc_httpmsg = Module["_hs_ims_suppserv_proc_httpmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_proc_httpmsg"].apply(null, arguments);
});
var _hs_ims_suppserv_shutdown = Module["_hs_ims_suppserv_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_shutdown"].apply(null, arguments);
});
var _hs_ims_suppserv_tag_data = Module["_hs_ims_suppserv_tag_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_tag_data"].apply(null, arguments);
});
var _hs_ims_suppserv_tag_end = Module["_hs_ims_suppserv_tag_end"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_tag_end"].apply(null, arguments);
});
var _hs_ims_suppserv_tag_start = Module["_hs_ims_suppserv_tag_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppserv_tag_start"].apply(null, arguments);
});
var _hs_ims_suppservs_evt_copy = Module["_hs_ims_suppservs_evt_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppservs_evt_copy"].apply(null, arguments);
});
var _hs_ims_suppservs_evt_free_internal = Module["_hs_ims_suppservs_evt_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_suppservs_evt_free_internal"].apply(null, arguments);
});
var _hs_ims_vs_sdp_add_medialine = Module["_hs_ims_vs_sdp_add_medialine"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_vs_sdp_add_medialine"].apply(null, arguments);
});
var _hs_ims_vs_sdp_compare_medialine = Module["_hs_ims_vs_sdp_compare_medialine"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_vs_sdp_compare_medialine"].apply(null, arguments);
});
var _hs_ims_wasm_socket_cbs_init = Module["_hs_ims_wasm_socket_cbs_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ims_wasm_socket_cbs_init"].apply(null, arguments);
});
var _hs_imsreg_ccm_callback = Module["_hs_imsreg_ccm_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_imsreg_ccm_callback"].apply(null, arguments);
});
var _hs_imsreg_handle_regevnt_notify = Module["_hs_imsreg_handle_regevnt_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_imsreg_handle_regevnt_notify"].apply(null, arguments);
});
var _hs_msm_add_aor = Module["_hs_msm_add_aor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_add_aor"].apply(null, arguments);
});
var _hs_msm_answer_call = Module["_hs_msm_answer_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_answer_call"].apply(null, arguments);
});
var _hs_msm_app_ctx_destroy = Module["_hs_msm_app_ctx_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_app_ctx_destroy"].apply(null, arguments);
});
var _hs_msm_build_uri_from_identity = Module["_hs_msm_build_uri_from_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_build_uri_from_identity"].apply(null, arguments);
});
var _hs_msm_call_ctx_destroy = Module["_hs_msm_call_ctx_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_call_ctx_destroy"].apply(null, arguments);
});
var _hs_msm_call_ctx_init = Module["_hs_msm_call_ctx_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_call_ctx_init"].apply(null, arguments);
});
var _hs_msm_create_bridge_conference = Module["_hs_msm_create_bridge_conference"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_create_bridge_conference"].apply(null, arguments);
});
var _hs_msm_ctx_lock = Module["_hs_msm_ctx_lock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_ctx_lock"].apply(null, arguments);
});
var _hs_msm_ctx_unlock = Module["_hs_msm_ctx_unlock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_ctx_unlock"].apply(null, arguments);
});
var _hs_msm_delete_aor = Module["_hs_msm_delete_aor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_delete_aor"].apply(null, arguments);
});
var _hs_msm_do_dereg = Module["_hs_msm_do_dereg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_do_dereg"].apply(null, arguments);
});
var _hs_msm_do_reg = Module["_hs_msm_do_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_do_reg"].apply(null, arguments);
});
var _hs_msm_do_reg_internal = Module["_hs_msm_do_reg_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_do_reg_internal"].apply(null, arguments);
});
var _hs_msm_do_reg_refresh = Module["_hs_msm_do_reg_refresh"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_do_reg_refresh"].apply(null, arguments);
});
var _hs_msm_end_all_sessions = Module["_hs_msm_end_all_sessions"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_end_all_sessions"].apply(null, arguments);
});
var _hs_msm_evt_msg_escape_uri = Module["_hs_msm_evt_msg_escape_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_evt_msg_escape_uri"].apply(null, arguments);
});
var _hs_msm_free_cb_ind = Module["_hs_msm_free_cb_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_free_cb_ind"].apply(null, arguments);
});
var _hs_msm_gen_ind_create_copy = Module["_hs_msm_gen_ind_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_gen_ind_create_copy"].apply(null, arguments);
});
var _hs_msm_get_aor_reg_capblist = Module["_hs_msm_get_aor_reg_capblist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_aor_reg_capblist"].apply(null, arguments);
});
var _hs_msm_get_app_ctx_from_appid = Module["_hs_msm_get_app_ctx_from_appid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_app_ctx_from_appid"].apply(null, arguments);
});
var _hs_msm_get_call_ctx_from_uid = Module["_hs_msm_get_call_ctx_from_uid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_call_ctx_from_uid"].apply(null, arguments);
});
var _hs_msm_get_call_init_nwk = Module["_hs_msm_get_call_init_nwk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_call_init_nwk"].apply(null, arguments);
});
var _hs_msm_get_id_map_prof_info = Module["_hs_msm_get_id_map_prof_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_id_map_prof_info"].apply(null, arguments);
});
var _hs_msm_get_service_context = Module["_hs_msm_get_service_context"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_service_context"].apply(null, arguments);
});
var _hs_msm_get_usable_serv_from_aor = Module["_hs_msm_get_usable_serv_from_aor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_usable_serv_from_aor"].apply(null, arguments);
});
var _hs_msm_get_usable_services = Module["_hs_msm_get_usable_services"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_usable_services"].apply(null, arguments);
});
var _hs_msm_get_voip_start_mode = Module["_hs_msm_get_voip_start_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_get_voip_start_mode"].apply(null, arguments);
});
var _hs_msm_handle_call_release_state = Module["_hs_msm_handle_call_release_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_handle_call_release_state"].apply(null, arguments);
});
var _hs_msm_handle_call_state_change = Module["_hs_msm_handle_call_state_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_handle_call_state_change"].apply(null, arguments);
});
var _hs_msm_handle_cap_change = Module["_hs_msm_handle_cap_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_handle_cap_change"].apply(null, arguments);
});
var _hs_msm_handle_cap_mod_for_emerg_mode_change = Module["_hs_msm_handle_cap_mod_for_emerg_mode_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_handle_cap_mod_for_emerg_mode_change"].apply(null, arguments);
});
var _hs_msm_handle_eam_event = Module["_hs_msm_handle_eam_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_handle_eam_event"].apply(null, arguments);
});
var _hs_msm_handle_ecb_mode_complete = Module["_hs_msm_handle_ecb_mode_complete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_handle_ecb_mode_complete"].apply(null, arguments);
});
var _hs_msm_handle_prof_caps_change = Module["_hs_msm_handle_prof_caps_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_handle_prof_caps_change"].apply(null, arguments);
});
var _hs_msm_hoff_comp_handler = Module["_hs_msm_hoff_comp_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_hoff_comp_handler"].apply(null, arguments);
});
var _hs_msm_hold_call = Module["_hs_msm_hold_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_hold_call"].apply(null, arguments);
});
var _hs_msm_init = Module["_hs_msm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_init"].apply(null, arguments);
});
var _hs_msm_is_cs_call_present = Module["_hs_msm_is_cs_call_present"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_cs_call_present"].apply(null, arguments);
});
var _hs_msm_is_domain_config_available = Module["_hs_msm_is_domain_config_available"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_domain_config_available"].apply(null, arguments);
});
var _hs_msm_is_domain_loaded = Module["_hs_msm_is_domain_loaded"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_domain_loaded"].apply(null, arguments);
});
var _hs_msm_is_emergency_num = Module["_hs_msm_is_emergency_num"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_emergency_num"].apply(null, arguments);
});
var _hs_msm_is_match_with_local_uri = Module["_hs_msm_is_match_with_local_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_match_with_local_uri"].apply(null, arguments);
});
var _hs_msm_is_new_calls_allowed = Module["_hs_msm_is_new_calls_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_new_calls_allowed"].apply(null, arguments);
});
var _hs_msm_is_profile_config_available = Module["_hs_msm_is_profile_config_available"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_profile_config_available"].apply(null, arguments);
});
var _hs_msm_is_profile_loaded = Module["_hs_msm_is_profile_loaded"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_profile_loaded"].apply(null, arguments);
});
var _hs_msm_is_started = Module["_hs_msm_is_started"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_is_started"].apply(null, arguments);
});
var _hs_msm_make_call = Module["_hs_msm_make_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_make_call"].apply(null, arguments);
});
var _hs_msm_make_call_x = Module["_hs_msm_make_call_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_make_call_x"].apply(null, arguments);
});
var _hs_msm_map_caps_to_services = Module["_hs_msm_map_caps_to_services"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_map_caps_to_services"].apply(null, arguments);
});
var _hs_msm_map_services_to_caps = Module["_hs_msm_map_services_to_caps"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_map_services_to_caps"].apply(null, arguments);
});
var _hs_msm_map_voip_error_code = Module["_hs_msm_map_voip_error_code"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_map_voip_error_code"].apply(null, arguments);
});
var _hs_msm_process_auto_login = Module["_hs_msm_process_auto_login"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_process_auto_login"].apply(null, arguments);
});
var _hs_msm_process_emergency_call = Module["_hs_msm_process_emergency_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_process_emergency_call"].apply(null, arguments);
});
var _hs_msm_prof_ctx_destroy = Module["_hs_msm_prof_ctx_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_prof_ctx_destroy"].apply(null, arguments);
});
var _hs_msm_prov_verify_state = Module["_hs_msm_prov_verify_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_prov_verify_state"].apply(null, arguments);
});
var _hs_msm_reg_event_cb = Module["_hs_msm_reg_event_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_reg_event_cb"].apply(null, arguments);
});
var _hs_msm_register_app = Module["_hs_msm_register_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_register_app"].apply(null, arguments);
});
var _hs_msm_register_app_internal = Module["_hs_msm_register_app_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_register_app_internal"].apply(null, arguments);
});
var _hs_msm_release_all_calls = Module["_hs_msm_release_all_calls"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_release_all_calls"].apply(null, arguments);
});
var _hs_msm_release_call = Module["_hs_msm_release_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_release_call"].apply(null, arguments);
});
var _hs_msm_release_call_x = Module["_hs_msm_release_call_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_release_call_x"].apply(null, arguments);
});
var _hs_msm_remove_app_ctx = Module["_hs_msm_remove_app_ctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_remove_app_ctx"].apply(null, arguments);
});
var _hs_msm_restart_internal = Module["_hs_msm_restart_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_restart_internal"].apply(null, arguments);
});
var _hs_msm_rsrc_get_aorcapab = Module["_hs_msm_rsrc_get_aorcapab"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_rsrc_get_aorcapab"].apply(null, arguments);
});
var _hs_msm_rsrc_get_aorcapab_internal = Module["_hs_msm_rsrc_get_aorcapab_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_rsrc_get_aorcapab_internal"].apply(null, arguments);
});
var _hs_msm_send_aor_status_ind = Module["_hs_msm_send_aor_status_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_send_aor_status_ind"].apply(null, arguments);
});
var _hs_msm_send_app_status_ind = Module["_hs_msm_send_app_status_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_send_app_status_ind"].apply(null, arguments);
});
var _hs_msm_send_call_ind_to_app = Module["_hs_msm_send_call_ind_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_send_call_ind_to_app"].apply(null, arguments);
});
var _hs_msm_send_call_state_to_hoffmngr = Module["_hs_msm_send_call_state_to_hoffmngr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_send_call_state_to_hoffmngr"].apply(null, arguments);
});
var _hs_msm_send_gen_ind_to_app = Module["_hs_msm_send_gen_ind_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_send_gen_ind_to_app"].apply(null, arguments);
});
var _hs_msm_send_ind_to_app = Module["_hs_msm_send_ind_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_send_ind_to_app"].apply(null, arguments);
});
var _hs_msm_send_oam_ind = Module["_hs_msm_send_oam_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_send_oam_ind"].apply(null, arguments);
});
var _hs_msm_signin = Module["_hs_msm_signin"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_signin"].apply(null, arguments);
});
var _hs_msm_signin_internal = Module["_hs_msm_signin_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_signin_internal"].apply(null, arguments);
});
var _hs_msm_signout_internal = Module["_hs_msm_signout_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_signout_internal"].apply(null, arguments);
});
var _hs_msm_sms_ctx_destroy = Module["_hs_msm_sms_ctx_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_sms_ctx_destroy"].apply(null, arguments);
});
var _hs_msm_ssn_params_init = Module["_hs_msm_ssn_params_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_ssn_params_init"].apply(null, arguments);
});
var _hs_msm_start = Module["_hs_msm_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_start"].apply(null, arguments);
});
var _hs_msm_start_provisioning_by_msisdn = Module["_hs_msm_start_provisioning_by_msisdn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_start_provisioning_by_msisdn"].apply(null, arguments);
});
var _hs_msm_stop_ext_serv_mod = Module["_hs_msm_stop_ext_serv_mod"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_stop_ext_serv_mod"].apply(null, arguments);
});
var _hs_msm_stop_internal = Module["_hs_msm_stop_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_stop_internal"].apply(null, arguments);
});
var _hs_msm_subscpt_ctx_destroy = Module["_hs_msm_subscpt_ctx_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_subscpt_ctx_destroy"].apply(null, arguments);
});
var _hs_msm_timer_cb = Module["_hs_msm_timer_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_timer_cb"].apply(null, arguments);
});
var _hs_msm_unhold_call = Module["_hs_msm_unhold_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_unhold_call"].apply(null, arguments);
});
var _hs_msm_validate_get_remote_uri = Module["_hs_msm_validate_get_remote_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_validate_get_remote_uri"].apply(null, arguments);
});
var _hs_msm_validate_sip_uri = Module["_hs_msm_validate_sip_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_validate_sip_uri"].apply(null, arguments);
});
var _hs_msm_voip_ev_handler = Module["_hs_msm_voip_ev_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_voip_ev_handler"].apply(null, arguments);
});
var _hs_msm_vs_ctx_destroy = Module["_hs_msm_vs_ctx_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_msm_vs_ctx_destroy"].apply(null, arguments);
});
var _hs_ncm_add_adptr = Module["_hs_ncm_add_adptr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_add_adptr"].apply(null, arguments);
});
var _hs_ncm_addrlistchange_handler = Module["_hs_ncm_addrlistchange_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_addrlistchange_handler"].apply(null, arguments);
});
var _hs_ncm_adpt_add_cs_nwk = Module["_hs_ncm_adpt_add_cs_nwk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_add_cs_nwk"].apply(null, arguments);
});
var _hs_ncm_adpt_context_copy = Module["_hs_ncm_adpt_context_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_context_copy"].apply(null, arguments);
});
var _hs_ncm_adpt_context_init = Module["_hs_ncm_adpt_context_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_context_init"].apply(null, arguments);
});
var _hs_ncm_adpt_info_remove = Module["_hs_ncm_adpt_info_remove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_info_remove"].apply(null, arguments);
});
var _hs_ncm_adpt_info_update = Module["_hs_ncm_adpt_info_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_info_update"].apply(null, arguments);
});
var _hs_ncm_adpt_init = Module["_hs_ncm_adpt_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_init"].apply(null, arguments);
});
var _hs_ncm_adpt_init_native = Module["_hs_ncm_adpt_init_native"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_init_native"].apply(null, arguments);
});
var _hs_ncm_adpt_ipaddr_copy_create = Module["_hs_ncm_adpt_ipaddr_copy_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_ipaddr_copy_create"].apply(null, arguments);
});
var _hs_ncm_adpt_ipaddr_is_equal = Module["_hs_ncm_adpt_ipaddr_is_equal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_ipaddr_is_equal"].apply(null, arguments);
});
var _hs_ncm_adpt_shutdown = Module["_hs_ncm_adpt_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_shutdown"].apply(null, arguments);
});
var _hs_ncm_adpt_update_rasadptrs = Module["_hs_ncm_adpt_update_rasadptrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_adpt_update_rasadptrs"].apply(null, arguments);
});
var _hs_ncm_build_xpath = Module["_hs_ncm_build_xpath"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_build_xpath"].apply(null, arguments);
});
var _hs_ncm_cb_tag_data = Module["_hs_ncm_cb_tag_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_cb_tag_data"].apply(null, arguments);
});
var _hs_ncm_cb_tag_start = Module["_hs_ncm_cb_tag_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_cb_tag_start"].apply(null, arguments);
});
var _hs_ncm_cell_monitor_init = Module["_hs_ncm_cell_monitor_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_cell_monitor_init"].apply(null, arguments);
});
var _hs_ncm_cell_monitor_shutdown = Module["_hs_ncm_cell_monitor_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_cell_monitor_shutdown"].apply(null, arguments);
});
var _hs_ncm_celldata_monitor_init = Module["_hs_ncm_celldata_monitor_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_celldata_monitor_init"].apply(null, arguments);
});
var _hs_ncm_celldata_monitor_query_nq = Module["_hs_ncm_celldata_monitor_query_nq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_celldata_monitor_query_nq"].apply(null, arguments);
});
var _hs_ncm_celldata_monitor_shutdown = Module["_hs_ncm_celldata_monitor_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_celldata_monitor_shutdown"].apply(null, arguments);
});
var _hs_ncm_config_get_adpt_type = Module["_hs_ncm_config_get_adpt_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_config_get_adpt_type"].apply(null, arguments);
});
var _hs_ncm_config_init = Module["_hs_ncm_config_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_config_init"].apply(null, arguments);
});
var _hs_ncm_config_is_adapt_ignored = Module["_hs_ncm_config_is_adapt_ignored"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_config_is_adapt_ignored"].apply(null, arguments);
});
var _hs_ncm_config_shutdown = Module["_hs_ncm_config_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_config_shutdown"].apply(null, arguments);
});
var _hs_ncm_context_lock_acquire = Module["_hs_ncm_context_lock_acquire"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_context_lock_acquire"].apply(null, arguments);
});
var _hs_ncm_context_lock_release = Module["_hs_ncm_context_lock_release"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_context_lock_release"].apply(null, arguments);
});
var _hs_ncm_core_get_ss_band = Module["_hs_ncm_core_get_ss_band"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_get_ss_band"].apply(null, arguments);
});
var _hs_ncm_core_init = Module["_hs_ncm_core_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_init"].apply(null, arguments);
});
var _hs_ncm_core_post_msg = Module["_hs_ncm_core_post_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_post_msg"].apply(null, arguments);
});
var _hs_ncm_core_post_route_change_event_to_app = Module["_hs_ncm_core_post_route_change_event_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_post_route_change_event_to_app"].apply(null, arguments);
});
var _hs_ncm_core_proc_nq_event = Module["_hs_ncm_core_proc_nq_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_proc_nq_event"].apply(null, arguments);
});
var _hs_ncm_core_resume = Module["_hs_ncm_core_resume"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_resume"].apply(null, arguments);
});
var _hs_ncm_core_shutdown = Module["_hs_ncm_core_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_shutdown"].apply(null, arguments);
});
var _hs_ncm_core_start = Module["_hs_ncm_core_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_start"].apply(null, arguments);
});
var _hs_ncm_core_stop = Module["_hs_ncm_core_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_stop"].apply(null, arguments);
});
var _hs_ncm_core_thead_entry = Module["_hs_ncm_core_thead_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_thead_entry"].apply(null, arguments);
});
var _hs_ncm_core_update_sq_trigger = Module["_hs_ncm_core_update_sq_trigger"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_core_update_sq_trigger"].apply(null, arguments);
});
var _hs_ncm_dereg_app = Module["_hs_ncm_dereg_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_dereg_app"].apply(null, arguments);
});
var _hs_ncm_destroy_adpt_lists = Module["_hs_ncm_destroy_adpt_lists"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_destroy_adpt_lists"].apply(null, arguments);
});
var _hs_ncm_free_adpt_list = Module["_hs_ncm_free_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_free_adpt_list"].apply(null, arguments);
});
var _hs_ncm_get_adapter_list = Module["_hs_ncm_get_adapter_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_adapter_list"].apply(null, arguments);
});
var _hs_ncm_get_adpt_conn_name = Module["_hs_ncm_get_adpt_conn_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_adpt_conn_name"].apply(null, arguments);
});
var _hs_ncm_get_adpt_conn_name_native = Module["_hs_ncm_get_adpt_conn_name_native"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_adpt_conn_name_native"].apply(null, arguments);
});
var _hs_ncm_get_adpt_info = Module["_hs_ncm_get_adpt_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_adpt_info"].apply(null, arguments);
});
var _hs_ncm_get_adpt_list = Module["_hs_ncm_get_adpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_adpt_list"].apply(null, arguments);
});
var _hs_ncm_get_best_if_index = Module["_hs_ncm_get_best_if_index"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_best_if_index"].apply(null, arguments);
});
var _hs_ncm_get_dns_ip = Module["_hs_ncm_get_dns_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_dns_ip"].apply(null, arguments);
});
var _hs_ncm_get_dns_ip_native = Module["_hs_ncm_get_dns_ip_native"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_get_dns_ip_native"].apply(null, arguments);
});
var _hs_ncm_getadptrbyname = Module["_hs_ncm_getadptrbyname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_getadptrbyname"].apply(null, arguments);
});
var _hs_ncm_getadptrbytype = Module["_hs_ncm_getadptrbytype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_getadptrbytype"].apply(null, arguments);
});
var _hs_ncm_init = Module["_hs_ncm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_init"].apply(null, arguments);
});
var _hs_ncm_nwk_adpt_create = Module["_hs_ncm_nwk_adpt_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_adpt_create"].apply(null, arguments);
});
var _hs_ncm_nwk_adpt_list_destroy = Module["_hs_ncm_nwk_adpt_list_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_adpt_list_destroy"].apply(null, arguments);
});
var _hs_ncm_nwk_events_init = Module["_hs_ncm_nwk_events_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_events_init"].apply(null, arguments);
});
var _hs_ncm_nwk_events_resume = Module["_hs_ncm_nwk_events_resume"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_events_resume"].apply(null, arguments);
});
var _hs_ncm_nwk_events_shutdown = Module["_hs_ncm_nwk_events_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_events_shutdown"].apply(null, arguments);
});
var _hs_ncm_nwk_events_start = Module["_hs_ncm_nwk_events_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_events_start"].apply(null, arguments);
});
var _hs_ncm_nwk_events_stop = Module["_hs_ncm_nwk_events_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_events_stop"].apply(null, arguments);
});
var _hs_ncm_nwk_events_suspend = Module["_hs_ncm_nwk_events_suspend"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_events_suspend"].apply(null, arguments);
});
var _hs_ncm_nwk_netlink_dispatch = Module["_hs_ncm_nwk_netlink_dispatch"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_netlink_dispatch"].apply(null, arguments);
});
var _hs_ncm_nwk_pre_adpt_list_free = Module["_hs_ncm_nwk_pre_adpt_list_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_pre_adpt_list_free"].apply(null, arguments);
});
var _hs_ncm_nwk_pre_adpt_list_update = Module["_hs_ncm_nwk_pre_adpt_list_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_pre_adpt_list_update"].apply(null, arguments);
});
var _hs_ncm_nwk_reset_reg_callback = Module["_hs_ncm_nwk_reset_reg_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_reset_reg_callback"].apply(null, arguments);
});
var _hs_ncm_nwk_sendto_event_cb = Module["_hs_ncm_nwk_sendto_event_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_sendto_event_cb"].apply(null, arguments);
});
var _hs_ncm_nwk_set_reg_callback = Module["_hs_ncm_nwk_set_reg_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_nwk_set_reg_callback"].apply(null, arguments);
});
var _hs_ncm_post_ind_to_app = Module["_hs_ncm_post_ind_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_post_ind_to_app"].apply(null, arguments);
});
var _hs_ncm_reg_app = Module["_hs_ncm_reg_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_reg_app"].apply(null, arguments);
});
var _hs_ncm_set_metric_of_default_route = Module["_hs_ncm_set_metric_of_default_route"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_set_metric_of_default_route"].apply(null, arguments);
});
var _hs_ncm_shutdown = Module["_hs_ncm_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_shutdown"].apply(null, arguments);
});
var _hs_ncm_start = Module["_hs_ncm_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_start"].apply(null, arguments);
});
var _hs_ncm_statobs_adpt_ev_callback = Module["_hs_ncm_statobs_adpt_ev_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_statobs_adpt_ev_callback"].apply(null, arguments);
});
var _hs_ncm_statobs_init = Module["_hs_ncm_statobs_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_statobs_init"].apply(null, arguments);
});
var _hs_ncm_statobs_resume = Module["_hs_ncm_statobs_resume"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_statobs_resume"].apply(null, arguments);
});
var _hs_ncm_statobs_shutdown = Module["_hs_ncm_statobs_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_statobs_shutdown"].apply(null, arguments);
});
var _hs_ncm_statobs_start = Module["_hs_ncm_statobs_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_statobs_start"].apply(null, arguments);
});
var _hs_ncm_statobs_stop = Module["_hs_ncm_statobs_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_statobs_stop"].apply(null, arguments);
});
var _hs_ncm_statobs_suspend = Module["_hs_ncm_statobs_suspend"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_statobs_suspend"].apply(null, arguments);
});
var _hs_ncm_stop = Module["_hs_ncm_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_stop"].apply(null, arguments);
});
var _hs_ncm_validate_and_set = Module["_hs_ncm_validate_and_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_validate_and_set"].apply(null, arguments);
});
var _hs_ncm_wifi_monitor_init = Module["_hs_ncm_wifi_monitor_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_wifi_monitor_init"].apply(null, arguments);
});
var _hs_ncm_wifi_monitor_shutdown = Module["_hs_ncm_wifi_monitor_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncm_wifi_monitor_shutdown"].apply(null, arguments);
});
var _hs_ncmconfig_xmltree_update = Module["_hs_ncmconfig_xmltree_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_ncmconfig_xmltree_update"].apply(null, arguments);
});
var _hs_nwk_viability_init = Module["_hs_nwk_viability_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_nwk_viability_init"].apply(null, arguments);
});
var _hs_nwk_viability_shutdown = Module["_hs_nwk_viability_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_nwk_viability_shutdown"].apply(null, arguments);
});
var _hs_nwk_viability_start = Module["_hs_nwk_viability_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_nwk_viability_start"].apply(null, arguments);
});
var _hs_nwk_viability_start_test = Module["_hs_nwk_viability_start_test"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_nwk_viability_start_test"].apply(null, arguments);
});
var _hs_nwk_viability_stop = Module["_hs_nwk_viability_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_nwk_viability_stop"].apply(null, arguments);
});
var _hs_oam_is_profile_exists = Module["_hs_oam_is_profile_exists"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_oam_is_profile_exists"].apply(null, arguments);
});
var _hs_rp_build_path = Module["_hs_rp_build_path"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_build_path"].apply(null, arguments);
});
var _hs_rp_conn_nw = Module["_hs_rp_conn_nw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_conn_nw"].apply(null, arguments);
});
var _hs_rp_disconn_nw = Module["_hs_rp_disconn_nw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_disconn_nw"].apply(null, arguments);
});
var _hs_rp_evt_free = Module["_hs_rp_evt_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_evt_free"].apply(null, arguments);
});
var _hs_rp_get_evtdisp = Module["_hs_rp_get_evtdisp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_get_evtdisp"].apply(null, arguments);
});
var _hs_rp_get_radioname = Module["_hs_rp_get_radioname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_get_radioname"].apply(null, arguments);
});
var _hs_rp_getevt_data = Module["_hs_rp_getevt_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_getevt_data"].apply(null, arguments);
});
var _hs_rp_init = Module["_hs_rp_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_init"].apply(null, arguments);
});
var _hs_rp_init_voicemode = Module["_hs_rp_init_voicemode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_init_voicemode"].apply(null, arguments);
});
var _hs_rp_ncm_ind_callback = Module["_hs_rp_ncm_ind_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_ncm_ind_callback"].apply(null, arguments);
});
var _hs_rp_post_evtdata = Module["_hs_rp_post_evtdata"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_post_evtdata"].apply(null, arguments);
});
var _hs_rp_radio_off = Module["_hs_rp_radio_off"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_radio_off"].apply(null, arguments);
});
var _hs_rp_radio_on = Module["_hs_rp_radio_on"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_radio_on"].apply(null, arguments);
});
var _hs_rp_shutdown = Module["_hs_rp_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_shutdown"].apply(null, arguments);
});
var _hs_rp_sm_rootctx_destroy = Module["_hs_rp_sm_rootctx_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_sm_rootctx_destroy"].apply(null, arguments);
});
var _hs_rp_start = Module["_hs_rp_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_start"].apply(null, arguments);
});
var _hs_rp_stop = Module["_hs_rp_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_stop"].apply(null, arguments);
});
var _hs_rp_switch_voicemode = Module["_hs_rp_switch_voicemode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_switch_voicemode"].apply(null, arguments);
});
var _hs_rp_timer_fired = Module["_hs_rp_timer_fired"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_timer_fired"].apply(null, arguments);
});
var _hs_rp_timer_init = Module["_hs_rp_timer_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_timer_init"].apply(null, arguments);
});
var _hs_rp_timer_reset = Module["_hs_rp_timer_reset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_timer_reset"].apply(null, arguments);
});
var _hs_rp_timer_start = Module["_hs_rp_timer_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_timer_start"].apply(null, arguments);
});
var _hs_rp_timer_stop = Module["_hs_rp_timer_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_rp_timer_stop"].apply(null, arguments);
});
var _hs_sig_notify_dispatcher = Module["_hs_sig_notify_dispatcher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sig_notify_dispatcher"].apply(null, arguments);
});
var _hs_sip326x_address_hdr_name_modify = Module["_hs_sip326x_address_hdr_name_modify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_address_hdr_name_modify"].apply(null, arguments);
});
var _hs_sip326x_aka_get_resp = Module["_hs_sip326x_aka_get_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_aka_get_resp"].apply(null, arguments);
});
var _hs_sip326x_build_authrz = Module["_hs_sip326x_build_authrz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_build_authrz"].apply(null, arguments);
});
var _hs_sip326x_build_dns_req = Module["_hs_sip326x_build_dns_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_build_dns_req"].apply(null, arguments);
});
var _hs_sip326x_build_proxyauthrz = Module["_hs_sip326x_build_proxyauthrz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_build_proxyauthrz"].apply(null, arguments);
});
var _hs_sip326x_build_warning = Module["_hs_sip326x_build_warning"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_build_warning"].apply(null, arguments);
});
var _hs_sip326x_build_wwwauthn = Module["_hs_sip326x_build_wwwauthn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_build_wwwauthn"].apply(null, arguments);
});
var _hs_sip326x_check_add_sock = Module["_hs_sip326x_check_add_sock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_check_add_sock"].apply(null, arguments);
});
var _hs_sip326x_check_del_sock = Module["_hs_sip326x_check_del_sock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_check_del_sock"].apply(null, arguments);
});
var _hs_sip326x_compare_address = Module["_hs_sip326x_compare_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_compare_address"].apply(null, arguments);
});
var _hs_sip326x_compare_host = Module["_hs_sip326x_compare_host"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_compare_host"].apply(null, arguments);
});
var _hs_sip326x_compare_str_ptr = Module["_hs_sip326x_compare_str_ptr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_compare_str_ptr"].apply(null, arguments);
});
var _hs_sip326x_compare_uri = Module["_hs_sip326x_compare_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_compare_uri"].apply(null, arguments);
});
var _hs_sip326x_convert_uri_identity = Module["_hs_sip326x_convert_uri_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_convert_uri_identity"].apply(null, arguments);
});
var _hs_sip326x_copy_ccm_msg = Module["_hs_sip326x_copy_ccm_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_copy_ccm_msg"].apply(null, arguments);
});
var _hs_sip326x_copy_nw_adpt = Module["_hs_sip326x_copy_nw_adpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_copy_nw_adpt"].apply(null, arguments);
});
var _hs_sip326x_copy_via_branch = Module["_hs_sip326x_copy_via_branch"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_copy_via_branch"].apply(null, arguments);
});
var _hs_sip326x_create_cnonce = Module["_hs_sip326x_create_cnonce"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_create_cnonce"].apply(null, arguments);
});
var _hs_sip326x_encode_accept = Module["_hs_sip326x_encode_accept"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_accept"].apply(null, arguments);
});
var _hs_sip326x_encode_accept_element = Module["_hs_sip326x_encode_accept_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_accept_element"].apply(null, arguments);
});
var _hs_sip326x_encode_accept_encoding = Module["_hs_sip326x_encode_accept_encoding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_accept_encoding"].apply(null, arguments);
});
var _hs_sip326x_encode_addr_hdrname = Module["_hs_sip326x_encode_addr_hdrname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_addr_hdrname"].apply(null, arguments);
});
var _hs_sip326x_encode_addr_hdrvalue = Module["_hs_sip326x_encode_addr_hdrvalue"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_addr_hdrvalue"].apply(null, arguments);
});
var _hs_sip326x_encode_addr_header = Module["_hs_sip326x_encode_addr_header"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_addr_header"].apply(null, arguments);
});
var _hs_sip326x_encode_allow = Module["_hs_sip326x_encode_allow"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_allow"].apply(null, arguments);
});
var _hs_sip326x_encode_auth_ext_params = Module["_hs_sip326x_encode_auth_ext_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_auth_ext_params"].apply(null, arguments);
});
var _hs_sip326x_encode_authn = Module["_hs_sip326x_encode_authn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_authn"].apply(null, arguments);
});
var _hs_sip326x_encode_authn_element = Module["_hs_sip326x_encode_authn_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_authn_element"].apply(null, arguments);
});
var _hs_sip326x_encode_authrz = Module["_hs_sip326x_encode_authrz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_authrz"].apply(null, arguments);
});
var _hs_sip326x_encode_authrz_element = Module["_hs_sip326x_encode_authrz_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_authrz_element"].apply(null, arguments);
});
var _hs_sip326x_encode_call_id = Module["_hs_sip326x_encode_call_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_call_id"].apply(null, arguments);
});
var _hs_sip326x_encode_callinfo = Module["_hs_sip326x_encode_callinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_callinfo"].apply(null, arguments);
});
var _hs_sip326x_encode_change2_upcase = Module["_hs_sip326x_encode_change2_upcase"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_change2_upcase"].apply(null, arguments);
});
var _hs_sip326x_encode_contact = Module["_hs_sip326x_encode_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_contact"].apply(null, arguments);
});
var _hs_sip326x_encode_contact_element = Module["_hs_sip326x_encode_contact_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_contact_element"].apply(null, arguments);
});
var _hs_sip326x_encode_content = Module["_hs_sip326x_encode_content"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_content"].apply(null, arguments);
});
var _hs_sip326x_encode_content_disposition = Module["_hs_sip326x_encode_content_disposition"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_content_disposition"].apply(null, arguments);
});
var _hs_sip326x_encode_content_encoding = Module["_hs_sip326x_encode_content_encoding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_content_encoding"].apply(null, arguments);
});
var _hs_sip326x_encode_content_language = Module["_hs_sip326x_encode_content_language"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_content_language"].apply(null, arguments);
});
var _hs_sip326x_encode_content_length = Module["_hs_sip326x_encode_content_length"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_content_length"].apply(null, arguments);
});
var _hs_sip326x_encode_content_type = Module["_hs_sip326x_encode_content_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_content_type"].apply(null, arguments);
});
var _hs_sip326x_encode_cseq = Module["_hs_sip326x_encode_cseq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_cseq"].apply(null, arguments);
});
var _hs_sip326x_encode_display_name = Module["_hs_sip326x_encode_display_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_display_name"].apply(null, arguments);
});
var _hs_sip326x_encode_diversion = Module["_hs_sip326x_encode_diversion"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_diversion"].apply(null, arguments);
});
var _hs_sip326x_encode_esc_gen_params = Module["_hs_sip326x_encode_esc_gen_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_esc_gen_params"].apply(null, arguments);
});
var _hs_sip326x_encode_event = Module["_hs_sip326x_encode_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_event"].apply(null, arguments);
});
var _hs_sip326x_encode_gen_params = Module["_hs_sip326x_encode_gen_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_gen_params"].apply(null, arguments);
});
var _hs_sip326x_encode_generic = Module["_hs_sip326x_encode_generic"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_generic"].apply(null, arguments);
});
var _hs_sip326x_encode_geoloc = Module["_hs_sip326x_encode_geoloc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_geoloc"].apply(null, arguments);
});
var _hs_sip326x_encode_headersparam = Module["_hs_sip326x_encode_headersparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_headersparam"].apply(null, arguments);
});
var _hs_sip326x_encode_histinfo = Module["_hs_sip326x_encode_histinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_histinfo"].apply(null, arguments);
});
var _hs_sip326x_encode_histinfo_element = Module["_hs_sip326x_encode_histinfo_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_histinfo_element"].apply(null, arguments);
});
var _hs_sip326x_encode_host = Module["_hs_sip326x_encode_host"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_host"].apply(null, arguments);
});
var _hs_sip326x_encode_method = Module["_hs_sip326x_encode_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_method"].apply(null, arguments);
});
var _hs_sip326x_encode_min_se = Module["_hs_sip326x_encode_min_se"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_min_se"].apply(null, arguments);
});
var _hs_sip326x_encode_msg = Module["_hs_sip326x_encode_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_msg"].apply(null, arguments);
});
var _hs_sip326x_encode_msg_ex = Module["_hs_sip326x_encode_msg_ex"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_msg_ex"].apply(null, arguments);
});
var _hs_sip326x_encode_optiontag_hdr = Module["_hs_sip326x_encode_optiontag_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_optiontag_hdr"].apply(null, arguments);
});
var _hs_sip326x_encode_pearly_media = Module["_hs_sip326x_encode_pearly_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_pearly_media"].apply(null, arguments);
});
var _hs_sip326x_encode_pidentity = Module["_hs_sip326x_encode_pidentity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_pidentity"].apply(null, arguments);
});
var _hs_sip326x_encode_privacy = Module["_hs_sip326x_encode_privacy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_privacy"].apply(null, arguments);
});
var _hs_sip326x_encode_rack = Module["_hs_sip326x_encode_rack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_rack"].apply(null, arguments);
});
var _hs_sip326x_encode_reason = Module["_hs_sip326x_encode_reason"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_reason"].apply(null, arguments);
});
var _hs_sip326x_encode_reason_element = Module["_hs_sip326x_encode_reason_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_reason_element"].apply(null, arguments);
});
var _hs_sip326x_encode_replaces = Module["_hs_sip326x_encode_replaces"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_replaces"].apply(null, arguments);
});
var _hs_sip326x_encode_replacesparam = Module["_hs_sip326x_encode_replacesparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_replacesparam"].apply(null, arguments);
});
var _hs_sip326x_encode_req_start_line = Module["_hs_sip326x_encode_req_start_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_req_start_line"].apply(null, arguments);
});
var _hs_sip326x_encode_resp_start_line = Module["_hs_sip326x_encode_resp_start_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_resp_start_line"].apply(null, arguments);
});
var _hs_sip326x_encode_retryafter = Module["_hs_sip326x_encode_retryafter"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_retryafter"].apply(null, arguments);
});
var _hs_sip326x_encode_route = Module["_hs_sip326x_encode_route"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_route"].apply(null, arguments);
});
var _hs_sip326x_encode_sessionexpires = Module["_hs_sip326x_encode_sessionexpires"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_sessionexpires"].apply(null, arguments);
});
var _hs_sip326x_encode_sub_state = Module["_hs_sip326x_encode_sub_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_sub_state"].apply(null, arguments);
});
var _hs_sip326x_encode_teluri = Module["_hs_sip326x_encode_teluri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_teluri"].apply(null, arguments);
});
var _hs_sip326x_encode_teluri_otherparam_name = Module["_hs_sip326x_encode_teluri_otherparam_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_teluri_otherparam_name"].apply(null, arguments);
});
var _hs_sip326x_encode_transport_param = Module["_hs_sip326x_encode_transport_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_transport_param"].apply(null, arguments);
});
var _hs_sip326x_encode_ttl = Module["_hs_sip326x_encode_ttl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_ttl"].apply(null, arguments);
});
var _hs_sip326x_encode_uri = Module["_hs_sip326x_encode_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_uri"].apply(null, arguments);
});
var _hs_sip326x_encode_uri_otherparam = Module["_hs_sip326x_encode_uri_otherparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_uri_otherparam"].apply(null, arguments);
});
var _hs_sip326x_encode_user_param = Module["_hs_sip326x_encode_user_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_user_param"].apply(null, arguments);
});
var _hs_sip326x_encode_via = Module["_hs_sip326x_encode_via"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_via"].apply(null, arguments);
});
var _hs_sip326x_encode_via_element = Module["_hs_sip326x_encode_via_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_via_element"].apply(null, arguments);
});
var _hs_sip326x_encode_via_ext_params = Module["_hs_sip326x_encode_via_ext_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_encode_via_ext_params"].apply(null, arguments);
});
var _hs_sip326x_fill_accept_cont_toccm = Module["_hs_sip326x_fill_accept_cont_toccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_fill_accept_cont_toccm"].apply(null, arguments);
});
var _hs_sip326x_fill_host_from_nwadpt = Module["_hs_sip326x_fill_host_from_nwadpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_fill_host_from_nwadpt"].apply(null, arguments);
});
var _hs_sip326x_fill_identity_uri = Module["_hs_sip326x_fill_identity_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_fill_identity_uri"].apply(null, arguments);
});
var _hs_sip326x_fill_nwadpt_from_host = Module["_hs_sip326x_fill_nwadpt_from_host"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_fill_nwadpt_from_host"].apply(null, arguments);
});
var _hs_sip326x_fill_remote_nwk_from_host = Module["_hs_sip326x_fill_remote_nwk_from_host"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_fill_remote_nwk_from_host"].apply(null, arguments);
});
var _hs_sip326x_get_active_sockid = Module["_hs_sip326x_get_active_sockid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_active_sockid"].apply(null, arguments);
});
var _hs_sip326x_get_appln_callback = Module["_hs_sip326x_get_appln_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_appln_callback"].apply(null, arguments);
});
var _hs_sip326x_get_cert_enduser_addr = Module["_hs_sip326x_get_cert_enduser_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_cert_enduser_addr"].apply(null, arguments);
});
var _hs_sip326x_get_default_reason_phrase = Module["_hs_sip326x_get_default_reason_phrase"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_default_reason_phrase"].apply(null, arguments);
});
var _hs_sip326x_get_dns_addr_list = Module["_hs_sip326x_get_dns_addr_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_dns_addr_list"].apply(null, arguments);
});
var _hs_sip326x_get_dns_uri_list = Module["_hs_sip326x_get_dns_uri_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_dns_uri_list"].apply(null, arguments);
});
var _hs_sip326x_get_keepalive_nego = Module["_hs_sip326x_get_keepalive_nego"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_keepalive_nego"].apply(null, arguments);
});
var _hs_sip326x_get_secure_urischeme = Module["_hs_sip326x_get_secure_urischeme"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_secure_urischeme"].apply(null, arguments);
});
var _hs_sip326x_get_sip_method_str_from_enum = Module["_hs_sip326x_get_sip_method_str_from_enum"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_sip_method_str_from_enum"].apply(null, arguments);
});
var _hs_sip326x_get_siperror_phrase = Module["_hs_sip326x_get_siperror_phrase"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_get_siperror_phrase"].apply(null, arguments);
});
var _hs_sip326x_identify_module = Module["_hs_sip326x_identify_module"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_identify_module"].apply(null, arguments);
});
var _hs_sip326x_identify_module_bymsg = Module["_hs_sip326x_identify_module_bymsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_identify_module_bymsg"].apply(null, arguments);
});
var _hs_sip326x_if_msg_create = Module["_hs_sip326x_if_msg_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_if_msg_create"].apply(null, arguments);
});
var _hs_sip326x_if_msg_free = Module["_hs_sip326x_if_msg_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_if_msg_free"].apply(null, arguments);
});
var _hs_sip326x_is_outbound_support = Module["_hs_sip326x_is_outbound_support"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_is_outbound_support"].apply(null, arguments);
});
var _hs_sip326x_is_xport_switch = Module["_hs_sip326x_is_xport_switch"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_is_xport_switch"].apply(null, arguments);
});
var _hs_sip326x_kill_xaction_by_id = Module["_hs_sip326x_kill_xaction_by_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_kill_xaction_by_id"].apply(null, arguments);
});
var _hs_sip326x_log_critical_malloc_error = Module["_hs_sip326x_log_critical_malloc_error"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_log_critical_malloc_error"].apply(null, arguments);
});
var _hs_sip326x_log_msg_val = Module["_hs_sip326x_log_msg_val"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_log_msg_val"].apply(null, arguments);
});
var _hs_sip326x_map_reason = Module["_hs_sip326x_map_reason"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_map_reason"].apply(null, arguments);
});
var _hs_sip326x_match_gruu_by_if = Module["_hs_sip326x_match_gruu_by_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_match_gruu_by_if"].apply(null, arguments);
});
var _hs_sip326x_match_if = Module["_hs_sip326x_match_if"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_match_if"].apply(null, arguments);
});
var _hs_sip326x_match_reg_server = Module["_hs_sip326x_match_reg_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_match_reg_server"].apply(null, arguments);
});
var _hs_sip326x_match_via = Module["_hs_sip326x_match_via"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_match_via"].apply(null, arguments);
});
var _hs_sip326x_md5_get_resp = Module["_hs_sip326x_md5_get_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_md5_get_resp"].apply(null, arguments);
});
var _hs_sip326x_message_sip_decode = Module["_hs_sip326x_message_sip_decode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_message_sip_decode"].apply(null, arguments);
});
var _hs_sip326x_need_keepalive = Module["_hs_sip326x_need_keepalive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_need_keepalive"].apply(null, arguments);
});
var _hs_sip326x_nhm_create_binding = Module["_hs_sip326x_nhm_create_binding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_create_binding"].apply(null, arguments);
});
var _hs_sip326x_nhm_delete_binding = Module["_hs_sip326x_nhm_delete_binding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_delete_binding"].apply(null, arguments);
});
var _hs_sip326x_nhm_free_binding = Module["_hs_sip326x_nhm_free_binding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_free_binding"].apply(null, arguments);
});
var _hs_sip326x_nhm_get_binding_info = Module["_hs_sip326x_nhm_get_binding_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_get_binding_info"].apply(null, arguments);
});
var _hs_sip326x_nhm_get_nat_config_info = Module["_hs_sip326x_nhm_get_nat_config_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_get_nat_config_info"].apply(null, arguments);
});
var _hs_sip326x_nhm_get_nat_config_type = Module["_hs_sip326x_nhm_get_nat_config_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_get_nat_config_type"].apply(null, arguments);
});
var _hs_sip326x_nhm_get_nat_ref_interval = Module["_hs_sip326x_nhm_get_nat_ref_interval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_get_nat_ref_interval"].apply(null, arguments);
});
var _hs_sip326x_nhm_get_static_natip = Module["_hs_sip326x_nhm_get_static_natip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_get_static_natip"].apply(null, arguments);
});
var _hs_sip326x_nhm_get_static_natport = Module["_hs_sip326x_nhm_get_static_natport"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_get_static_natport"].apply(null, arguments);
});
var _hs_sip326x_nhm_init = Module["_hs_sip326x_nhm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_init"].apply(null, arguments);
});
var _hs_sip326x_nhm_outkeepalive = Module["_hs_sip326x_nhm_outkeepalive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_outkeepalive"].apply(null, arguments);
});
var _hs_sip326x_nhm_proc_incoming_msg = Module["_hs_sip326x_nhm_proc_incoming_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_proc_incoming_msg"].apply(null, arguments);
});
var _hs_sip326x_nhm_proc_outgoing_msg = Module["_hs_sip326x_nhm_proc_outgoing_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_proc_outgoing_msg"].apply(null, arguments);
});
var _hs_sip326x_nhm_proc_timer_msg = Module["_hs_sip326x_nhm_proc_timer_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_proc_timer_msg"].apply(null, arguments);
});
var _hs_sip326x_nhm_purge_binding = Module["_hs_sip326x_nhm_purge_binding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_purge_binding"].apply(null, arguments);
});
var _hs_sip326x_nhm_refresh_binding = Module["_hs_sip326x_nhm_refresh_binding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_refresh_binding"].apply(null, arguments);
});
var _hs_sip326x_nhm_reinit = Module["_hs_sip326x_nhm_reinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_reinit"].apply(null, arguments);
});
var _hs_sip326x_nhm_set_nat_config_info = Module["_hs_sip326x_nhm_set_nat_config_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_set_nat_config_info"].apply(null, arguments);
});
var _hs_sip326x_nhm_shutdown = Module["_hs_sip326x_nhm_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_shutdown"].apply(null, arguments);
});
var _hs_sip326x_nhm_start_refresh_timer = Module["_hs_sip326x_nhm_start_refresh_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_start_refresh_timer"].apply(null, arguments);
});
var _hs_sip326x_nhm_stop_maintaining_all_bindings = Module["_hs_sip326x_nhm_stop_maintaining_all_bindings"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_stop_maintaining_all_bindings"].apply(null, arguments);
});
var _hs_sip326x_nhm_stop_maintaining_binding = Module["_hs_sip326x_nhm_stop_maintaining_binding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_stop_maintaining_binding"].apply(null, arguments);
});
var _hs_sip326x_nhm_stop_maintaining_binding_by_src = Module["_hs_sip326x_nhm_stop_maintaining_binding_by_src"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_nhm_stop_maintaining_binding_by_src"].apply(null, arguments);
});
var _hs_sip326x_notify_reg_state_change = Module["_hs_sip326x_notify_reg_state_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_notify_reg_state_change"].apply(null, arguments);
});
var _hs_sip326x_notify_subscription_state_change = Module["_hs_sip326x_notify_subscription_state_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_notify_subscription_state_change"].apply(null, arguments);
});
var _hs_sip326x_order_resolved_address = Module["_hs_sip326x_order_resolved_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_order_resolved_address"].apply(null, arguments);
});
var _hs_sip326x_proc_registration_event = Module["_hs_sip326x_proc_registration_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_proc_registration_event"].apply(null, arguments);
});
var _hs_sip326x_register_appln_callback = Module["_hs_sip326x_register_appln_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_register_appln_callback"].apply(null, arguments);
});
var _hs_sip326x_release_if_msg = Module["_hs_sip326x_release_if_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_release_if_msg"].apply(null, arguments);
});
var _hs_sip326x_release_ua_nw_msg = Module["_hs_sip326x_release_ua_nw_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_release_ua_nw_msg"].apply(null, arguments);
});
var _hs_sip326x_reset_all_modules = Module["_hs_sip326x_reset_all_modules"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_reset_all_modules"].apply(null, arguments);
});
var _hs_sip326x_resolve_domain_2uri = Module["_hs_sip326x_resolve_domain_2uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_resolve_domain_2uri"].apply(null, arguments);
});
var _hs_sip326x_resolve_domain_name = Module["_hs_sip326x_resolve_domain_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_resolve_domain_name"].apply(null, arguments);
});
var _hs_sip326x_resolve_domain_to_addr = Module["_hs_sip326x_resolve_domain_to_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_resolve_domain_to_addr"].apply(null, arguments);
});
var _hs_sip326x_resolve_transport = Module["_hs_sip326x_resolve_transport"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_resolve_transport"].apply(null, arguments);
});
var _hs_sip326x_restart_tl_timers = Module["_hs_sip326x_restart_tl_timers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_restart_tl_timers"].apply(null, arguments);
});
var _hs_sip326x_se_check_genmand_hdrs = Module["_hs_sip326x_se_check_genmand_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_check_genmand_hdrs"].apply(null, arguments);
});
var _hs_sip326x_se_check_reqstmand_hdrs = Module["_hs_sip326x_se_check_reqstmand_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_check_reqstmand_hdrs"].apply(null, arguments);
});
var _hs_sip326x_se_check_respmand_hdrs = Module["_hs_sip326x_se_check_respmand_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_check_respmand_hdrs"].apply(null, arguments);
});
var _hs_sip326x_se_convert_to_ip = Module["_hs_sip326x_se_convert_to_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_convert_to_ip"].apply(null, arguments);
});
var _hs_sip326x_se_dec_accept_range = Module["_hs_sip326x_se_dec_accept_range"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_accept_range"].apply(null, arguments);
});
var _hs_sip326x_se_dec_ainfo = Module["_hs_sip326x_se_dec_ainfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_ainfo"].apply(null, arguments);
});
var _hs_sip326x_se_dec_analyzer = Module["_hs_sip326x_se_dec_analyzer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_analyzer"].apply(null, arguments);
});
var _hs_sip326x_se_dec_anlyz_fieldsupport = Module["_hs_sip326x_se_dec_anlyz_fieldsupport"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_anlyz_fieldsupport"].apply(null, arguments);
});
var _hs_sip326x_se_dec_authparam = Module["_hs_sip326x_se_dec_authparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_authparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_common = Module["_hs_sip326x_se_dec_common"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_common"].apply(null, arguments);
});
var _hs_sip326x_se_dec_contactparam = Module["_hs_sip326x_se_dec_contactparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_contactparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_contdisp = Module["_hs_sip326x_se_dec_contdisp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_contdisp"].apply(null, arguments);
});
var _hs_sip326x_se_dec_context = Module["_hs_sip326x_se_dec_context"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_context"].apply(null, arguments);
});
var _hs_sip326x_se_dec_delta_seconds = Module["_hs_sip326x_se_dec_delta_seconds"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_delta_seconds"].apply(null, arguments);
});
var _hs_sip326x_se_dec_duration = Module["_hs_sip326x_se_dec_duration"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_duration"].apply(null, arguments);
});
var _hs_sip326x_se_dec_encodings = Module["_hs_sip326x_se_dec_encodings"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_encodings"].apply(null, arguments);
});
var _hs_sip326x_se_dec_ext = Module["_hs_sip326x_se_dec_ext"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_ext"].apply(null, arguments);
});
var _hs_sip326x_se_dec_extension_token = Module["_hs_sip326x_se_dec_extension_token"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_extension_token"].apply(null, arguments);
});
var _hs_sip326x_se_dec_generic_param = Module["_hs_sip326x_se_dec_generic_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_generic_param"].apply(null, arguments);
});
var _hs_sip326x_se_dec_genericparam = Module["_hs_sip326x_se_dec_genericparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_genericparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_genericval = Module["_hs_sip326x_se_dec_genericval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_genericval"].apply(null, arguments);
});
var _hs_sip326x_se_dec_get_uri_schema = Module["_hs_sip326x_se_dec_get_uri_schema"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_get_uri_schema"].apply(null, arguments);
});
var _hs_sip326x_se_dec_getmethod = Module["_hs_sip326x_se_dec_getmethod"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_getmethod"].apply(null, arguments);
});
var _hs_sip326x_se_dec_geturilrparam = Module["_hs_sip326x_se_dec_geturilrparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_geturilrparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_geturitransparam = Module["_hs_sip326x_se_dec_geturitransparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_geturitransparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_geturiusrparam = Module["_hs_sip326x_se_dec_geturiusrparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_geturiusrparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_globalnumber = Module["_hs_sip326x_se_dec_globalnumber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_globalnumber"].apply(null, arguments);
});
var _hs_sip326x_se_dec_headerparam = Module["_hs_sip326x_se_dec_headerparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_headerparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_hex4 = Module["_hs_sip326x_se_dec_hex4"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_hex4"].apply(null, arguments);
});
var _hs_sip326x_se_dec_hostaddress = Module["_hs_sip326x_se_dec_hostaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_hostaddress"].apply(null, arguments);
});
var _hs_sip326x_se_dec_hostname = Module["_hs_sip326x_se_dec_hostname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_hostname"].apply(null, arguments);
});
var _hs_sip326x_se_dec_ipaddress = Module["_hs_sip326x_se_dec_ipaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_ipaddress"].apply(null, arguments);
});
var _hs_sip326x_se_dec_ipv4address = Module["_hs_sip326x_se_dec_ipv4address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_ipv4address"].apply(null, arguments);
});
var _hs_sip326x_se_dec_ipv6address = Module["_hs_sip326x_se_dec_ipv6address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_ipv6address"].apply(null, arguments);
});
var _hs_sip326x_se_dec_istoken = Module["_hs_sip326x_se_dec_istoken"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_istoken"].apply(null, arguments);
});
var _hs_sip326x_se_dec_language = Module["_hs_sip326x_se_dec_language"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_language"].apply(null, arguments);
});
var _hs_sip326x_se_dec_language_range = Module["_hs_sip326x_se_dec_language_range"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_language_range"].apply(null, arguments);
});
var _hs_sip326x_se_dec_localnumber = Module["_hs_sip326x_se_dec_localnumber"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_localnumber"].apply(null, arguments);
});
var _hs_sip326x_se_dec_lws = Module["_hs_sip326x_se_dec_lws"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_lws"].apply(null, arguments);
});
var _hs_sip326x_se_dec_m_parameter = Module["_hs_sip326x_se_dec_m_parameter"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_m_parameter"].apply(null, arguments);
});
var _hs_sip326x_se_dec_m_subtype = Module["_hs_sip326x_se_dec_m_subtype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_m_subtype"].apply(null, arguments);
});
var _hs_sip326x_se_dec_m_type = Module["_hs_sip326x_se_dec_m_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_m_type"].apply(null, arguments);
});
var _hs_sip326x_se_dec_media_range = Module["_hs_sip326x_se_dec_media_range"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_media_range"].apply(null, arguments);
});
var _hs_sip326x_se_dec_mediatype = Module["_hs_sip326x_se_dec_mediatype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_mediatype"].apply(null, arguments);
});
var _hs_sip326x_se_dec_message_qop = Module["_hs_sip326x_se_dec_message_qop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_message_qop"].apply(null, arguments);
});
var _hs_sip326x_se_dec_method = Module["_hs_sip326x_se_dec_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_method"].apply(null, arguments);
});
var _hs_sip326x_se_dec_mime_smime_body = Module["_hs_sip326x_se_dec_mime_smime_body"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_mime_smime_body"].apply(null, arguments);
});
var _hs_sip326x_se_dec_nc_value = Module["_hs_sip326x_se_dec_nc_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_nc_value"].apply(null, arguments);
});
var _hs_sip326x_se_dec_nonce_count = Module["_hs_sip326x_se_dec_nonce_count"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_nonce_count"].apply(null, arguments);
});
var _hs_sip326x_se_dec_optiontag = Module["_hs_sip326x_se_dec_optiontag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_optiontag"].apply(null, arguments);
});
var _hs_sip326x_se_dec_param = Module["_hs_sip326x_se_dec_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_param"].apply(null, arguments);
});
var _hs_sip326x_se_dec_port = Module["_hs_sip326x_se_dec_port"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_port"].apply(null, arguments);
});
var _hs_sip326x_se_dec_privacy_type = Module["_hs_sip326x_se_dec_privacy_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_privacy_type"].apply(null, arguments);
});
var _hs_sip326x_se_dec_qdtext = Module["_hs_sip326x_se_dec_qdtext"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_qdtext"].apply(null, arguments);
});
var _hs_sip326x_se_dec_quoted_string = Module["_hs_sip326x_se_dec_quoted_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_quoted_string"].apply(null, arguments);
});
var _hs_sip326x_se_dec_quoted_stringval = Module["_hs_sip326x_se_dec_quoted_stringval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_quoted_stringval"].apply(null, arguments);
});
var _hs_sip326x_se_dec_reasonparam = Module["_hs_sip326x_se_dec_reasonparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_reasonparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_replacesparam = Module["_hs_sip326x_se_dec_replacesparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_replacesparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_require = Module["_hs_sip326x_se_dec_require"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_require"].apply(null, arguments);
});
var _hs_sip326x_se_dec_response_auth = Module["_hs_sip326x_se_dec_response_auth"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_response_auth"].apply(null, arguments);
});
var _hs_sip326x_se_dec_sip_date = Module["_hs_sip326x_se_dec_sip_date"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_sip_date"].apply(null, arguments);
});
var _hs_sip326x_se_dec_sipversion = Module["_hs_sip326x_se_dec_sipversion"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_sipversion"].apply(null, arguments);
});
var _hs_sip326x_se_dec_subtag_primarytag = Module["_hs_sip326x_se_dec_subtag_primarytag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_subtag_primarytag"].apply(null, arguments);
});
var _hs_sip326x_se_dec_sws = Module["_hs_sip326x_se_dec_sws"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_sws"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf = Module["_hs_sip326x_se_dec_syntverf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_accept = Module["_hs_sip326x_se_dec_syntverf_accept"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_accept"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_acceptencoding = Module["_hs_sip326x_se_dec_syntverf_acceptencoding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_acceptencoding"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_acceptlang = Module["_hs_sip326x_se_dec_syntverf_acceptlang"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_acceptlang"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_alertinfo = Module["_hs_sip326x_se_dec_syntverf_alertinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_alertinfo"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_allow = Module["_hs_sip326x_se_dec_syntverf_allow"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_allow"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_auth = Module["_hs_sip326x_se_dec_syntverf_auth"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_auth"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_authinfo = Module["_hs_sip326x_se_dec_syntverf_authinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_authinfo"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_callid = Module["_hs_sip326x_se_dec_syntverf_callid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_callid"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_callinfo = Module["_hs_sip326x_se_dec_syntverf_callinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_callinfo"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_contact = Module["_hs_sip326x_se_dec_syntverf_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_contact"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_contdisp = Module["_hs_sip326x_se_dec_syntverf_contdisp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_contdisp"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_contenc = Module["_hs_sip326x_se_dec_syntverf_contenc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_contenc"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_contlang = Module["_hs_sip326x_se_dec_syntverf_contlang"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_contlang"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_contlen = Module["_hs_sip326x_se_dec_syntverf_contlen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_contlen"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_conttype = Module["_hs_sip326x_se_dec_syntverf_conttype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_conttype"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_cseq = Module["_hs_sip326x_se_dec_syntverf_cseq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_cseq"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_date = Module["_hs_sip326x_se_dec_syntverf_date"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_date"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_diversion = Module["_hs_sip326x_se_dec_syntverf_diversion"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_diversion"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_errorinfo = Module["_hs_sip326x_se_dec_syntverf_errorinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_errorinfo"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_event = Module["_hs_sip326x_se_dec_syntverf_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_event"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_expires = Module["_hs_sip326x_se_dec_syntverf_expires"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_expires"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_flowtimer = Module["_hs_sip326x_se_dec_syntverf_flowtimer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_flowtimer"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_from = Module["_hs_sip326x_se_dec_syntverf_from"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_from"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_generic = Module["_hs_sip326x_se_dec_syntverf_generic"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_generic"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_geolocerr = Module["_hs_sip326x_se_dec_syntverf_geolocerr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_geolocerr"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_histinfo = Module["_hs_sip326x_se_dec_syntverf_histinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_histinfo"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_identity = Module["_hs_sip326x_se_dec_syntverf_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_identity"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_join = Module["_hs_sip326x_se_dec_syntverf_join"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_join"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_maxfwd = Module["_hs_sip326x_se_dec_syntverf_maxfwd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_maxfwd"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_mimever = Module["_hs_sip326x_se_dec_syntverf_mimever"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_mimever"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_minexp = Module["_hs_sip326x_se_dec_syntverf_minexp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_minexp"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_minse = Module["_hs_sip326x_se_dec_syntverf_minse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_minse"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_passerted = Module["_hs_sip326x_se_dec_syntverf_passerted"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_passerted"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_passociated = Module["_hs_sip326x_se_dec_syntverf_passociated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_passociated"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_path = Module["_hs_sip326x_se_dec_syntverf_path"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_path"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_pcalled_party_id = Module["_hs_sip326x_se_dec_syntverf_pcalled_party_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_pcalled_party_id"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_pearly_media = Module["_hs_sip326x_se_dec_syntverf_pearly_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_pearly_media"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_ppreferred = Module["_hs_sip326x_se_dec_syntverf_ppreferred"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_ppreferred"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_privacy = Module["_hs_sip326x_se_dec_syntverf_privacy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_privacy"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_proxyauthen = Module["_hs_sip326x_se_dec_syntverf_proxyauthen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_proxyauthen"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_proxyauthrz = Module["_hs_sip326x_se_dec_syntverf_proxyauthrz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_proxyauthrz"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_pvisited_network_id = Module["_hs_sip326x_se_dec_syntverf_pvisited_network_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_pvisited_network_id"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_rack = Module["_hs_sip326x_se_dec_syntverf_rack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_rack"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_reason = Module["_hs_sip326x_se_dec_syntverf_reason"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_reason"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_recroute = Module["_hs_sip326x_se_dec_syntverf_recroute"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_recroute"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_referby = Module["_hs_sip326x_se_dec_syntverf_referby"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_referby"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_referto = Module["_hs_sip326x_se_dec_syntverf_referto"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_referto"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_replaces = Module["_hs_sip326x_se_dec_syntverf_replaces"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_replaces"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_require = Module["_hs_sip326x_se_dec_syntverf_require"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_require"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_retryafter = Module["_hs_sip326x_se_dec_syntverf_retryafter"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_retryafter"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_route = Module["_hs_sip326x_se_dec_syntverf_route"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_route"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_rseq = Module["_hs_sip326x_se_dec_syntverf_rseq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_rseq"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_serviceroute = Module["_hs_sip326x_se_dec_syntverf_serviceroute"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_serviceroute"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_session_expires = Module["_hs_sip326x_se_dec_syntverf_session_expires"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_session_expires"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_sip_etag = Module["_hs_sip326x_se_dec_syntverf_sip_etag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_sip_etag"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_string_hdrval = Module["_hs_sip326x_se_dec_syntverf_string_hdrval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_string_hdrval"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_subscription_state = Module["_hs_sip326x_se_dec_syntverf_subscription_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_subscription_state"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_support = Module["_hs_sip326x_se_dec_syntverf_support"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_support"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_to = Module["_hs_sip326x_se_dec_syntverf_to"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_to"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_unsupport = Module["_hs_sip326x_se_dec_syntverf_unsupport"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_unsupport"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_via = Module["_hs_sip326x_se_dec_syntverf_via"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_via"].apply(null, arguments);
});
var _hs_sip326x_se_dec_syntverf_wwwauth = Module["_hs_sip326x_se_dec_syntverf_wwwauth"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_syntverf_wwwauth"].apply(null, arguments);
});
var _hs_sip326x_se_dec_teluriotherparam = Module["_hs_sip326x_se_dec_teluriotherparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_teluriotherparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_teluriparam = Module["_hs_sip326x_se_dec_teluriparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_teluriparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_token = Module["_hs_sip326x_se_dec_token"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_token"].apply(null, arguments);
});
var _hs_sip326x_se_dec_tokenval = Module["_hs_sip326x_se_dec_tokenval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_tokenval"].apply(null, arguments);
});
var _hs_sip326x_se_dec_update_allowbitmap = Module["_hs_sip326x_se_dec_update_allowbitmap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_update_allowbitmap"].apply(null, arguments);
});
var _hs_sip326x_se_dec_uri = Module["_hs_sip326x_se_dec_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_uri"].apply(null, arguments);
});
var _hs_sip326x_se_dec_uric = Module["_hs_sip326x_se_dec_uric"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_uric"].apply(null, arguments);
});
var _hs_sip326x_se_dec_uriotherparam = Module["_hs_sip326x_se_dec_uriotherparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_uriotherparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_uriparam = Module["_hs_sip326x_se_dec_uriparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_uriparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_url_parse_headers = Module["_hs_sip326x_se_dec_url_parse_headers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_url_parse_headers"].apply(null, arguments);
});
var _hs_sip326x_se_dec_viaparam = Module["_hs_sip326x_se_dec_viaparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_viaparam"].apply(null, arguments);
});
var _hs_sip326x_se_dec_word = Module["_hs_sip326x_se_dec_word"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_dec_word"].apply(null, arguments);
});
var _hs_sip326x_se_decoder = Module["_hs_sip326x_se_decoder"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_decoder"].apply(null, arguments);
});
var _hs_sip326x_se_find_quote = Module["_hs_sip326x_se_find_quote"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_find_quote"].apply(null, arguments);
});
var _hs_sip326x_se_nextsep = Module["_hs_sip326x_se_nextsep"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_nextsep"].apply(null, arguments);
});
var _hs_sip326x_se_requrl_unescape = Module["_hs_sip326x_se_requrl_unescape"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_requrl_unescape"].apply(null, arguments);
});
var _hs_sip326x_se_skip_dquotes = Module["_hs_sip326x_se_skip_dquotes"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_skip_dquotes"].apply(null, arguments);
});
var _hs_sip326x_se_validate = Module["_hs_sip326x_se_validate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_validate"].apply(null, arguments);
});
var _hs_sip326x_se_validate_method = Module["_hs_sip326x_se_validate_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_validate_method"].apply(null, arguments);
});
var _hs_sip326x_se_validate_request = Module["_hs_sip326x_se_validate_request"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_se_validate_request"].apply(null, arguments);
});
var _hs_sip326x_select_redirect_sip_uri = Module["_hs_sip326x_select_redirect_sip_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_select_redirect_sip_uri"].apply(null, arguments);
});
var _hs_sip326x_set_session_alive = Module["_hs_sip326x_set_session_alive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_set_session_alive"].apply(null, arguments);
});
var _hs_sip326x_sigcomp_build_nack = Module["_hs_sip326x_sigcomp_build_nack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_sigcomp_build_nack"].apply(null, arguments);
});
var _hs_sip326x_sigcomp_compress = Module["_hs_sip326x_sigcomp_compress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_sigcomp_compress"].apply(null, arguments);
});
var _hs_sip326x_sigcomp_decompress = Module["_hs_sip326x_sigcomp_decompress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_sigcomp_decompress"].apply(null, arguments);
});
var _hs_sip326x_sigcomp_decompress_destroy = Module["_hs_sip326x_sigcomp_decompress_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_sigcomp_decompress_destroy"].apply(null, arguments);
});
var _hs_sip326x_sigcomp_init = Module["_hs_sip326x_sigcomp_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_sigcomp_init"].apply(null, arguments);
});
var _hs_sip326x_sigcomp_shutdown = Module["_hs_sip326x_sigcomp_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_sigcomp_shutdown"].apply(null, arguments);
});
var _hs_sip326x_stats_init = Module["_hs_sip326x_stats_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_stats_init"].apply(null, arguments);
});
var _hs_sip326x_stats_reset = Module["_hs_sip326x_stats_reset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_stats_reset"].apply(null, arguments);
});
var _hs_sip326x_stats_update_syserrors = Module["_hs_sip326x_stats_update_syserrors"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_stats_update_syserrors"].apply(null, arguments);
});
var _hs_sip326x_statsbyaor_add = Module["_hs_sip326x_statsbyaor_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_statsbyaor_add"].apply(null, arguments);
});
var _hs_sip326x_statsbyaor_del = Module["_hs_sip326x_statsbyaor_del"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_statsbyaor_del"].apply(null, arguments);
});
var _hs_sip326x_statsbyaor_log = Module["_hs_sip326x_statsbyaor_log"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_statsbyaor_log"].apply(null, arguments);
});
var _hs_sip326x_statsbyaor_update = Module["_hs_sip326x_statsbyaor_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_statsbyaor_update"].apply(null, arguments);
});
var _hs_sip326x_statsbyaor_update_by_sipmsg = Module["_hs_sip326x_statsbyaor_update_by_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_statsbyaor_update_by_sipmsg"].apply(null, arguments);
});
var _hs_sip326x_statsbyctxt_log = Module["_hs_sip326x_statsbyctxt_log"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_statsbyctxt_log"].apply(null, arguments);
});
var _hs_sip326x_timer_ict_refresh_value = Module["_hs_sip326x_timer_ict_refresh_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_timer_ict_refresh_value"].apply(null, arguments);
});
var _hs_sip326x_tl_add_via_branch = Module["_hs_sip326x_tl_add_via_branch"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_add_via_branch"].apply(null, arguments);
});
var _hs_sip326x_tl_build_msg = Module["_hs_sip326x_tl_build_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_build_msg"].apply(null, arguments);
});
var _hs_sip326x_tl_check_for_loop = Module["_hs_sip326x_tl_check_for_loop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_check_for_loop"].apply(null, arguments);
});
var _hs_sip326x_tl_create_ct = Module["_hs_sip326x_tl_create_ct"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_create_ct"].apply(null, arguments);
});
var _hs_sip326x_tl_create_ict = Module["_hs_sip326x_tl_create_ict"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_create_ict"].apply(null, arguments);
});
var _hs_sip326x_tl_create_ist = Module["_hs_sip326x_tl_create_ist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_create_ist"].apply(null, arguments);
});
var _hs_sip326x_tl_create_nict = Module["_hs_sip326x_tl_create_nict"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_create_nict"].apply(null, arguments);
});
var _hs_sip326x_tl_create_nist = Module["_hs_sip326x_tl_create_nist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_create_nist"].apply(null, arguments);
});
var _hs_sip326x_tl_create_st = Module["_hs_sip326x_tl_create_st"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_create_st"].apply(null, arguments);
});
var _hs_sip326x_tl_find_kill_xaction = Module["_hs_sip326x_tl_find_kill_xaction"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_find_kill_xaction"].apply(null, arguments);
});
var _hs_sip326x_tl_find_tx = Module["_hs_sip326x_tl_find_tx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_find_tx"].apply(null, arguments);
});
var _hs_sip326x_tl_find_tx_for_txid = Module["_hs_sip326x_tl_find_tx_for_txid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_find_tx_for_txid"].apply(null, arguments);
});
var _hs_sip326x_tl_free_xaction = Module["_hs_sip326x_tl_free_xaction"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_free_xaction"].apply(null, arguments);
});
var _hs_sip326x_tl_get_invite_msg = Module["_hs_sip326x_tl_get_invite_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_get_invite_msg"].apply(null, arguments);
});
var _hs_sip326x_tl_handle_conn_status_change = Module["_hs_sip326x_tl_handle_conn_status_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_handle_conn_status_change"].apply(null, arguments);
});
var _hs_sip326x_tl_ict_restart = Module["_hs_sip326x_tl_ict_restart"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_ict_restart"].apply(null, arguments);
});
var _hs_sip326x_tl_ict_timer = Module["_hs_sip326x_tl_ict_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_ict_timer"].apply(null, arguments);
});
var _hs_sip326x_tl_ict_tpah = Module["_hs_sip326x_tl_ict_tpah"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_ict_tpah"].apply(null, arguments);
});
var _hs_sip326x_tl_ict_tu = Module["_hs_sip326x_tl_ict_tu"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_ict_tu"].apply(null, arguments);
});
var _hs_sip326x_tl_init = Module["_hs_sip326x_tl_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_init"].apply(null, arguments);
});
var _hs_sip326x_tl_ist_timer = Module["_hs_sip326x_tl_ist_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_ist_timer"].apply(null, arguments);
});
var _hs_sip326x_tl_ist_tpah = Module["_hs_sip326x_tl_ist_tpah"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_ist_tpah"].apply(null, arguments);
});
var _hs_sip326x_tl_ist_tu = Module["_hs_sip326x_tl_ist_tu"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_ist_tu"].apply(null, arguments);
});
var _hs_sip326x_tl_kill_xaction = Module["_hs_sip326x_tl_kill_xaction"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_kill_xaction"].apply(null, arguments);
});
var _hs_sip326x_tl_match_xaction_2543ua = Module["_hs_sip326x_tl_match_xaction_2543ua"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_match_xaction_2543ua"].apply(null, arguments);
});
var _hs_sip326x_tl_nict_restart = Module["_hs_sip326x_tl_nict_restart"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_nict_restart"].apply(null, arguments);
});
var _hs_sip326x_tl_nict_timer = Module["_hs_sip326x_tl_nict_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_nict_timer"].apply(null, arguments);
});
var _hs_sip326x_tl_nict_tpah = Module["_hs_sip326x_tl_nict_tpah"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_nict_tpah"].apply(null, arguments);
});
var _hs_sip326x_tl_nict_tu = Module["_hs_sip326x_tl_nict_tu"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_nict_tu"].apply(null, arguments);
});
var _hs_sip326x_tl_nist_timer = Module["_hs_sip326x_tl_nist_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_nist_timer"].apply(null, arguments);
});
var _hs_sip326x_tl_nist_tpah = Module["_hs_sip326x_tl_nist_tpah"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_nist_tpah"].apply(null, arguments);
});
var _hs_sip326x_tl_nist_tu = Module["_hs_sip326x_tl_nist_tu"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_nist_tu"].apply(null, arguments);
});
var _hs_sip326x_tl_proc_timer_msg = Module["_hs_sip326x_tl_proc_timer_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_proc_timer_msg"].apply(null, arguments);
});
var _hs_sip326x_tl_proc_tp_errors = Module["_hs_sip326x_tl_proc_tp_errors"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_proc_tp_errors"].apply(null, arguments);
});
var _hs_sip326x_tl_proc_tpah_msg = Module["_hs_sip326x_tl_proc_tpah_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_proc_tpah_msg"].apply(null, arguments);
});
var _hs_sip326x_tl_proc_tu_msg = Module["_hs_sip326x_tl_proc_tu_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_proc_tu_msg"].apply(null, arguments);
});
var _hs_sip326x_tl_reinit = Module["_hs_sip326x_tl_reinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_reinit"].apply(null, arguments);
});
var _hs_sip326x_tl_retx_nict_req = Module["_hs_sip326x_tl_retx_nict_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_retx_nict_req"].apply(null, arguments);
});
var _hs_sip326x_tl_search_ct = Module["_hs_sip326x_tl_search_ct"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_search_ct"].apply(null, arguments);
});
var _hs_sip326x_tl_search_st = Module["_hs_sip326x_tl_search_st"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_search_st"].apply(null, arguments);
});
var _hs_sip326x_tl_stop = Module["_hs_sip326x_tl_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_stop"].apply(null, arguments);
});
var _hs_sip326x_tl_update_pend_invite_timers = Module["_hs_sip326x_tl_update_pend_invite_timers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_update_pend_invite_timers"].apply(null, arguments);
});
var _hs_sip326x_tl_validate_resp_against_req = Module["_hs_sip326x_tl_validate_resp_against_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tl_validate_resp_against_req"].apply(null, arguments);
});
var _hs_sip326x_tpah_add_alias = Module["_hs_sip326x_tpah_add_alias"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_add_alias"].apply(null, arguments);
});
var _hs_sip326x_tpah_add_conn_node = Module["_hs_sip326x_tpah_add_conn_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_add_conn_node"].apply(null, arguments);
});
var _hs_sip326x_tpah_add_maddr_node = Module["_hs_sip326x_tpah_add_maddr_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_add_maddr_node"].apply(null, arguments);
});
var _hs_sip326x_tpah_addto_multicast = Module["_hs_sip326x_tpah_addto_multicast"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_addto_multicast"].apply(null, arguments);
});
var _hs_sip326x_tpah_alloc_conn_node = Module["_hs_sip326x_tpah_alloc_conn_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_alloc_conn_node"].apply(null, arguments);
});
var _hs_sip326x_tpah_check_conn_send_msg = Module["_hs_sip326x_tpah_check_conn_send_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_check_conn_send_msg"].apply(null, arguments);
});
var _hs_sip326x_tpah_dtm_calback = Module["_hs_sip326x_tpah_dtm_calback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_dtm_calback"].apply(null, arguments);
});
var _hs_sip326x_tpah_fill_ipv4addr = Module["_hs_sip326x_tpah_fill_ipv4addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_fill_ipv4addr"].apply(null, arguments);
});
var _hs_sip326x_tpah_fill_received_via_param = Module["_hs_sip326x_tpah_fill_received_via_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_fill_received_via_param"].apply(null, arguments);
});
var _hs_sip326x_tpah_find_conn = Module["_hs_sip326x_tpah_find_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_find_conn"].apply(null, arguments);
});
var _hs_sip326x_tpah_get_alternative_dest = Module["_hs_sip326x_tpah_get_alternative_dest"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_get_alternative_dest"].apply(null, arguments);
});
var _hs_sip326x_tpah_handle_conn_status_change = Module["_hs_sip326x_tpah_handle_conn_status_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_handle_conn_status_change"].apply(null, arguments);
});
var _hs_sip326x_tpah_handle_incoming_conn = Module["_hs_sip326x_tpah_handle_incoming_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_handle_incoming_conn"].apply(null, arguments);
});
var _hs_sip326x_tpah_handle_nw_msg = Module["_hs_sip326x_tpah_handle_nw_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_handle_nw_msg"].apply(null, arguments);
});
var _hs_sip326x_tpah_init = Module["_hs_sip326x_tpah_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_init"].apply(null, arguments);
});
var _hs_sip326x_tpah_initiate_tcp_conn = Module["_hs_sip326x_tpah_initiate_tcp_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_initiate_tcp_conn"].apply(null, arguments);
});
var _hs_sip326x_tpah_proc_recvd_msg = Module["_hs_sip326x_tpah_proc_recvd_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_proc_recvd_msg"].apply(null, arguments);
});
var _hs_sip326x_tpah_process_timeout = Module["_hs_sip326x_tpah_process_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_process_timeout"].apply(null, arguments);
});
var _hs_sip326x_tpah_raw_send_on_udp = Module["_hs_sip326x_tpah_raw_send_on_udp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_raw_send_on_udp"].apply(null, arguments);
});
var _hs_sip326x_tpah_reinit = Module["_hs_sip326x_tpah_reinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_reinit"].apply(null, arguments);
});
var _hs_sip326x_tpah_release_conn = Module["_hs_sip326x_tpah_release_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_release_conn"].apply(null, arguments);
});
var _hs_sip326x_tpah_release_maddr = Module["_hs_sip326x_tpah_release_maddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_release_maddr"].apply(null, arguments);
});
var _hs_sip326x_tpah_remove_conn_node = Module["_hs_sip326x_tpah_remove_conn_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_remove_conn_node"].apply(null, arguments);
});
var _hs_sip326x_tpah_removefrom_multicast = Module["_hs_sip326x_tpah_removefrom_multicast"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_removefrom_multicast"].apply(null, arguments);
});
var _hs_sip326x_tpah_reset_conn_timer = Module["_hs_sip326x_tpah_reset_conn_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_reset_conn_timer"].apply(null, arguments);
});
var _hs_sip326x_tpah_resetall_src_conn = Module["_hs_sip326x_tpah_resetall_src_conn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_resetall_src_conn"].apply(null, arguments);
});
var _hs_sip326x_tpah_resolve_and_send_on_tcp = Module["_hs_sip326x_tpah_resolve_and_send_on_tcp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_resolve_and_send_on_tcp"].apply(null, arguments);
});
var _hs_sip326x_tpah_retry_inform_sip = Module["_hs_sip326x_tpah_retry_inform_sip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_retry_inform_sip"].apply(null, arguments);
});
var _hs_sip326x_tpah_send_on_tcp = Module["_hs_sip326x_tpah_send_on_tcp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_send_on_tcp"].apply(null, arguments);
});
var _hs_sip326x_tpah_send_on_udp = Module["_hs_sip326x_tpah_send_on_udp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_send_on_udp"].apply(null, arguments);
});
var _hs_sip326x_tpah_send_req = Module["_hs_sip326x_tpah_send_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_send_req"].apply(null, arguments);
});
var _hs_sip326x_tpah_send_resp = Module["_hs_sip326x_tpah_send_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_send_resp"].apply(null, arguments);
});
var _hs_sip326x_tpah_send_resp_on_tcp = Module["_hs_sip326x_tpah_send_resp_on_tcp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_send_resp_on_tcp"].apply(null, arguments);
});
var _hs_sip326x_tpah_send_resp_on_udp = Module["_hs_sip326x_tpah_send_resp_on_udp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_send_resp_on_udp"].apply(null, arguments);
});
var _hs_sip326x_tpah_server_validation = Module["_hs_sip326x_tpah_server_validation"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_server_validation"].apply(null, arguments);
});
var _hs_sip326x_tpah_shutdown = Module["_hs_sip326x_tpah_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_shutdown"].apply(null, arguments);
});
var _hs_sip326x_tpah_socket_init_bind = Module["_hs_sip326x_tpah_socket_init_bind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_socket_init_bind"].apply(null, arguments);
});
var _hs_sip326x_tpah_socket_shutdown = Module["_hs_sip326x_tpah_socket_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_socket_shutdown"].apply(null, arguments);
});
var _hs_sip326x_tpah_start = Module["_hs_sip326x_tpah_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_start"].apply(null, arguments);
});
var _hs_sip326x_tpah_stop = Module["_hs_sip326x_tpah_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_stop"].apply(null, arguments);
});
var _hs_sip326x_tpah_update_conn_info = Module["_hs_sip326x_tpah_update_conn_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tpah_update_conn_info"].apply(null, arguments);
});
var _hs_sip326x_tu_add_dialog_watcher_for_new_dialog = Module["_hs_sip326x_tu_add_dialog_watcher_for_new_dialog"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_add_dialog_watcher_for_new_dialog"].apply(null, arguments);
});
var _hs_sip326x_tu_add_regflow_entry = Module["_hs_sip326x_tu_add_regflow_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_add_regflow_entry"].apply(null, arguments);
});
var _hs_sip326x_tu_add_service_route_set = Module["_hs_sip326x_tu_add_service_route_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_add_service_route_set"].apply(null, arguments);
});
var _hs_sip326x_tu_add_watcher_for_dialog_event = Module["_hs_sip326x_tu_add_watcher_for_dialog_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_add_watcher_for_dialog_event"].apply(null, arguments);
});
var _hs_sip326x_tu_authn_req = Module["_hs_sip326x_tu_authn_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_authn_req"].apply(null, arguments);
});
var _hs_sip326x_tu_bld_sess_timer_hdrs_in_dlg_est_resp = Module["_hs_sip326x_tu_bld_sess_timer_hdrs_in_dlg_est_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_bld_sess_timer_hdrs_in_dlg_est_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_build_cancel = Module["_hs_sip326x_tu_build_cancel"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_cancel"].apply(null, arguments);
});
var _hs_sip326x_tu_build_contact_identity_list = Module["_hs_sip326x_tu_build_contact_identity_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_contact_identity_list"].apply(null, arguments);
});
var _hs_sip326x_tu_build_dialog_element = Module["_hs_sip326x_tu_build_dialog_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_dialog_element"].apply(null, arguments);
});
var _hs_sip326x_tu_build_dialog_xml_msg = Module["_hs_sip326x_tu_build_dialog_xml_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_dialog_xml_msg"].apply(null, arguments);
});
var _hs_sip326x_tu_build_diversion_hdr = Module["_hs_sip326x_tu_build_diversion_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_diversion_hdr"].apply(null, arguments);
});
var _hs_sip326x_tu_build_hdr_pidentity = Module["_hs_sip326x_tu_build_hdr_pidentity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_hdr_pidentity"].apply(null, arguments);
});
var _hs_sip326x_tu_build_local_contact = Module["_hs_sip326x_tu_build_local_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_local_contact"].apply(null, arguments);
});
var _hs_sip326x_tu_build_local_via = Module["_hs_sip326x_tu_build_local_via"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_local_via"].apply(null, arguments);
});
var _hs_sip326x_tu_build_mid_session_req = Module["_hs_sip326x_tu_build_mid_session_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_mid_session_req"].apply(null, arguments);
});
var _hs_sip326x_tu_build_reg_authrz_credentials = Module["_hs_sip326x_tu_build_reg_authrz_credentials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_reg_authrz_credentials"].apply(null, arguments);
});
var _hs_sip326x_tu_build_reg_contact_list = Module["_hs_sip326x_tu_build_reg_contact_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_reg_contact_list"].apply(null, arguments);
});
var _hs_sip326x_tu_build_reg_event_subscribe = Module["_hs_sip326x_tu_build_reg_event_subscribe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_reg_event_subscribe"].apply(null, arguments);
});
var _hs_sip326x_tu_build_resp = Module["_hs_sip326x_tu_build_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_build_session_timer_hdrs_in_req = Module["_hs_sip326x_tu_build_session_timer_hdrs_in_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_session_timer_hdrs_in_req"].apply(null, arguments);
});
var _hs_sip326x_tu_build_session_timer_hdrs_in_update_resp = Module["_hs_sip326x_tu_build_session_timer_hdrs_in_update_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_session_timer_hdrs_in_update_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_build_sip_reg_req = Module["_hs_sip326x_tu_build_sip_reg_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_sip_reg_req"].apply(null, arguments);
});
var _hs_sip326x_tu_build_sip_req_out_of_dlg = Module["_hs_sip326x_tu_build_sip_req_out_of_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_sip_req_out_of_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_build_tel_uri = Module["_hs_sip326x_tu_build_tel_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_build_tel_uri"].apply(null, arguments);
});
var _hs_sip326x_tu_check_dialog_watchers = Module["_hs_sip326x_tu_check_dialog_watchers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_check_dialog_watchers"].apply(null, arguments);
});
var _hs_sip326x_tu_check_release_dlg = Module["_hs_sip326x_tu_check_release_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_check_release_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_conv_tel2sip_uri = Module["_hs_sip326x_tu_conv_tel2sip_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_conv_tel2sip_uri"].apply(null, arguments);
});
var _hs_sip326x_tu_copy_active_server = Module["_hs_sip326x_tu_copy_active_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_copy_active_server"].apply(null, arguments);
});
var _hs_sip326x_tu_copy_contact_from_dlg = Module["_hs_sip326x_tu_copy_contact_from_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_copy_contact_from_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_copy_replaces_uritodlg = Module["_hs_sip326x_tu_copy_replaces_uritodlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_copy_replaces_uritodlg"].apply(null, arguments);
});
var _hs_sip326x_tu_count_forked_dlgs = Module["_hs_sip326x_tu_count_forked_dlgs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_count_forked_dlgs"].apply(null, arguments);
});
var _hs_sip326x_tu_create_dlg = Module["_hs_sip326x_tu_create_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_create_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_create_forked_dlg = Module["_hs_sip326x_tu_create_forked_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_create_forked_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_create_geoloc_hdr_from_mime = Module["_hs_sip326x_tu_create_geoloc_hdr_from_mime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_create_geoloc_hdr_from_mime"].apply(null, arguments);
});
var _hs_sip326x_tu_dereg_oldbinding = Module["_hs_sip326x_tu_dereg_oldbinding"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dereg_oldbinding"].apply(null, arguments);
});
var _hs_sip326x_tu_dialog_init = Module["_hs_sip326x_tu_dialog_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dialog_init"].apply(null, arguments);
});
var _hs_sip326x_tu_dialog_reinit = Module["_hs_sip326x_tu_dialog_reinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dialog_reinit"].apply(null, arguments);
});
var _hs_sip326x_tu_dialog_shutdown = Module["_hs_sip326x_tu_dialog_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dialog_shutdown"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_change_state = Module["_hs_sip326x_tu_dlg_change_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_change_state"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_ct_add = Module["_hs_sip326x_tu_dlg_ct_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_ct_add"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_ct_remove = Module["_hs_sip326x_tu_dlg_ct_remove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_ct_remove"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_find_ct_sip_cseq = Module["_hs_sip326x_tu_dlg_find_ct_sip_cseq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_find_ct_sip_cseq"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_find_ct_sip_method = Module["_hs_sip326x_tu_dlg_find_ct_sip_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_find_ct_sip_method"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_find_ct_xaction_id = Module["_hs_sip326x_tu_dlg_find_ct_xaction_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_find_ct_xaction_id"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_find_st_sip_cseq_no = Module["_hs_sip326x_tu_dlg_find_st_sip_cseq_no"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_find_st_sip_cseq_no"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_find_st_sip_method = Module["_hs_sip326x_tu_dlg_find_st_sip_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_find_st_sip_method"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_save_18x_content = Module["_hs_sip326x_tu_dlg_save_18x_content"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_save_18x_content"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_set_method = Module["_hs_sip326x_tu_dlg_set_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_set_method"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_st_add = Module["_hs_sip326x_tu_dlg_st_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_st_add"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_st_remove = Module["_hs_sip326x_tu_dlg_st_remove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_st_remove"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_store_destaddr = Module["_hs_sip326x_tu_dlg_store_destaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_store_destaddr"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_update_local_uri_scheme = Module["_hs_sip326x_tu_dlg_update_local_uri_scheme"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_update_local_uri_scheme"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_update_local_xport = Module["_hs_sip326x_tu_dlg_update_local_xport"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_update_local_xport"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_update_localaddr = Module["_hs_sip326x_tu_dlg_update_localaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_update_localaddr"].apply(null, arguments);
});
var _hs_sip326x_tu_dlg_update_localuri = Module["_hs_sip326x_tu_dlg_update_localuri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_dlg_update_localuri"].apply(null, arguments);
});
var _hs_sip326x_tu_extract_gruu = Module["_hs_sip326x_tu_extract_gruu"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_extract_gruu"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_ccm_diversion_list = Module["_hs_sip326x_tu_fill_ccm_diversion_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_ccm_diversion_list"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_ccm_pearly_hdrs = Module["_hs_sip326x_tu_fill_ccm_pearly_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_ccm_pearly_hdrs"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_commonhdrs_from_ccm = Module["_hs_sip326x_tu_fill_commonhdrs_from_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_commonhdrs_from_ccm"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_contact_capabilities_from_ccm = Module["_hs_sip326x_tu_fill_contact_capabilities_from_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_contact_capabilities_from_ccm"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_contact_capabilities_to_ccm = Module["_hs_sip326x_tu_fill_contact_capabilities_to_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_contact_capabilities_to_ccm"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_exthdrs = Module["_hs_sip326x_tu_fill_exthdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_exthdrs"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_geoloc_hdr = Module["_hs_sip326x_tu_fill_geoloc_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_geoloc_hdr"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_identity = Module["_hs_sip326x_tu_fill_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_identity"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_nonce_count = Module["_hs_sip326x_tu_fill_nonce_count"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_nonce_count"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_passerted = Module["_hs_sip326x_tu_fill_passerted"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_passerted"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_replaces_uriheader = Module["_hs_sip326x_tu_fill_replaces_uriheader"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_replaces_uriheader"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_req_optiontag_from_ccm = Module["_hs_sip326x_tu_fill_req_optiontag_from_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_req_optiontag_from_ccm"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_secureparams_from_ccm = Module["_hs_sip326x_tu_fill_secureparams_from_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_secureparams_from_ccm"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_sip_capabilities = Module["_hs_sip326x_tu_fill_sip_capabilities"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_sip_capabilities"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_sip_diversion_list = Module["_hs_sip326x_tu_fill_sip_diversion_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_sip_diversion_list"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_sip_pearly_hdrs = Module["_hs_sip326x_tu_fill_sip_pearly_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_sip_pearly_hdrs"].apply(null, arguments);
});
var _hs_sip326x_tu_fill_uri = Module["_hs_sip326x_tu_fill_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_fill_uri"].apply(null, arguments);
});
var _hs_sip326x_tu_forked_dlg_absorb_2xx = Module["_hs_sip326x_tu_forked_dlg_absorb_2xx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_forked_dlg_absorb_2xx"].apply(null, arguments);
});
var _hs_sip326x_tu_forked_dlg_handle_1xx = Module["_hs_sip326x_tu_forked_dlg_handle_1xx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_forked_dlg_handle_1xx"].apply(null, arguments);
});
var _hs_sip326x_tu_free_dlg = Module["_hs_sip326x_tu_free_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_free_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_free_reg = Module["_hs_sip326x_tu_free_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_free_reg"].apply(null, arguments);
});
var _hs_sip326x_tu_free_regtable_entry = Module["_hs_sip326x_tu_free_regtable_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_free_regtable_entry"].apply(null, arguments);
});
var _hs_sip326x_tu_generate_and_send_bye = Module["_hs_sip326x_tu_generate_and_send_bye"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_generate_and_send_bye"].apply(null, arguments);
});
var _hs_sip326x_tu_generate_cseq = Module["_hs_sip326x_tu_generate_cseq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_generate_cseq"].apply(null, arguments);
});
var _hs_sip326x_tu_generate_nonce = Module["_hs_sip326x_tu_generate_nonce"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_generate_nonce"].apply(null, arguments);
});
var _hs_sip326x_tu_generate_tag = Module["_hs_sip326x_tu_generate_tag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_generate_tag"].apply(null, arguments);
});
var _hs_sip326x_tu_get_active_flow = Module["_hs_sip326x_tu_get_active_flow"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_active_flow"].apply(null, arguments);
});
var _hs_sip326x_tu_get_active_server = Module["_hs_sip326x_tu_get_active_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_active_server"].apply(null, arguments);
});
var _hs_sip326x_tu_get_aor_by_dlg_token = Module["_hs_sip326x_tu_get_aor_by_dlg_token"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_aor_by_dlg_token"].apply(null, arguments);
});
var _hs_sip326x_tu_get_aor_by_sipmsg = Module["_hs_sip326x_tu_get_aor_by_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_aor_by_sipmsg"].apply(null, arguments);
});
var _hs_sip326x_tu_get_aor_by_token = Module["_hs_sip326x_tu_get_aor_by_token"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_aor_by_token"].apply(null, arguments);
});
var _hs_sip326x_tu_get_dialog_by_sipmsg = Module["_hs_sip326x_tu_get_dialog_by_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_dialog_by_sipmsg"].apply(null, arguments);
});
var _hs_sip326x_tu_get_expires_for_user = Module["_hs_sip326x_tu_get_expires_for_user"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_expires_for_user"].apply(null, arguments);
});
var _hs_sip326x_tu_get_failoverserver = Module["_hs_sip326x_tu_get_failoverserver"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_failoverserver"].apply(null, arguments);
});
var _hs_sip326x_tu_get_min_contact_duration = Module["_hs_sip326x_tu_get_min_contact_duration"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_min_contact_duration"].apply(null, arguments);
});
var _hs_sip326x_tu_get_prebuilt_route_set = Module["_hs_sip326x_tu_get_prebuilt_route_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_prebuilt_route_set"].apply(null, arguments);
});
var _hs_sip326x_tu_get_regflow_entry = Module["_hs_sip326x_tu_get_regflow_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_regflow_entry"].apply(null, arguments);
});
var _hs_sip326x_tu_get_regtable_entry = Module["_hs_sip326x_tu_get_regtable_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_regtable_entry"].apply(null, arguments);
});
var _hs_sip326x_tu_get_remote_target_uri = Module["_hs_sip326x_tu_get_remote_target_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_remote_target_uri"].apply(null, arguments);
});
var _hs_sip326x_tu_get_response_digest = Module["_hs_sip326x_tu_get_response_digest"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_get_response_digest"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_async_ct_failure = Module["_hs_sip326x_tu_handle_async_ct_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_async_ct_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_async_st_failure = Module["_hs_sip326x_tu_handle_async_st_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_async_st_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_conn_status_change = Module["_hs_sip326x_tu_handle_conn_status_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_conn_status_change"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_create_ct_failure = Module["_hs_sip326x_tu_handle_create_ct_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_create_ct_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_create_ct_failure_for_reg = Module["_hs_sip326x_tu_handle_create_ct_failure_for_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_create_ct_failure_for_reg"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_create_st_failure = Module["_hs_sip326x_tu_handle_create_st_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_create_st_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_nonreg_failover = Module["_hs_sip326x_tu_handle_nonreg_failover"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_nonreg_failover"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_ping_timeout = Module["_hs_sip326x_tu_handle_ping_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_ping_timeout"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_reg_failover = Module["_hs_sip326x_tu_handle_reg_failover"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_reg_failover"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_sipreq_privacy = Module["_hs_sip326x_tu_handle_sipreq_privacy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_sipreq_privacy"].apply(null, arguments);
});
var _hs_sip326x_tu_handle_st_resp_failure = Module["_hs_sip326x_tu_handle_st_resp_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_handle_st_resp_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_identify_req_dest = Module["_hs_sip326x_tu_identify_req_dest"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_identify_req_dest"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_ccm = Module["_hs_sip326x_tu_inform_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_ccm"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_ccm_reg_resp = Module["_hs_sip326x_tu_inform_ccm_reg_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_ccm_reg_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_ccm_req_failure = Module["_hs_sip326x_tu_inform_ccm_req_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_ccm_req_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_ccm_stop_notify = Module["_hs_sip326x_tu_inform_ccm_stop_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_ccm_stop_notify"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_ccm_subscribe = Module["_hs_sip326x_tu_inform_ccm_subscribe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_ccm_subscribe"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_exthdr = Module["_hs_sip326x_tu_inform_exthdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_exthdr"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_reg_req_failure = Module["_hs_sip326x_tu_inform_reg_req_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_reg_req_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_inform_supported = Module["_hs_sip326x_tu_inform_supported"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_inform_supported"].apply(null, arguments);
});
var _hs_sip326x_tu_init = Module["_hs_sip326x_tu_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_init"].apply(null, arguments);
});
var _hs_sip326x_tu_map_reason_to_resp_code = Module["_hs_sip326x_tu_map_reason_to_resp_code"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_map_reason_to_resp_code"].apply(null, arguments);
});
var _hs_sip326x_tu_map_resp_to_reason_code = Module["_hs_sip326x_tu_map_resp_to_reason_code"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_map_resp_to_reason_code"].apply(null, arguments);
});
var _hs_sip326x_tu_match_ccm_sip_call_id = Module["_hs_sip326x_tu_match_ccm_sip_call_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_ccm_sip_call_id"].apply(null, arguments);
});
var _hs_sip326x_tu_match_dialog = Module["_hs_sip326x_tu_match_dialog"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_dialog"].apply(null, arguments);
});
var _hs_sip326x_tu_match_dialog_for_forking = Module["_hs_sip326x_tu_match_dialog_for_forking"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_dialog_for_forking"].apply(null, arguments);
});
var _hs_sip326x_tu_match_dlg_token = Module["_hs_sip326x_tu_match_dlg_token"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_dlg_token"].apply(null, arguments);
});
var _hs_sip326x_tu_match_reg_callid = Module["_hs_sip326x_tu_match_reg_callid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_reg_callid"].apply(null, arguments);
});
var _hs_sip326x_tu_match_reg_dialog = Module["_hs_sip326x_tu_match_reg_dialog"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_reg_dialog"].apply(null, arguments);
});
var _hs_sip326x_tu_match_reg_token = Module["_hs_sip326x_tu_match_reg_token"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_reg_token"].apply(null, arguments);
});
var _hs_sip326x_tu_match_registered_aor = Module["_hs_sip326x_tu_match_registered_aor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_registered_aor"].apply(null, arguments);
});
var _hs_sip326x_tu_match_replaces_dialog = Module["_hs_sip326x_tu_match_replaces_dialog"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_match_replaces_dialog"].apply(null, arguments);
});
var _hs_sip326x_tu_notify_reg_event = Module["_hs_sip326x_tu_notify_reg_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_notify_reg_event"].apply(null, arguments);
});
var _hs_sip326x_tu_post_internal_reg = Module["_hs_sip326x_tu_post_internal_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_post_internal_reg"].apply(null, arguments);
});
var _hs_sip326x_tu_post_reg_failure = Module["_hs_sip326x_tu_post_reg_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_post_reg_failure"].apply(null, arguments);
});
var _hs_sip326x_tu_post_tcp_regfailure = Module["_hs_sip326x_tu_post_tcp_regfailure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_post_tcp_regfailure"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_1xx = Module["_hs_sip326x_tu_proc_1xx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_1xx"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_2xx = Module["_hs_sip326x_tu_proc_2xx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_2xx"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_auth_resp = Module["_hs_sip326x_tu_proc_auth_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_auth_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_authinfo = Module["_hs_sip326x_tu_proc_authinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_authinfo"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_cancel_resp = Module["_hs_sip326x_tu_proc_cancel_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_cancel_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_ccm_msg = Module["_hs_sip326x_tu_proc_ccm_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_ccm_msg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_ccm_req_in_dlg = Module["_hs_sip326x_tu_proc_ccm_req_in_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_ccm_req_in_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_ccm_req_out_of_dlg = Module["_hs_sip326x_tu_proc_ccm_req_out_of_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_ccm_req_out_of_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_ccm_resp = Module["_hs_sip326x_tu_proc_ccm_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_ccm_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_ext_regevnt_notify = Module["_hs_sip326x_tu_proc_ext_regevnt_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_ext_regevnt_notify"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_negative_resp_from_nw = Module["_hs_sip326x_tu_proc_negative_resp_from_nw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_negative_resp_from_nw"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_notify_internal_dlg = Module["_hs_sip326x_tu_proc_notify_internal_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_notify_internal_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_nw_event = Module["_hs_sip326x_tu_proc_nw_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_nw_event"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_reg_unreg = Module["_hs_sip326x_tu_proc_reg_unreg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_reg_unreg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_retx_2xx = Module["_hs_sip326x_tu_proc_retx_2xx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_retx_2xx"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_sigcomp_msg = Module["_hs_sip326x_tu_proc_sigcomp_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_sigcomp_msg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_sip_msg = Module["_hs_sip326x_tu_proc_sip_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_sip_msg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_sip_reg_resp = Module["_hs_sip326x_tu_proc_sip_reg_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_sip_reg_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_sip_req_in_dlg = Module["_hs_sip326x_tu_proc_sip_req_in_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_sip_req_in_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_sip_req_out_of_dlg = Module["_hs_sip326x_tu_proc_sip_req_out_of_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_sip_req_out_of_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_sip_req_recvd = Module["_hs_sip326x_tu_proc_sip_req_recvd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_sip_req_recvd"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_sip_resp_recvd = Module["_hs_sip326x_tu_proc_sip_resp_recvd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_sip_resp_recvd"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_start_notify = Module["_hs_sip326x_tu_proc_start_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_start_notify"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_stop_notify = Module["_hs_sip326x_tu_proc_stop_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_stop_notify"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_timer_msg = Module["_hs_sip326x_tu_proc_timer_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_timer_msg"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_tl_tp_errors = Module["_hs_sip326x_tu_proc_tl_tp_errors"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_tl_tp_errors"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_trigger_nw_response = Module["_hs_sip326x_tu_proc_trigger_nw_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_trigger_nw_response"].apply(null, arguments);
});
var _hs_sip326x_tu_proc_trigger_req_retx_timeout = Module["_hs_sip326x_tu_proc_trigger_req_retx_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_proc_trigger_req_retx_timeout"].apply(null, arguments);
});
var _hs_sip326x_tu_process_error_req = Module["_hs_sip326x_tu_process_error_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_process_error_req"].apply(null, arguments);
});
var _hs_sip326x_tu_process_session_timers_in_resp = Module["_hs_sip326x_tu_process_session_timers_in_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_process_session_timers_in_resp"].apply(null, arguments);
});
var _hs_sip326x_tu_record_failover = Module["_hs_sip326x_tu_record_failover"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_record_failover"].apply(null, arguments);
});
var _hs_sip326x_tu_reg_db_init = Module["_hs_sip326x_tu_reg_db_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reg_db_init"].apply(null, arguments);
});
var _hs_sip326x_tu_reg_db_reinit = Module["_hs_sip326x_tu_reg_db_reinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reg_db_reinit"].apply(null, arguments);
});
var _hs_sip326x_tu_reg_db_shutdown = Module["_hs_sip326x_tu_reg_db_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reg_db_shutdown"].apply(null, arguments);
});
var _hs_sip326x_tu_reg_dlg_update_localaddr = Module["_hs_sip326x_tu_reg_dlg_update_localaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reg_dlg_update_localaddr"].apply(null, arguments);
});
var _hs_sip326x_tu_reg_event_refresh_subscribe = Module["_hs_sip326x_tu_reg_event_refresh_subscribe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reg_event_refresh_subscribe"].apply(null, arguments);
});
var _hs_sip326x_tu_reg_event_subscribe = Module["_hs_sip326x_tu_reg_event_subscribe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reg_event_subscribe"].apply(null, arguments);
});
var _hs_sip326x_tu_reg_event_unsubscribe = Module["_hs_sip326x_tu_reg_event_unsubscribe"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reg_event_unsubscribe"].apply(null, arguments);
});
var _hs_sip326x_tu_regdlg_ct_add = Module["_hs_sip326x_tu_regdlg_ct_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_regdlg_ct_add"].apply(null, arguments);
});
var _hs_sip326x_tu_regdlg_ct_remove = Module["_hs_sip326x_tu_regdlg_ct_remove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_regdlg_ct_remove"].apply(null, arguments);
});
var _hs_sip326x_tu_reinit = Module["_hs_sip326x_tu_reinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reinit"].apply(null, arguments);
});
var _hs_sip326x_tu_reject_pend_NIST_of_call = Module["_hs_sip326x_tu_reject_pend_NIST_of_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reject_pend_NIST_of_call"].apply(null, arguments);
});
var _hs_sip326x_tu_release_dlg = Module["_hs_sip326x_tu_release_dlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_release_dlg"].apply(null, arguments);
});
var _hs_sip326x_tu_release_forked_dlgs = Module["_hs_sip326x_tu_release_forked_dlgs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_release_forked_dlgs"].apply(null, arguments);
});
var _hs_sip326x_tu_release_reg = Module["_hs_sip326x_tu_release_reg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_release_reg"].apply(null, arguments);
});
var _hs_sip326x_tu_rem_regflow_entry = Module["_hs_sip326x_tu_rem_regflow_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_rem_regflow_entry"].apply(null, arguments);
});
var _hs_sip326x_tu_reset_active_server = Module["_hs_sip326x_tu_reset_active_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reset_active_server"].apply(null, arguments);
});
var _hs_sip326x_tu_retry_msgq_posting = Module["_hs_sip326x_tu_retry_msgq_posting"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_retry_msgq_posting"].apply(null, arguments);
});
var _hs_sip326x_tu_reverse_copy_route_list = Module["_hs_sip326x_tu_reverse_copy_route_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_reverse_copy_route_list"].apply(null, arguments);
});
var _hs_sip326x_tu_send_ack_and_bye = Module["_hs_sip326x_tu_send_ack_and_bye"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_send_ack_and_bye"].apply(null, arguments);
});
var _hs_sip326x_tu_send_keep_alive_msg = Module["_hs_sip326x_tu_send_keep_alive_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_send_keep_alive_msg"].apply(null, arguments);
});
var _hs_sip326x_tu_send_req_without_dialog_creation = Module["_hs_sip326x_tu_send_req_without_dialog_creation"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_send_req_without_dialog_creation"].apply(null, arguments);
});
var _hs_sip326x_tu_set_active_server = Module["_hs_sip326x_tu_set_active_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_set_active_server"].apply(null, arguments);
});
var _hs_sip326x_tu_set_passociated = Module["_hs_sip326x_tu_set_passociated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_set_passociated"].apply(null, arguments);
});
var _hs_sip326x_tu_shutdown = Module["_hs_sip326x_tu_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_shutdown"].apply(null, arguments);
});
var _hs_sip326x_tu_start = Module["_hs_sip326x_tu_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_start"].apply(null, arguments);
});
var _hs_sip326x_tu_start_keepalive_timer = Module["_hs_sip326x_tu_start_keepalive_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_start_keepalive_timer"].apply(null, arguments);
});
var _hs_sip326x_tu_start_ping_timer = Module["_hs_sip326x_tu_start_ping_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_start_ping_timer"].apply(null, arguments);
});
var _hs_sip326x_tu_start_session_timers = Module["_hs_sip326x_tu_start_session_timers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_start_session_timers"].apply(null, arguments);
});
var _hs_sip326x_tu_stop = Module["_hs_sip326x_tu_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_stop"].apply(null, arguments);
});
var _hs_sip326x_tu_stop_1xx_timers = Module["_hs_sip326x_tu_stop_1xx_timers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_stop_1xx_timers"].apply(null, arguments);
});
var _hs_sip326x_tu_stop_keepalive_timer = Module["_hs_sip326x_tu_stop_keepalive_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_stop_keepalive_timer"].apply(null, arguments);
});
var _hs_sip326x_tu_stop_ping_timer = Module["_hs_sip326x_tu_stop_ping_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_stop_ping_timer"].apply(null, arguments);
});
var _hs_sip326x_tu_stop_session_timers = Module["_hs_sip326x_tu_stop_session_timers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_stop_session_timers"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_add_node = Module["_hs_sip326x_tu_sub_add_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_add_node"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_destroy_node = Module["_hs_sip326x_tu_sub_destroy_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_destroy_node"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_get_node_ccm_id = Module["_hs_sip326x_tu_sub_get_node_ccm_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_get_node_ccm_id"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_get_node_event_id = Module["_hs_sip326x_tu_sub_get_node_event_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_get_node_event_id"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_get_node_event_type = Module["_hs_sip326x_tu_sub_get_node_event_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_get_node_event_type"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_proc_auth_challenge = Module["_hs_sip326x_tu_sub_proc_auth_challenge"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_proc_auth_challenge"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_proc_min_expires = Module["_hs_sip326x_tu_sub_proc_min_expires"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_proc_min_expires"].apply(null, arguments);
});
var _hs_sip326x_tu_sub_proc_resp_from_nw = Module["_hs_sip326x_tu_sub_proc_resp_from_nw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_sub_proc_resp_from_nw"].apply(null, arguments);
});
var _hs_sip326x_tu_subscribe_refresh = Module["_hs_sip326x_tu_subscribe_refresh"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_subscribe_refresh"].apply(null, arguments);
});
var _hs_sip326x_tu_trigger_notify_for_dialog_event = Module["_hs_sip326x_tu_trigger_notify_for_dialog_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_trigger_notify_for_dialog_event"].apply(null, arguments);
});
var _hs_sip326x_tu_trigger_notify_for_refer_event = Module["_hs_sip326x_tu_trigger_notify_for_refer_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_trigger_notify_for_refer_event"].apply(null, arguments);
});
var _hs_sip326x_tu_trigger_sub_resp_and_notify = Module["_hs_sip326x_tu_trigger_sub_resp_and_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_trigger_sub_resp_and_notify"].apply(null, arguments);
});
var _hs_sip326x_tu_update_regtable_entry = Module["_hs_sip326x_tu_update_regtable_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_update_regtable_entry"].apply(null, arguments);
});
var _hs_sip326x_tu_user_login = Module["_hs_sip326x_tu_user_login"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_user_login"].apply(null, arguments);
});
var _hs_sip326x_tu_user_logout = Module["_hs_sip326x_tu_user_logout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_user_logout"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_1xx_for_invite = Module["_hs_sip326x_tu_validate_1xx_for_invite"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_1xx_for_invite"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_2xx_for_invite = Module["_hs_sip326x_tu_validate_2xx_for_invite"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_2xx_for_invite"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_alert = Module["_hs_sip326x_tu_validate_ccm_alert"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_alert"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_callredirect = Module["_hs_sip326x_tu_validate_ccm_callredirect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_callredirect"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_connect = Module["_hs_sip326x_tu_validate_ccm_connect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_connect"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_connect_ack = Module["_hs_sip326x_tu_validate_ccm_connect_ack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_connect_ack"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_getcapability = Module["_hs_sip326x_tu_validate_ccm_getcapability"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_getcapability"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_getcapability_response = Module["_hs_sip326x_tu_validate_ccm_getcapability_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_getcapability_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_info_req = Module["_hs_sip326x_tu_validate_ccm_info_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_info_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_info_response = Module["_hs_sip326x_tu_validate_ccm_info_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_info_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_message_req = Module["_hs_sip326x_tu_validate_ccm_message_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_message_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_message_response = Module["_hs_sip326x_tu_validate_ccm_message_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_message_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_notify_req = Module["_hs_sip326x_tu_validate_ccm_notify_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_notify_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_notify_response = Module["_hs_sip326x_tu_validate_ccm_notify_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_notify_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_ping_req = Module["_hs_sip326x_tu_validate_ccm_ping_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_ping_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_prack_req = Module["_hs_sip326x_tu_validate_ccm_prack_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_prack_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_prack_response = Module["_hs_sip326x_tu_validate_ccm_prack_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_prack_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_redirect_response = Module["_hs_sip326x_tu_validate_ccm_redirect_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_redirect_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_refer_req = Module["_hs_sip326x_tu_validate_ccm_refer_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_refer_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_refer_response = Module["_hs_sip326x_tu_validate_ccm_refer_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_refer_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_register = Module["_hs_sip326x_tu_validate_ccm_register"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_register"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_release = Module["_hs_sip326x_tu_validate_ccm_release"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_release"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_service_req = Module["_hs_sip326x_tu_validate_ccm_service_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_service_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_service_response = Module["_hs_sip326x_tu_validate_ccm_service_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_service_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_setup = Module["_hs_sip326x_tu_validate_ccm_setup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_setup"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_start_notify = Module["_hs_sip326x_tu_validate_ccm_start_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_start_notify"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_stop_notify = Module["_hs_sip326x_tu_validate_ccm_stop_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_stop_notify"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_subscribe_req = Module["_hs_sip326x_tu_validate_ccm_subscribe_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_subscribe_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_subscribe_response = Module["_hs_sip326x_tu_validate_ccm_subscribe_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_subscribe_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_update = Module["_hs_sip326x_tu_validate_ccm_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_update"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_ccm_update_response = Module["_hs_sip326x_tu_validate_ccm_update_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_ccm_update_response"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_insession_req = Module["_hs_sip326x_tu_validate_insession_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_insession_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_outsession_req = Module["_hs_sip326x_tu_validate_outsession_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_outsession_req"].apply(null, arguments);
});
var _hs_sip326x_tu_validate_privacy = Module["_hs_sip326x_tu_validate_privacy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_tu_validate_privacy"].apply(null, arguments);
});
var _hs_sip326x_ua_controller = Module["_hs_sip326x_ua_controller"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_ua_controller"].apply(null, arguments);
});
var _hs_sip326x_ua_init = Module["_hs_sip326x_ua_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_ua_init"].apply(null, arguments);
});
var _hs_sip326x_ua_shutdown = Module["_hs_sip326x_ua_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_ua_shutdown"].apply(null, arguments);
});
var _hs_sip326x_ua_start = Module["_hs_sip326x_ua_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_ua_start"].apply(null, arguments);
});
var _hs_sip326x_ua_stop = Module["_hs_sip326x_ua_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_ua_stop"].apply(null, arguments);
});
var _hs_sip326x_unregister_appln_callback = Module["_hs_sip326x_unregister_appln_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_unregister_appln_callback"].apply(null, arguments);
});
var _hs_sip326x_update_validcontact_expiry = Module["_hs_sip326x_update_validcontact_expiry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_update_validcontact_expiry"].apply(null, arguments);
});
var _hs_sip326x_xml_parse_reginfo = Module["_hs_sip326x_xml_parse_reginfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip326x_xml_parse_reginfo"].apply(null, arguments);
});
var _hs_sip_address_hdr_add_other_param = Module["_hs_sip_address_hdr_add_other_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_add_other_param"].apply(null, arguments);
});
var _hs_sip_address_hdr_compare = Module["_hs_sip_address_hdr_compare"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_compare"].apply(null, arguments);
});
var _hs_sip_address_hdr_copy = Module["_hs_sip_address_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_copy"].apply(null, arguments);
});
var _hs_sip_address_hdr_create_copy = Module["_hs_sip_address_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_address_hdr_create_default = Module["_hs_sip_address_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_address_hdr_free = Module["_hs_sip_address_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_free"].apply(null, arguments);
});
var _hs_sip_address_hdr_from_value_string = Module["_hs_sip_address_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_address_hdr_validate = Module["_hs_sip_address_hdr_validate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_address_hdr_validate"].apply(null, arguments);
});
var _hs_sip_app_digest_get_resp = Module["_hs_sip_app_digest_get_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_app_digest_get_resp"].apply(null, arguments);
});
var _hs_sip_app_if_digest_is_registered = Module["_hs_sip_app_if_digest_is_registered"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_app_if_digest_is_registered"].apply(null, arguments);
});
var _hs_sip_app_init_digest_db = Module["_hs_sip_app_init_digest_db"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_app_init_digest_db"].apply(null, arguments);
});
var _hs_sip_auth_info_hdr_add_param = Module["_hs_sip_auth_info_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_auth_info_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_auth_info_hdr_copy = Module["_hs_sip_auth_info_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_auth_info_hdr_copy"].apply(null, arguments);
});
var _hs_sip_auth_info_hdr_create_copy = Module["_hs_sip_auth_info_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_auth_info_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_auth_info_hdr_create_default = Module["_hs_sip_auth_info_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_auth_info_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_auth_info_hdr_free = Module["_hs_sip_auth_info_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_auth_info_hdr_free"].apply(null, arguments);
});
var _hs_sip_auth_info_hdr_from_value_string = Module["_hs_sip_auth_info_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_auth_info_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_authrz_hdr_add_param = Module["_hs_sip_authrz_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_authrz_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_authrz_hdr_create_copy = Module["_hs_sip_authrz_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_authrz_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_authrz_hdr_create_default = Module["_hs_sip_authrz_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_authrz_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_authrz_hdr_digest_resp_copy = Module["_hs_sip_authrz_hdr_digest_resp_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_authrz_hdr_digest_resp_copy"].apply(null, arguments);
});
var _hs_sip_authrz_hdr_free = Module["_hs_sip_authrz_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_authrz_hdr_free"].apply(null, arguments);
});
var _hs_sip_authrz_hdr_from_value_string = Module["_hs_sip_authrz_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_authrz_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_build_host = Module["_hs_sip_build_host"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_build_host"].apply(null, arguments);
});
var _hs_sip_contact_hdr_add_param = Module["_hs_sip_contact_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_contact_hdr_copy = Module["_hs_sip_contact_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_copy"].apply(null, arguments);
});
var _hs_sip_contact_hdr_create = Module["_hs_sip_contact_hdr_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_create"].apply(null, arguments);
});
var _hs_sip_contact_hdr_create_copy = Module["_hs_sip_contact_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_contact_hdr_create_default = Module["_hs_sip_contact_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_contact_hdr_free = Module["_hs_sip_contact_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_free"].apply(null, arguments);
});
var _hs_sip_contact_hdr_free_internal = Module["_hs_sip_contact_hdr_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_free_internal"].apply(null, arguments);
});
var _hs_sip_contact_hdr_from_value_string = Module["_hs_sip_contact_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_contact_hdr_get_other_param = Module["_hs_sip_contact_hdr_get_other_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_contact_hdr_get_other_param"].apply(null, arguments);
});
var _hs_sip_cseq_hdr_add_param = Module["_hs_sip_cseq_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_cseq_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_cseq_hdr_copy = Module["_hs_sip_cseq_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_cseq_hdr_copy"].apply(null, arguments);
});
var _hs_sip_cseq_hdr_create_default = Module["_hs_sip_cseq_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_cseq_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_cseq_hdr_free = Module["_hs_sip_cseq_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_cseq_hdr_free"].apply(null, arguments);
});
var _hs_sip_cseq_hdr_from_value_string = Module["_hs_sip_cseq_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_cseq_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_dec_syntverf_addr_hdr = Module["_hs_sip_dec_syntverf_addr_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_dec_syntverf_addr_hdr"].apply(null, arguments);
});
var _hs_sip_dialog_id_compare = Module["_hs_sip_dialog_id_compare"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_dialog_id_compare"].apply(null, arguments);
});
var _hs_sip_dialog_id_copy = Module["_hs_sip_dialog_id_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_dialog_id_copy"].apply(null, arguments);
});
var _hs_sip_dialog_id_free_internal = Module["_hs_sip_dialog_id_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_dialog_id_free_internal"].apply(null, arguments);
});
var _hs_sip_digest_challenge_create_default = Module["_hs_sip_digest_challenge_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_digest_challenge_create_default"].apply(null, arguments);
});
var _hs_sip_digest_challenge_free = Module["_hs_sip_digest_challenge_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_digest_challenge_free"].apply(null, arguments);
});
var _hs_sip_digest_response_create_default = Module["_hs_sip_digest_response_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_digest_response_create_default"].apply(null, arguments);
});
var _hs_sip_digest_response_free = Module["_hs_sip_digest_response_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_digest_response_free"].apply(null, arguments);
});
var _hs_sip_event_hdr_add_param = Module["_hs_sip_event_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_event_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_event_hdr_copy = Module["_hs_sip_event_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_event_hdr_copy"].apply(null, arguments);
});
var _hs_sip_event_hdr_create_default = Module["_hs_sip_event_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_event_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_event_hdr_free = Module["_hs_sip_event_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_event_hdr_free"].apply(null, arguments);
});
var _hs_sip_event_hdr_from_value_string = Module["_hs_sip_event_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_event_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_find_req_dest = Module["_hs_sip_find_req_dest"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_find_req_dest"].apply(null, arguments);
});
var _hs_sip_generic_hdr_add_param = Module["_hs_sip_generic_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_generic_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_generic_hdr_create = Module["_hs_sip_generic_hdr_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_generic_hdr_create"].apply(null, arguments);
});
var _hs_sip_generic_hdr_create_copy = Module["_hs_sip_generic_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_generic_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_generic_hdr_create_default = Module["_hs_sip_generic_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_generic_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_generic_hdr_free = Module["_hs_sip_generic_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_generic_hdr_free"].apply(null, arguments);
});
var _hs_sip_generic_hdr_from_value_string = Module["_hs_sip_generic_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_generic_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_geolocerr_hdr_add_param = Module["_hs_sip_geolocerr_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_geolocerr_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_geolocerr_hdr_copy = Module["_hs_sip_geolocerr_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_geolocerr_hdr_copy"].apply(null, arguments);
});
var _hs_sip_geolocerr_hdr_create_default = Module["_hs_sip_geolocerr_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_geolocerr_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_geolocerr_hdr_free = Module["_hs_sip_geolocerr_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_geolocerr_hdr_free"].apply(null, arguments);
});
var _hs_sip_geolocerr_hdr_from_value_string = Module["_hs_sip_geolocerr_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_geolocerr_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_get_calldlg = Module["_hs_sip_get_calldlg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_get_calldlg"].apply(null, arguments);
});
var _hs_sip_get_event_from_method = Module["_hs_sip_get_event_from_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_get_event_from_method"].apply(null, arguments);
});
var _hs_sip_get_hdr_type_from_name = Module["_hs_sip_get_hdr_type_from_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_get_hdr_type_from_name"].apply(null, arguments);
});
var _hs_sip_get_methodstr_from_event = Module["_hs_sip_get_methodstr_from_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_get_methodstr_from_event"].apply(null, arguments);
});
var _hs_sip_get_paxsnwkinfo_by_ip = Module["_hs_sip_get_paxsnwkinfo_by_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_get_paxsnwkinfo_by_ip"].apply(null, arguments);
});
var _hs_sip_hdr_add_param = Module["_hs_sip_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_hdr_copy_hdrval = Module["_hs_sip_hdr_copy_hdrval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_hdr_copy_hdrval"].apply(null, arguments);
});
var _hs_sip_hdr_free = Module["_hs_sip_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_hdr_free"].apply(null, arguments);
});
var _hs_sip_hdr_from_value_string = Module["_hs_sip_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_hdr_replace_hdrval = Module["_hs_sip_hdr_replace_hdrval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_hdr_replace_hdrval"].apply(null, arguments);
});
var _hs_sip_hdr_update_list = Module["_hs_sip_hdr_update_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_hdr_update_list"].apply(null, arguments);
});
var _hs_sip_histinfo_hdr_add_param = Module["_hs_sip_histinfo_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_histinfo_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_histinfo_hdr_copy = Module["_hs_sip_histinfo_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_histinfo_hdr_copy"].apply(null, arguments);
});
var _hs_sip_histinfo_hdr_create_copy = Module["_hs_sip_histinfo_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_histinfo_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_histinfo_hdr_create_default = Module["_hs_sip_histinfo_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_histinfo_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_histinfo_hdr_free = Module["_hs_sip_histinfo_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_histinfo_hdr_free"].apply(null, arguments);
});
var _hs_sip_histinfo_hdr_free_internal = Module["_hs_sip_histinfo_hdr_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_histinfo_hdr_free_internal"].apply(null, arguments);
});
var _hs_sip_histinfo_hdr_from_value_string = Module["_hs_sip_histinfo_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_histinfo_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_host_copy = Module["_hs_sip_host_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_host_copy"].apply(null, arguments);
});
var _hs_sip_host_free_internal = Module["_hs_sip_host_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_host_free_internal"].apply(null, arguments);
});
var _hs_sip_host_init = Module["_hs_sip_host_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_host_init"].apply(null, arguments);
});
var _hs_sip_host_validate = Module["_hs_sip_host_validate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_host_validate"].apply(null, arguments);
});
var _hs_sip_is_aor_config_pernw = Module["_hs_sip_is_aor_config_pernw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_is_aor_config_pernw"].apply(null, arguments);
});
var _hs_sip_is_string_hdr = Module["_hs_sip_is_string_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_is_string_hdr"].apply(null, arguments);
});
var _hs_sip_min_se_hdr_add_param = Module["_hs_sip_min_se_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_min_se_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_min_se_hdr_copy = Module["_hs_sip_min_se_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_min_se_hdr_copy"].apply(null, arguments);
});
var _hs_sip_min_se_hdr_create_default = Module["_hs_sip_min_se_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_min_se_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_min_se_hdr_free = Module["_hs_sip_min_se_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_min_se_hdr_free"].apply(null, arguments);
});
var _hs_sip_min_se_hdr_from_value_string = Module["_hs_sip_min_se_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_min_se_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_move_cont_cap_to_ccm = Module["_hs_sip_move_cont_cap_to_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_move_cont_cap_to_ccm"].apply(null, arguments);
});
var _hs_sip_move_content_to_ccm = Module["_hs_sip_move_content_to_ccm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_move_content_to_ccm"].apply(null, arguments);
});
var _hs_sip_msg_copy_2 = Module["_hs_sip_msg_copy_2"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_copy_2"].apply(null, arguments);
});
var _hs_sip_msg_create_copy = Module["_hs_sip_msg_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_create_copy"].apply(null, arguments);
});
var _hs_sip_msg_create_default = Module["_hs_sip_msg_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_create_default"].apply(null, arguments);
});
var _hs_sip_msg_free = Module["_hs_sip_msg_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_free"].apply(null, arguments);
});
var _hs_sip_msg_free_internal = Module["_hs_sip_msg_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_free_internal"].apply(null, arguments);
});
var _hs_sip_msg_get_hdr = Module["_hs_sip_msg_get_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_get_hdr"].apply(null, arguments);
});
var _hs_sip_msg_get_hdrlist = Module["_hs_sip_msg_get_hdrlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_get_hdrlist"].apply(null, arguments);
});
var _hs_sip_msg_set_content = Module["_hs_sip_msg_set_content"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_set_content"].apply(null, arguments);
});
var _hs_sip_msg_set_content_cap = Module["_hs_sip_msg_set_content_cap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_set_content_cap"].apply(null, arguments);
});
var _hs_sip_msg_xport_context_copy = Module["_hs_sip_msg_xport_context_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_msg_xport_context_copy"].apply(null, arguments);
});
var _hs_sip_optiontag_hdr_add_param = Module["_hs_sip_optiontag_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_optiontag_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_optiontag_hdr_add_tag = Module["_hs_sip_optiontag_hdr_add_tag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_optiontag_hdr_add_tag"].apply(null, arguments);
});
var _hs_sip_optiontag_hdr_copy = Module["_hs_sip_optiontag_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_optiontag_hdr_copy"].apply(null, arguments);
});
var _hs_sip_optiontag_hdr_create_default = Module["_hs_sip_optiontag_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_optiontag_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_optiontag_hdr_find_bitmap = Module["_hs_sip_optiontag_hdr_find_bitmap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_optiontag_hdr_find_bitmap"].apply(null, arguments);
});
var _hs_sip_optiontag_hdr_free = Module["_hs_sip_optiontag_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_optiontag_hdr_free"].apply(null, arguments);
});
var _hs_sip_optiontag_hdr_from_value_string = Module["_hs_sip_optiontag_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_optiontag_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_rack_hdr_add_param = Module["_hs_sip_rack_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_rack_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_rack_hdr_compare = Module["_hs_sip_rack_hdr_compare"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_rack_hdr_compare"].apply(null, arguments);
});
var _hs_sip_rack_hdr_copy = Module["_hs_sip_rack_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_rack_hdr_copy"].apply(null, arguments);
});
var _hs_sip_rack_hdr_create_default = Module["_hs_sip_rack_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_rack_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_rack_hdr_free = Module["_hs_sip_rack_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_rack_hdr_free"].apply(null, arguments);
});
var _hs_sip_rack_hdr_from_value_string = Module["_hs_sip_rack_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_rack_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_reason_hdr_copy = Module["_hs_sip_reason_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_reason_hdr_copy"].apply(null, arguments);
});
var _hs_sip_reason_hdr_create_copy = Module["_hs_sip_reason_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_reason_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_reason_hdr_create_default = Module["_hs_sip_reason_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_reason_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_reason_hdr_free = Module["_hs_sip_reason_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_reason_hdr_free"].apply(null, arguments);
});
var _hs_sip_reason_hdr_free_internal = Module["_hs_sip_reason_hdr_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_reason_hdr_free_internal"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_add_param = Module["_hs_sip_replaces_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_compare = Module["_hs_sip_replaces_hdr_compare"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_compare"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_copy = Module["_hs_sip_replaces_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_copy"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_create_copy = Module["_hs_sip_replaces_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_create_default = Module["_hs_sip_replaces_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_free = Module["_hs_sip_replaces_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_free"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_free_internal = Module["_hs_sip_replaces_hdr_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_free_internal"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_from_value_string = Module["_hs_sip_replaces_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_init = Module["_hs_sip_replaces_hdr_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_init"].apply(null, arguments);
});
var _hs_sip_replaces_hdr_remove_param = Module["_hs_sip_replaces_hdr_remove_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_replaces_hdr_remove_param"].apply(null, arguments);
});
var _hs_sip_retryafter_hdr_add_param = Module["_hs_sip_retryafter_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_retryafter_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_retryafter_hdr_copy = Module["_hs_sip_retryafter_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_retryafter_hdr_copy"].apply(null, arguments);
});
var _hs_sip_retryafter_hdr_create_default = Module["_hs_sip_retryafter_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_retryafter_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_retryafter_hdr_free = Module["_hs_sip_retryafter_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_retryafter_hdr_free"].apply(null, arguments);
});
var _hs_sip_retryafter_hdr_from_value_string = Module["_hs_sip_retryafter_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_retryafter_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_sess_exp_hdr_add_other_param = Module["_hs_sip_sess_exp_hdr_add_other_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sess_exp_hdr_add_other_param"].apply(null, arguments);
});
var _hs_sip_sess_exp_hdr_copy = Module["_hs_sip_sess_exp_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sess_exp_hdr_copy"].apply(null, arguments);
});
var _hs_sip_sess_exp_hdr_create_default = Module["_hs_sip_sess_exp_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sess_exp_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_sess_exp_hdr_free = Module["_hs_sip_sess_exp_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sess_exp_hdr_free"].apply(null, arguments);
});
var _hs_sip_sess_exp_hdr_from_value_string = Module["_hs_sip_sess_exp_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sess_exp_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_string_hdr_add_param = Module["_hs_sip_string_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_string_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_string_hdr_copy = Module["_hs_sip_string_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_string_hdr_copy"].apply(null, arguments);
});
var _hs_sip_string_hdr_create = Module["_hs_sip_string_hdr_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_string_hdr_create"].apply(null, arguments);
});
var _hs_sip_string_hdr_create_copy = Module["_hs_sip_string_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_string_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_string_hdr_create_default = Module["_hs_sip_string_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_string_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_string_hdr_free = Module["_hs_sip_string_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_string_hdr_free"].apply(null, arguments);
});
var _hs_sip_string_hdr_from_value_string = Module["_hs_sip_string_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_string_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_sub_state_hdr_add_param = Module["_hs_sip_sub_state_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sub_state_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_sub_state_hdr_copy = Module["_hs_sip_sub_state_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sub_state_hdr_copy"].apply(null, arguments);
});
var _hs_sip_sub_state_hdr_create_default = Module["_hs_sip_sub_state_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sub_state_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_sub_state_hdr_free = Module["_hs_sip_sub_state_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sub_state_hdr_free"].apply(null, arguments);
});
var _hs_sip_sub_state_hdr_from_value_string = Module["_hs_sip_sub_state_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_sub_state_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_tl_notify_event = Module["_hs_sip_tl_notify_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_tl_notify_event"].apply(null, arguments);
});
var _hs_sip_tu_outdlg_noninv_proc = Module["_hs_sip_tu_outdlg_noninv_proc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_tu_outdlg_noninv_proc"].apply(null, arguments);
});
var _hs_sip_tu_outdlg_req_proc = Module["_hs_sip_tu_outdlg_req_proc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_tu_outdlg_req_proc"].apply(null, arguments);
});
var _hs_sip_tu_outdlg_sub_proc = Module["_hs_sip_tu_outdlg_sub_proc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_tu_outdlg_sub_proc"].apply(null, arguments);
});
var _hs_sip_txn_if_init = Module["_hs_sip_txn_if_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_txn_if_init"].apply(null, arguments);
});
var _hs_sip_txn_if_notify_event = Module["_hs_sip_txn_if_notify_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_txn_if_notify_event"].apply(null, arguments);
});
var _hs_sip_txn_if_proc_msg = Module["_hs_sip_txn_if_proc_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_txn_if_proc_msg"].apply(null, arguments);
});
var _hs_sip_uint32_hdr_add_param = Module["_hs_sip_uint32_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint32_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_uint32_hdr_create_default = Module["_hs_sip_uint32_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint32_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_uint32_hdr_free = Module["_hs_sip_uint32_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint32_hdr_free"].apply(null, arguments);
});
var _hs_sip_uint32_hdr_from_value_string = Module["_hs_sip_uint32_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint32_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_uint8_hdr_add_param = Module["_hs_sip_uint8_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint8_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_uint8_hdr_create_default = Module["_hs_sip_uint8_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint8_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_uint8_hdr_free = Module["_hs_sip_uint8_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint8_hdr_free"].apply(null, arguments);
});
var _hs_sip_uint8_hdr_from_value_string = Module["_hs_sip_uint8_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uint8_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_uri_compare = Module["_hs_sip_uri_compare"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_compare"].apply(null, arguments);
});
var _hs_sip_uri_copy = Module["_hs_sip_uri_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_copy"].apply(null, arguments);
});
var _hs_sip_uri_create_copy = Module["_hs_sip_uri_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_create_copy"].apply(null, arguments);
});
var _hs_sip_uri_free = Module["_hs_sip_uri_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_free"].apply(null, arguments);
});
var _hs_sip_uri_free_internal = Module["_hs_sip_uri_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_free_internal"].apply(null, arguments);
});
var _hs_sip_uri_from_string = Module["_hs_sip_uri_from_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_from_string"].apply(null, arguments);
});
var _hs_sip_uri_get_scheme = Module["_hs_sip_uri_get_scheme"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_get_scheme"].apply(null, arguments);
});
var _hs_sip_uri_get_transport_param = Module["_hs_sip_uri_get_transport_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_get_transport_param"].apply(null, arguments);
});
var _hs_sip_uri_init = Module["_hs_sip_uri_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_init"].apply(null, arguments);
});
var _hs_sip_uri_to_string = Module["_hs_sip_uri_to_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_uri_to_string"].apply(null, arguments);
});
var _hs_sip_via_hdr_add_other_param = Module["_hs_sip_via_hdr_add_other_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_add_other_param"].apply(null, arguments);
});
var _hs_sip_via_hdr_copy = Module["_hs_sip_via_hdr_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_copy"].apply(null, arguments);
});
var _hs_sip_via_hdr_create_copy = Module["_hs_sip_via_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_via_hdr_create_default = Module["_hs_sip_via_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_via_hdr_free = Module["_hs_sip_via_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_free"].apply(null, arguments);
});
var _hs_sip_via_hdr_free_internal = Module["_hs_sip_via_hdr_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_free_internal"].apply(null, arguments);
});
var _hs_sip_via_hdr_from_value_string = Module["_hs_sip_via_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_via_hdr_has_param = Module["_hs_sip_via_hdr_has_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_has_param"].apply(null, arguments);
});
var _hs_sip_via_hdr_remove_param = Module["_hs_sip_via_hdr_remove_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_remove_param"].apply(null, arguments);
});
var _hs_sip_via_hdr_validate = Module["_hs_sip_via_hdr_validate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_hdr_validate"].apply(null, arguments);
});
var _hs_sip_via_sent_protocol_copy = Module["_hs_sip_via_sent_protocol_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_via_sent_protocol_copy"].apply(null, arguments);
});
var _hs_sip_www_authn_hdr_add_param = Module["_hs_sip_www_authn_hdr_add_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_www_authn_hdr_add_param"].apply(null, arguments);
});
var _hs_sip_www_authn_hdr_create_copy = Module["_hs_sip_www_authn_hdr_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_www_authn_hdr_create_copy"].apply(null, arguments);
});
var _hs_sip_www_authn_hdr_create_default = Module["_hs_sip_www_authn_hdr_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_www_authn_hdr_create_default"].apply(null, arguments);
});
var _hs_sip_www_authn_hdr_digest_challenge_copy = Module["_hs_sip_www_authn_hdr_digest_challenge_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_www_authn_hdr_digest_challenge_copy"].apply(null, arguments);
});
var _hs_sip_www_authn_hdr_free = Module["_hs_sip_www_authn_hdr_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_www_authn_hdr_free"].apply(null, arguments);
});
var _hs_sip_www_authn_hdr_from_value_string = Module["_hs_sip_www_authn_hdr_from_value_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_www_authn_hdr_from_value_string"].apply(null, arguments);
});
var _hs_sip_xml_reginfo_contact_free = Module["_hs_sip_xml_reginfo_contact_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_xml_reginfo_contact_free"].apply(null, arguments);
});
var _hs_sip_xml_reginfo_free = Module["_hs_sip_xml_reginfo_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_xml_reginfo_free"].apply(null, arguments);
});
var _hs_sip_xml_reginfo_reg_free = Module["_hs_sip_xml_reginfo_reg_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_sip_xml_reginfo_reg_free"].apply(null, arguments);
});
var _hs_subscpt_add_app_evtpkg = Module["_hs_subscpt_add_app_evtpkg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_add_app_evtpkg"].apply(null, arguments);
});
var _hs_subscpt_add_subscpt = Module["_hs_subscpt_add_subscpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_add_subscpt"].apply(null, arguments);
});
var _hs_subscpt_add_xaction = Module["_hs_subscpt_add_xaction"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_add_xaction"].apply(null, arguments);
});
var _hs_subscpt_app_send_ind = Module["_hs_subscpt_app_send_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_app_send_ind"].apply(null, arguments);
});
var _hs_subscpt_app_send_reqfailed_ind = Module["_hs_subscpt_app_send_reqfailed_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_app_send_reqfailed_ind"].apply(null, arguments);
});
var _hs_subscpt_app_send_term_ind = Module["_hs_subscpt_app_send_term_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_app_send_term_ind"].apply(null, arguments);
});
var _hs_subscpt_app_send_unsoli_ntfy_ind = Module["_hs_subscpt_app_send_unsoli_ntfy_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_app_send_unsoli_ntfy_ind"].apply(null, arguments);
});
var _hs_subscpt_chng_state = Module["_hs_subscpt_chng_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_chng_state"].apply(null, arguments);
});
var _hs_subscpt_cleanup_msgq = Module["_hs_subscpt_cleanup_msgq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_cleanup_msgq"].apply(null, arguments);
});
var _hs_subscpt_del_subscpt = Module["_hs_subscpt_del_subscpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_del_subscpt"].apply(null, arguments);
});
var _hs_subscpt_del_xaction = Module["_hs_subscpt_del_xaction"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_del_xaction"].apply(null, arguments);
});
var _hs_subscpt_dispatcher = Module["_hs_subscpt_dispatcher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_dispatcher"].apply(null, arguments);
});
var _hs_subscpt_free_appmsg = Module["_hs_subscpt_free_appmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_free_appmsg"].apply(null, arguments);
});
var _hs_subscpt_free_ind = Module["_hs_subscpt_free_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_free_ind"].apply(null, arguments);
});
var _hs_subscpt_free_indinfo = Module["_hs_subscpt_free_indinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_free_indinfo"].apply(null, arguments);
});
var _hs_subscpt_free_subscpt = Module["_hs_subscpt_free_subscpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_free_subscpt"].apply(null, arguments);
});
var _hs_subscpt_get_app_evtpkg = Module["_hs_subscpt_get_app_evtpkg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_get_app_evtpkg"].apply(null, arguments);
});
var _hs_subscpt_get_ctx = Module["_hs_subscpt_get_ctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_get_ctx"].apply(null, arguments);
});
var _hs_subscpt_get_ctx_by_timerid = Module["_hs_subscpt_get_ctx_by_timerid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_get_ctx_by_timerid"].apply(null, arguments);
});
var _hs_subscpt_get_subid_bysipmsg = Module["_hs_subscpt_get_subid_bysipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_get_subid_bysipmsg"].apply(null, arguments);
});
var _hs_subscpt_init = Module["_hs_subscpt_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_init"].apply(null, arguments);
});
var _hs_subscpt_notifier_app_active = Module["_hs_subscpt_notifier_app_active"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_notifier_app_active"].apply(null, arguments);
});
var _hs_subscpt_notifier_app_init = Module["_hs_subscpt_notifier_app_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_notifier_app_init"].apply(null, arguments);
});
var _hs_subscpt_notifier_hndle_appmsg = Module["_hs_subscpt_notifier_hndle_appmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_notifier_hndle_appmsg"].apply(null, arguments);
});
var _hs_subscpt_notifier_hndle_sipmsg = Module["_hs_subscpt_notifier_hndle_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_notifier_hndle_sipmsg"].apply(null, arguments);
});
var _hs_subscpt_notifier_hndle_timermsg = Module["_hs_subscpt_notifier_hndle_timermsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_notifier_hndle_timermsg"].apply(null, arguments);
});
var _hs_subscpt_notifier_sip_expired = Module["_hs_subscpt_notifier_sip_expired"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_notifier_sip_expired"].apply(null, arguments);
});
var _hs_subscpt_notifier_sip_states = Module["_hs_subscpt_notifier_sip_states"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_notifier_sip_states"].apply(null, arguments);
});
var _hs_subscpt_ntfy_req = Module["_hs_subscpt_ntfy_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_ntfy_req"].apply(null, arguments);
});
var _hs_subscpt_ntfy_resp = Module["_hs_subscpt_ntfy_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_ntfy_resp"].apply(null, arguments);
});
var _hs_subscpt_params_copy = Module["_hs_subscpt_params_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_params_copy"].apply(null, arguments);
});
var _hs_subscpt_params_create = Module["_hs_subscpt_params_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_params_create"].apply(null, arguments);
});
var _hs_subscpt_params_destroy = Module["_hs_subscpt_params_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_params_destroy"].apply(null, arguments);
});
var _hs_subscpt_params_init = Module["_hs_subscpt_params_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_params_init"].apply(null, arguments);
});
var _hs_subscpt_reg_evtpkg = Module["_hs_subscpt_reg_evtpkg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_reg_evtpkg"].apply(null, arguments);
});
var _hs_subscpt_reterive_xaction = Module["_hs_subscpt_reterive_xaction"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_reterive_xaction"].apply(null, arguments);
});
var _hs_subscpt_shutdown = Module["_hs_subscpt_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_shutdown"].apply(null, arguments);
});
var _hs_subscpt_sip_cb = Module["_hs_subscpt_sip_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_sip_cb"].apply(null, arguments);
});
var _hs_subscpt_sip_fill_subscb_req = Module["_hs_subscpt_sip_fill_subscb_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_sip_fill_subscb_req"].apply(null, arguments);
});
var _hs_subscpt_sip_send_ntfy = Module["_hs_subscpt_sip_send_ntfy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_sip_send_ntfy"].apply(null, arguments);
});
var _hs_subscpt_sip_send_ntfyresp = Module["_hs_subscpt_sip_send_ntfyresp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_sip_send_ntfyresp"].apply(null, arguments);
});
var _hs_subscpt_sip_send_subresp = Module["_hs_subscpt_sip_send_subresp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_sip_send_subresp"].apply(null, arguments);
});
var _hs_subscpt_sip_send_subscb_appreq = Module["_hs_subscpt_sip_send_subscb_appreq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_sip_send_subscb_appreq"].apply(null, arguments);
});
var _hs_subscpt_sip_send_unsubscb = Module["_hs_subscpt_sip_send_unsubscb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_sip_send_unsubscb"].apply(null, arguments);
});
var _hs_subscpt_start = Module["_hs_subscpt_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_start"].apply(null, arguments);
});
var _hs_subscpt_start_timer = Module["_hs_subscpt_start_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_start_timer"].apply(null, arguments);
});
var _hs_subscpt_stop = Module["_hs_subscpt_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_stop"].apply(null, arguments);
});
var _hs_subscpt_stop_timer = Module["_hs_subscpt_stop_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_stop_timer"].apply(null, arguments);
});
var _hs_subscpt_subscb_app_deactive = Module["_hs_subscpt_subscb_app_deactive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_app_deactive"].apply(null, arguments);
});
var _hs_subscpt_subscb_app_states = Module["_hs_subscpt_subscb_app_states"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_app_states"].apply(null, arguments);
});
var _hs_subscpt_subscb_hndle_appmsg = Module["_hs_subscpt_subscb_hndle_appmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_hndle_appmsg"].apply(null, arguments);
});
var _hs_subscpt_subscb_hndle_ntfy = Module["_hs_subscpt_subscb_hndle_ntfy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_hndle_ntfy"].apply(null, arguments);
});
var _hs_subscpt_subscb_hndle_ntfy_reason = Module["_hs_subscpt_subscb_hndle_ntfy_reason"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_hndle_ntfy_reason"].apply(null, arguments);
});
var _hs_subscpt_subscb_hndle_sipmsg = Module["_hs_subscpt_subscb_hndle_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_hndle_sipmsg"].apply(null, arguments);
});
var _hs_subscpt_subscb_hndle_timermsg = Module["_hs_subscpt_subscb_hndle_timermsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_hndle_timermsg"].apply(null, arguments);
});
var _hs_subscpt_subscb_sip_active = Module["_hs_subscpt_subscb_sip_active"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_sip_active"].apply(null, arguments);
});
var _hs_subscpt_subscb_sip_deactive = Module["_hs_subscpt_subscb_sip_deactive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_sip_deactive"].apply(null, arguments);
});
var _hs_subscpt_subscb_sip_init = Module["_hs_subscpt_subscb_sip_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_sip_init"].apply(null, arguments);
});
var _hs_subscpt_subscb_sip_toexpire = Module["_hs_subscpt_subscb_sip_toexpire"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_sip_toexpire"].apply(null, arguments);
});
var _hs_subscpt_subscb_sip_unsuscbinit = Module["_hs_subscpt_subscb_sip_unsuscbinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscb_sip_unsuscbinit"].apply(null, arguments);
});
var _hs_subscpt_subscribe_req = Module["_hs_subscpt_subscribe_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscribe_req"].apply(null, arguments);
});
var _hs_subscpt_subscribe_resp = Module["_hs_subscpt_subscribe_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_subscribe_resp"].apply(null, arguments);
});
var _hs_subscpt_unsubscribe_req = Module["_hs_subscpt_unsubscribe_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_unsubscribe_req"].apply(null, arguments);
});
var _hs_subscpt_update_credentials = Module["_hs_subscpt_update_credentials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_subscpt_update_credentials"].apply(null, arguments);
});
var _hs_support_uuid_create = Module["_hs_support_uuid_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_support_uuid_create"].apply(null, arguments);
});
var _hs_support_uuid_create_md5_from_name = Module["_hs_support_uuid_create_md5_from_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_support_uuid_create_md5_from_name"].apply(null, arguments);
});
var _hs_toucs = Module["_hs_toucs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_toucs"].apply(null, arguments);
});
var _hs_voip_answer_call = Module["_hs_voip_answer_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_answer_call"].apply(null, arguments);
});
var _hs_voip_bconf_create = Module["_hs_voip_bconf_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_bconf_create"].apply(null, arguments);
});
var _hs_voip_bconf_create_with_urilist = Module["_hs_voip_bconf_create_with_urilist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_bconf_create_with_urilist"].apply(null, arguments);
});
var _hs_voip_build_config_path = Module["_hs_voip_build_config_path"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_build_config_path"].apply(null, arguments);
});
var _hs_voip_build_default_path = Module["_hs_voip_build_default_path"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_build_default_path"].apply(null, arguments);
});
var _hs_voip_build_domain_path = Module["_hs_voip_build_domain_path"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_build_domain_path"].apply(null, arguments);
});
var _hs_voip_build_uri_from_identity = Module["_hs_voip_build_uri_from_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_build_uri_from_identity"].apply(null, arguments);
});
var _hs_voip_call_params_init = Module["_hs_voip_call_params_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_call_params_init"].apply(null, arguments);
});
var _hs_voip_call_parking = Module["_hs_voip_call_parking"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_call_parking"].apply(null, arguments);
});
var _hs_voip_ccm_alert_timer = Module["_hs_voip_ccm_alert_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_alert_timer"].apply(null, arguments);
});
var _hs_voip_ccm_answer_incoming_call = Module["_hs_voip_ccm_answer_incoming_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_answer_incoming_call"].apply(null, arguments);
});
var _hs_voip_ccm_app_change_codec = Module["_hs_voip_ccm_app_change_codec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_change_codec"].apply(null, arguments);
});
var _hs_voip_ccm_app_change_to_fax = Module["_hs_voip_ccm_app_change_to_fax"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_change_to_fax"].apply(null, arguments);
});
var _hs_voip_ccm_app_disable_cwait = Module["_hs_voip_ccm_app_disable_cwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_disable_cwait"].apply(null, arguments);
});
var _hs_voip_ccm_app_request_allowed = Module["_hs_voip_ccm_app_request_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_request_allowed"].apply(null, arguments);
});
var _hs_voip_ccm_app_send_im_msg = Module["_hs_voip_ccm_app_send_im_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_send_im_msg"].apply(null, arguments);
});
var _hs_voip_ccm_app_send_notify = Module["_hs_voip_ccm_app_send_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_send_notify"].apply(null, arguments);
});
var _hs_voip_ccm_app_send_ping_request = Module["_hs_voip_ccm_app_send_ping_request"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_send_ping_request"].apply(null, arguments);
});
var _hs_voip_ccm_app_send_subscb_resp = Module["_hs_voip_ccm_app_send_subscb_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_send_subscb_resp"].apply(null, arguments);
});
var _hs_voip_ccm_app_send_subscpt = Module["_hs_voip_ccm_app_send_subscpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_send_subscpt"].apply(null, arguments);
});
var _hs_voip_ccm_app_service_dispatcher = Module["_hs_voip_ccm_app_service_dispatcher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_service_dispatcher"].apply(null, arguments);
});
var _hs_voip_ccm_app_set_dtmf_xport = Module["_hs_voip_ccm_app_set_dtmf_xport"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_set_dtmf_xport"].apply(null, arguments);
});
var _hs_voip_ccm_app_user_login = Module["_hs_voip_ccm_app_user_login"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_user_login"].apply(null, arguments);
});
var _hs_voip_ccm_app_user_logout = Module["_hs_voip_ccm_app_user_logout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_app_user_logout"].apply(null, arguments);
});
var _hs_voip_ccm_attend_out_sess_refer = Module["_hs_voip_ccm_attend_out_sess_refer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_attend_out_sess_refer"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_add_list_pcpt_to_conf = Module["_hs_voip_ccm_bconf_add_list_pcpt_to_conf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_add_list_pcpt_to_conf"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_add_next_pcpt = Module["_hs_voip_ccm_bconf_add_next_pcpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_add_next_pcpt"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_add_party = Module["_hs_voip_ccm_bconf_add_party"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_add_party"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_app_active = Module["_hs_voip_ccm_bconf_app_active"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_app_active"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_app_held = Module["_hs_voip_ccm_bconf_app_held"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_app_held"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_app_incoming = Module["_hs_voip_ccm_bconf_app_incoming"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_app_incoming"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_app_init = Module["_hs_voip_ccm_bconf_app_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_app_init"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_app_null = Module["_hs_voip_ccm_bconf_app_null"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_app_null"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_build_urilist_content = Module["_hs_voip_ccm_bconf_build_urilist_content"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_build_urilist_content"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_callback = Module["_hs_voip_ccm_bconf_callback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_callback"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_clear_obj = Module["_hs_voip_ccm_bconf_clear_obj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_clear_obj"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_create = Module["_hs_voip_ccm_bconf_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_create"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_create_3pty = Module["_hs_voip_ccm_bconf_create_3pty"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_create_3pty"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_create_urilist = Module["_hs_voip_ccm_bconf_create_urilist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_create_urilist"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_get_free_obj = Module["_hs_voip_ccm_bconf_get_free_obj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_get_free_obj"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_get_obj_by_2pty_callid = Module["_hs_voip_ccm_bconf_get_obj_by_2pty_callid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_get_obj_by_2pty_callid"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_get_obj_by_callid = Module["_hs_voip_ccm_bconf_get_obj_by_callid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_get_obj_by_callid"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_get_obj_by_state = Module["_hs_voip_ccm_bconf_get_obj_by_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_get_obj_by_state"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_get_obj_from_subscr_id = Module["_hs_voip_ccm_bconf_get_obj_from_subscr_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_get_obj_from_subscr_id"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_get_party_info = Module["_hs_voip_ccm_bconf_get_party_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_get_party_info"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_get_pcpt_node = Module["_hs_voip_ccm_bconf_get_pcpt_node"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_get_pcpt_node"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_handle_answer_ind = Module["_hs_voip_ccm_bconf_handle_answer_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_handle_answer_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_handle_makefailed_ind = Module["_hs_voip_ccm_bconf_handle_makefailed_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_handle_makefailed_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_handle_refer_failure = Module["_hs_voip_ccm_bconf_handle_refer_failure"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_handle_refer_failure"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_handle_release_ind = Module["_hs_voip_ccm_bconf_handle_release_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_handle_release_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_hndle_refer_notify = Module["_hs_voip_ccm_bconf_hndle_refer_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_hndle_refer_notify"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_hndle_subscb_notify = Module["_hs_voip_ccm_bconf_hndle_subscb_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_hndle_subscb_notify"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_init = Module["_hs_voip_ccm_bconf_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_init"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_ntfy_rcvd_ind = Module["_hs_voip_ccm_bconf_ntfy_rcvd_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_ntfy_rcvd_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_pcpt_status_ind = Module["_hs_voip_ccm_bconf_pcpt_status_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_pcpt_status_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_process_app_req = Module["_hs_voip_ccm_bconf_process_app_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_process_app_req"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_process_req = Module["_hs_voip_ccm_bconf_process_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_process_req"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_release_bconf = Module["_hs_voip_ccm_bconf_release_bconf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_release_bconf"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_remove_party = Module["_hs_voip_ccm_bconf_remove_party"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_remove_party"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_revert_3pty = Module["_hs_voip_ccm_bconf_revert_3pty"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_revert_3pty"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_send_app_ind = Module["_hs_voip_ccm_bconf_send_app_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_send_app_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_send_app_subscb_sent_ind = Module["_hs_voip_ccm_bconf_send_app_subscb_sent_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_send_app_subscb_sent_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_send_failed_ind = Module["_hs_voip_ccm_bconf_send_failed_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_send_failed_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_send_init_ind = Module["_hs_voip_ccm_bconf_send_init_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_send_init_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_send_terminated_ind = Module["_hs_voip_ccm_bconf_send_terminated_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_send_terminated_ind"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_shutdown = Module["_hs_voip_ccm_bconf_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_shutdown"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_subscribe_req = Module["_hs_voip_ccm_bconf_subscribe_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_subscribe_req"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_terminate = Module["_hs_voip_ccm_bconf_terminate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_terminate"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_to_app = Module["_hs_voip_ccm_bconf_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_to_app"].apply(null, arguments);
});
var _hs_voip_ccm_bconf_update_pcpt_list = Module["_hs_voip_ccm_bconf_update_pcpt_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_bconf_update_pcpt_list"].apply(null, arguments);
});
var _hs_voip_ccm_build_3pcc_midsess_offer = Module["_hs_voip_ccm_build_3pcc_midsess_offer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_build_3pcc_midsess_offer"].apply(null, arguments);
});
var _hs_voip_ccm_build_fax_params = Module["_hs_voip_ccm_build_fax_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_build_fax_params"].apply(null, arguments);
});
var _hs_voip_ccm_build_midsess_offer = Module["_hs_voip_ccm_build_midsess_offer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_build_midsess_offer"].apply(null, arguments);
});
var _hs_voip_ccm_build_midsess_sdp = Module["_hs_voip_ccm_build_midsess_sdp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_build_midsess_sdp"].apply(null, arguments);
});
var _hs_voip_ccm_build_send_codec_change = Module["_hs_voip_ccm_build_send_codec_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_build_send_codec_change"].apply(null, arguments);
});
var _hs_voip_ccm_build_send_nwpref_sdp = Module["_hs_voip_ccm_build_send_nwpref_sdp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_build_send_nwpref_sdp"].apply(null, arguments);
});
var _hs_voip_ccm_c002_alert = Module["_hs_voip_ccm_c002_alert"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_alert"].apply(null, arguments);
});
var _hs_voip_ccm_c002_callinitiated = Module["_hs_voip_ccm_c002_callinitiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_callinitiated"].apply(null, arguments);
});
var _hs_voip_ccm_c002_callwaiting = Module["_hs_voip_ccm_c002_callwaiting"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_callwaiting"].apply(null, arguments);
});
var _hs_voip_ccm_c002_change_codec = Module["_hs_voip_ccm_c002_change_codec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_change_codec"].apply(null, arguments);
});
var _hs_voip_ccm_c002_conn_ack = Module["_hs_voip_ccm_c002_conn_ack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_conn_ack"].apply(null, arguments);
});
var _hs_voip_ccm_c002_connected = Module["_hs_voip_ccm_c002_connected"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_connected"].apply(null, arguments);
});
var _hs_voip_ccm_c002_connected_ring = Module["_hs_voip_ccm_c002_connected_ring"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_connected_ring"].apply(null, arguments);
});
var _hs_voip_ccm_c002_conntd_rsrcwait = Module["_hs_voip_ccm_c002_conntd_rsrcwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_conntd_rsrcwait"].apply(null, arguments);
});
var _hs_voip_ccm_c002_ct_initiated = Module["_hs_voip_ccm_c002_ct_initiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_ct_initiated"].apply(null, arguments);
});
var _hs_voip_ccm_c002_ct_wait = Module["_hs_voip_ccm_c002_ct_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_ct_wait"].apply(null, arguments);
});
var _hs_voip_ccm_c002_ctheld = Module["_hs_voip_ccm_c002_ctheld"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_ctheld"].apply(null, arguments);
});
var _hs_voip_ccm_c002_error = Module["_hs_voip_ccm_c002_error"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_error"].apply(null, arguments);
});
var _hs_voip_ccm_c002_fxo_dialtone = Module["_hs_voip_ccm_c002_fxo_dialtone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_fxo_dialtone"].apply(null, arguments);
});
var _hs_voip_ccm_c002_fxo_ringback_tone = Module["_hs_voip_ccm_c002_fxo_ringback_tone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_fxo_ringback_tone"].apply(null, arguments);
});
var _hs_voip_ccm_c002_held = Module["_hs_voip_ccm_c002_held"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_held"].apply(null, arguments);
});
var _hs_voip_ccm_c002_held_ack = Module["_hs_voip_ccm_c002_held_ack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_held_ack"].apply(null, arguments);
});
var _hs_voip_ccm_c002_held_initiated = Module["_hs_voip_ccm_c002_held_initiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_held_initiated"].apply(null, arguments);
});
var _hs_voip_ccm_c002_held_wait = Module["_hs_voip_ccm_c002_held_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_held_wait"].apply(null, arguments);
});
var _hs_voip_ccm_c002_incoming = Module["_hs_voip_ccm_c002_incoming"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_incoming"].apply(null, arguments);
});
var _hs_voip_ccm_c002_null = Module["_hs_voip_ccm_c002_null"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_null"].apply(null, arguments);
});
var _hs_voip_ccm_c002_offhook = Module["_hs_voip_ccm_c002_offhook"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_offhook"].apply(null, arguments);
});
var _hs_voip_ccm_c002_release = Module["_hs_voip_ccm_c002_release"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_release"].apply(null, arguments);
});
var _hs_voip_ccm_c002_rsrcinit = Module["_hs_voip_ccm_c002_rsrcinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_rsrcinit"].apply(null, arguments);
});
var _hs_voip_ccm_c002_update_initiated = Module["_hs_voip_ccm_c002_update_initiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_update_initiated"].apply(null, arguments);
});
var _hs_voip_ccm_c002_update_rcvd = Module["_hs_voip_ccm_c002_update_rcvd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_update_rcvd"].apply(null, arguments);
});
var _hs_voip_ccm_c002_user_resp = Module["_hs_voip_ccm_c002_user_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_c002_user_resp"].apply(null, arguments);
});
var _hs_voip_ccm_call_parking_handler = Module["_hs_voip_ccm_call_parking_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_call_parking_handler"].apply(null, arguments);
});
var _hs_voip_ccm_callconnected_timer = Module["_hs_voip_ccm_callconnected_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callconnected_timer"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_add_xaction = Module["_hs_voip_ccm_callobj_add_xaction"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_add_xaction"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_changstate_x = Module["_hs_voip_ccm_callobj_changstate_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_changstate_x"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_clear_refer_sub = Module["_hs_voip_ccm_callobj_clear_refer_sub"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_clear_refer_sub"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_enter_callstate = Module["_hs_voip_ccm_callobj_enter_callstate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_enter_callstate"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_get_diversion_hdrs = Module["_hs_voip_ccm_callobj_get_diversion_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_get_diversion_hdrs"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_handle_dtmf = Module["_hs_voip_ccm_callobj_handle_dtmf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_handle_dtmf"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_init = Module["_hs_voip_ccm_callobj_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_init"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_is_callswitch_possible = Module["_hs_voip_ccm_callobj_is_callswitch_possible"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_is_callswitch_possible"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_retrieve_nat_info = Module["_hs_voip_ccm_callobj_retrieve_nat_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_retrieve_nat_info"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_retrive_xaction_x = Module["_hs_voip_ccm_callobj_retrive_xaction_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_retrive_xaction_x"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_send_update = Module["_hs_voip_ccm_callobj_send_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_send_update"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_timer_cb = Module["_hs_voip_ccm_callobj_timer_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_timer_cb"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_update_codeclist = Module["_hs_voip_ccm_callobj_update_codeclist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_update_codeclist"].apply(null, arguments);
});
var _hs_voip_ccm_callobj_update_nat_info = Module["_hs_voip_ccm_callobj_update_nat_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callobj_update_nat_info"].apply(null, arguments);
});
var _hs_voip_ccm_callpickup_handler = Module["_hs_voip_ccm_callpickup_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_callpickup_handler"].apply(null, arguments);
});
var _hs_voip_ccm_can_terminate_call = Module["_hs_voip_ccm_can_terminate_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_can_terminate_call"].apply(null, arguments);
});
var _hs_voip_ccm_cleanup_msgq = Module["_hs_voip_ccm_cleanup_msgq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_cleanup_msgq"].apply(null, arguments);
});
var _hs_voip_ccm_clear_call_parking_details = Module["_hs_voip_ccm_clear_call_parking_details"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_clear_call_parking_details"].apply(null, arguments);
});
var _hs_voip_ccm_clear_callobj = Module["_hs_voip_ccm_clear_callobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_clear_callobj"].apply(null, arguments);
});
var _hs_voip_ccm_compare_and_send_alert = Module["_hs_voip_ccm_compare_and_send_alert"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_compare_and_send_alert"].apply(null, arguments);
});
var _hs_voip_ccm_convert_digit_ascii = Module["_hs_voip_ccm_convert_digit_ascii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_convert_digit_ascii"].apply(null, arguments);
});
var _hs_voip_ccm_copy_call2subscpt_params = Module["_hs_voip_ccm_copy_call2subscpt_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_copy_call2subscpt_params"].apply(null, arguments);
});
var _hs_voip_ccm_copy_forkctx_tocallobj = Module["_hs_voip_ccm_copy_forkctx_tocallobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_copy_forkctx_tocallobj"].apply(null, arguments);
});
var _hs_voip_ccm_copy_secure_params = Module["_hs_voip_ccm_copy_secure_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_copy_secure_params"].apply(null, arguments);
});
var _hs_voip_ccm_create_sipmsg_x = Module["_hs_voip_ccm_create_sipmsg_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_create_sipmsg_x"].apply(null, arguments);
});
var _hs_voip_ccm_createcpy_diversion_list = Module["_hs_voip_ccm_createcpy_diversion_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_createcpy_diversion_list"].apply(null, arguments);
});
var _hs_voip_ccm_dec_uri = Module["_hs_voip_ccm_dec_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dec_uri"].apply(null, arguments);
});
var _hs_voip_ccm_deny_callforward = Module["_hs_voip_ccm_deny_callforward"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_deny_callforward"].apply(null, arguments);
});
var _hs_voip_ccm_deny_refer = Module["_hs_voip_ccm_deny_refer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_deny_refer"].apply(null, arguments);
});
var _hs_voip_ccm_derive_session_mode = Module["_hs_voip_ccm_derive_session_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_derive_session_mode"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_alert = Module["_hs_voip_ccm_dim_app_alert"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_alert"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_call_pickup = Module["_hs_voip_ccm_dim_app_call_pickup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_call_pickup"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_callinitiated = Module["_hs_voip_ccm_dim_app_callinitiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_callinitiated"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_callwaiting = Module["_hs_voip_ccm_dim_app_callwaiting"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_callwaiting"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_change_codec = Module["_hs_voip_ccm_dim_app_change_codec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_change_codec"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_conn_ack = Module["_hs_voip_ccm_dim_app_conn_ack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_conn_ack"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_connected = Module["_hs_voip_ccm_dim_app_connected"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_connected"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_connected_ring = Module["_hs_voip_ccm_dim_app_connected_ring"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_connected_ring"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_conntd_rsrcwait = Module["_hs_voip_ccm_dim_app_conntd_rsrcwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_conntd_rsrcwait"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_ct_initiated = Module["_hs_voip_ccm_dim_app_ct_initiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_ct_initiated"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_ct_wait = Module["_hs_voip_ccm_dim_app_ct_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_ct_wait"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_ctheld = Module["_hs_voip_ccm_dim_app_ctheld"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_ctheld"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_error = Module["_hs_voip_ccm_dim_app_error"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_error"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_fxo_dialtone = Module["_hs_voip_ccm_dim_app_fxo_dialtone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_fxo_dialtone"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_fxo_ringback_tone = Module["_hs_voip_ccm_dim_app_fxo_ringback_tone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_fxo_ringback_tone"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_held = Module["_hs_voip_ccm_dim_app_held"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_held"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_held_ack = Module["_hs_voip_ccm_dim_app_held_ack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_held_ack"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_held_initiated = Module["_hs_voip_ccm_dim_app_held_initiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_held_initiated"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_held_wait = Module["_hs_voip_ccm_dim_app_held_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_held_wait"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_incoming = Module["_hs_voip_ccm_dim_app_incoming"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_incoming"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_null = Module["_hs_voip_ccm_dim_app_null"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_null"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_offhook = Module["_hs_voip_ccm_dim_app_offhook"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_offhook"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_provisioning = Module["_hs_voip_ccm_dim_app_provisioning"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_provisioning"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_release = Module["_hs_voip_ccm_dim_app_release"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_release"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_rsrcinit = Module["_hs_voip_ccm_dim_app_rsrcinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_rsrcinit"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_update_init = Module["_hs_voip_ccm_dim_app_update_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_update_init"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_update_rcvd = Module["_hs_voip_ccm_dim_app_update_rcvd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_update_rcvd"].apply(null, arguments);
});
var _hs_voip_ccm_dim_app_user_resp = Module["_hs_voip_ccm_dim_app_user_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dim_app_user_resp"].apply(null, arguments);
});
var _hs_voip_ccm_dispatcher = Module["_hs_voip_ccm_dispatcher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_dispatcher"].apply(null, arguments);
});
var _hs_voip_ccm_endpoint_in_use = Module["_hs_voip_ccm_endpoint_in_use"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_endpoint_in_use"].apply(null, arguments);
});
var _hs_voip_ccm_endpoint_start_timer = Module["_hs_voip_ccm_endpoint_start_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_endpoint_start_timer"].apply(null, arguments);
});
var _hs_voip_ccm_endpoint_stop_timer = Module["_hs_voip_ccm_endpoint_stop_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_endpoint_stop_timer"].apply(null, arguments);
});
var _hs_voip_ccm_ep_add_subscpt = Module["_hs_voip_ccm_ep_add_subscpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_add_subscpt"].apply(null, arguments);
});
var _hs_voip_ccm_ep_allow_incomingcall_on_userrelease = Module["_hs_voip_ccm_ep_allow_incomingcall_on_userrelease"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_allow_incomingcall_on_userrelease"].apply(null, arguments);
});
var _hs_voip_ccm_ep_clear_context = Module["_hs_voip_ccm_ep_clear_context"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_clear_context"].apply(null, arguments);
});
var _hs_voip_ccm_ep_create_callobj = Module["_hs_voip_ccm_ep_create_callobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_create_callobj"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_active_or_held_call = Module["_hs_voip_ccm_ep_get_active_or_held_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_active_or_held_call"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_call_count = Module["_hs_voip_ccm_ep_get_call_count"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_call_count"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_callobj = Module["_hs_voip_ccm_ep_get_callobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_callobj"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_callobj_by_dimevent = Module["_hs_voip_ccm_ep_get_callobj_by_dimevent"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_callobj_by_dimevent"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_callwaiting_callobj = Module["_hs_voip_ccm_ep_get_callwaiting_callobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_callwaiting_callobj"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_fxo = Module["_hs_voip_ccm_ep_get_fxo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_fxo"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_subscpt = Module["_hs_voip_ccm_ep_get_subscpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_subscpt"].apply(null, arguments);
});
var _hs_voip_ccm_ep_get_switchcallobj = Module["_hs_voip_ccm_ep_get_switchcallobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_get_switchcallobj"].apply(null, arguments);
});
var _hs_voip_ccm_ep_is_anycall_in_transientstate = Module["_hs_voip_ccm_ep_is_anycall_in_transientstate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_is_anycall_in_transientstate"].apply(null, arguments);
});
var _hs_voip_ccm_ep_is_conf_active = Module["_hs_voip_ccm_ep_is_conf_active"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_is_conf_active"].apply(null, arguments);
});
var _hs_voip_ccm_ep_onhook = Module["_hs_voip_ccm_ep_onhook"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_onhook"].apply(null, arguments);
});
var _hs_voip_ccm_ep_outgoing_call_allowed = Module["_hs_voip_ccm_ep_outgoing_call_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_outgoing_call_allowed"].apply(null, arguments);
});
var _hs_voip_ccm_ep_release_context = Module["_hs_voip_ccm_ep_release_context"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_release_context"].apply(null, arguments);
});
var _hs_voip_ccm_ep_remove_callobj = Module["_hs_voip_ccm_ep_remove_callobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_remove_callobj"].apply(null, arguments);
});
var _hs_voip_ccm_ep_subscpt_free = Module["_hs_voip_ccm_ep_subscpt_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ep_subscpt_free"].apply(null, arguments);
});
var _hs_voip_ccm_evt_msg_copy = Module["_hs_voip_ccm_evt_msg_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_evt_msg_copy"].apply(null, arguments);
});
var _hs_voip_ccm_fill_callerid = Module["_hs_voip_ccm_fill_callerid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_fill_callerid"].apply(null, arguments);
});
var _hs_voip_ccm_fill_faxsdp = Module["_hs_voip_ccm_fill_faxsdp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_fill_faxsdp"].apply(null, arguments);
});
var _hs_voip_ccm_fill_localsdp_callobject = Module["_hs_voip_ccm_fill_localsdp_callobject"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_fill_localsdp_callobject"].apply(null, arguments);
});
var _hs_voip_ccm_fill_sdp = Module["_hs_voip_ccm_fill_sdp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_fill_sdp"].apply(null, arguments);
});
var _hs_voip_ccm_fill_stat_msg = Module["_hs_voip_ccm_fill_stat_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_fill_stat_msg"].apply(null, arguments);
});
var _hs_voip_ccm_forkctx_free = Module["_hs_voip_ccm_forkctx_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_forkctx_free"].apply(null, arguments);
});
var _hs_voip_ccm_free_app_service_message = Module["_hs_voip_ccm_free_app_service_message"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_free_app_service_message"].apply(null, arguments);
});
var _hs_voip_ccm_fwd_incoming_msg = Module["_hs_voip_ccm_fwd_incoming_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_fwd_incoming_msg"].apply(null, arguments);
});
var _hs_voip_ccm_get_call_info = Module["_hs_voip_ccm_get_call_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_call_info"].apply(null, arguments);
});
var _hs_voip_ccm_get_callobj_by_callid = Module["_hs_voip_ccm_get_callobj_by_callid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_callobj_by_callid"].apply(null, arguments);
});
var _hs_voip_ccm_get_callobj_by_replacesid = Module["_hs_voip_ccm_get_callobj_by_replacesid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_callobj_by_replacesid"].apply(null, arguments);
});
var _hs_voip_ccm_get_current_dialog_info = Module["_hs_voip_ccm_get_current_dialog_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_current_dialog_info"].apply(null, arguments);
});
var _hs_voip_ccm_get_dynamic_pt = Module["_hs_voip_ccm_get_dynamic_pt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_dynamic_pt"].apply(null, arguments);
});
var _hs_voip_ccm_get_endpoint_id = Module["_hs_voip_ccm_get_endpoint_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_endpoint_id"].apply(null, arguments);
});
var _hs_voip_ccm_get_epid_by_sipmsg = Module["_hs_voip_ccm_get_epid_by_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_epid_by_sipmsg"].apply(null, arguments);
});
var _hs_voip_ccm_get_epid_from_callid = Module["_hs_voip_ccm_get_epid_from_callid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_epid_from_callid"].apply(null, arguments);
});
var _hs_voip_ccm_get_forkctx_by_forkid = Module["_hs_voip_ccm_get_forkctx_by_forkid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_forkctx_by_forkid"].apply(null, arguments);
});
var _hs_voip_ccm_get_forkctx_by_sipmsg = Module["_hs_voip_ccm_get_forkctx_by_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_forkctx_by_sipmsg"].apply(null, arguments);
});
var _hs_voip_ccm_get_reasonphrse_frm_sipresp = Module["_hs_voip_ccm_get_reasonphrse_frm_sipresp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_reasonphrse_frm_sipresp"].apply(null, arguments);
});
var _hs_voip_ccm_get_state = Module["_hs_voip_ccm_get_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_state"].apply(null, arguments);
});
var _hs_voip_ccm_get_timer_data = Module["_hs_voip_ccm_get_timer_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_timer_data"].apply(null, arguments);
});
var _hs_voip_ccm_get_timerdata_by_type = Module["_hs_voip_ccm_get_timerdata_by_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_timerdata_by_type"].apply(null, arguments);
});
var _hs_voip_ccm_get_updated_p_identity = Module["_hs_voip_ccm_get_updated_p_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_updated_p_identity"].apply(null, arguments);
});
var _hs_voip_ccm_get_updated_privacy_options = Module["_hs_voip_ccm_get_updated_privacy_options"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_get_updated_privacy_options"].apply(null, arguments);
});
var _hs_voip_ccm_handle_call_park_seq = Module["_hs_voip_ccm_handle_call_park_seq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_call_park_seq"].apply(null, arguments);
});
var _hs_voip_ccm_handle_call_pickup_seq = Module["_hs_voip_ccm_handle_call_pickup_seq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_call_pickup_seq"].apply(null, arguments);
});
var _hs_voip_ccm_handle_conference_seq = Module["_hs_voip_ccm_handle_conference_seq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_conference_seq"].apply(null, arguments);
});
var _hs_voip_ccm_handle_ct_seq = Module["_hs_voip_ccm_handle_ct_seq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_ct_seq"].apply(null, arguments);
});
var _hs_voip_ccm_handle_hold_other_call_seq = Module["_hs_voip_ccm_handle_hold_other_call_seq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_hold_other_call_seq"].apply(null, arguments);
});
var _hs_voip_ccm_handle_newcall_seq = Module["_hs_voip_ccm_handle_newcall_seq"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_newcall_seq"].apply(null, arguments);
});
var _hs_voip_ccm_handle_other_call_state = Module["_hs_voip_ccm_handle_other_call_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_other_call_state"].apply(null, arguments);
});
var _hs_voip_ccm_handle_prack = Module["_hs_voip_ccm_handle_prack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_prack"].apply(null, arguments);
});
var _hs_voip_ccm_handle_prack_resp = Module["_hs_voip_ccm_handle_prack_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_prack_resp"].apply(null, arguments);
});
var _hs_voip_ccm_handle_pstocs_hoff_initiated = Module["_hs_voip_ccm_handle_pstocs_hoff_initiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_pstocs_hoff_initiated"].apply(null, arguments);
});
var _hs_voip_ccm_handle_pstops_hoff_initiated = Module["_hs_voip_ccm_handle_pstops_hoff_initiated"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_handle_pstops_hoff_initiated"].apply(null, arguments);
});
var _hs_voip_ccm_held_process_update = Module["_hs_voip_ccm_held_process_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_held_process_update"].apply(null, arguments);
});
var _hs_voip_ccm_held_timer = Module["_hs_voip_ccm_held_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_held_timer"].apply(null, arguments);
});
var _hs_voip_ccm_heldinit_hndle_othercall = Module["_hs_voip_ccm_heldinit_hndle_othercall"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_heldinit_hndle_othercall"].apply(null, arguments);
});
var _hs_voip_ccm_heldinit_process_update_resp = Module["_hs_voip_ccm_heldinit_process_update_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_heldinit_process_update_resp"].apply(null, arguments);
});
var _hs_voip_ccm_hist_cpy_create = Module["_hs_voip_ccm_hist_cpy_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_hist_cpy_create"].apply(null, arguments);
});
var _hs_voip_ccm_histinfo_free = Module["_hs_voip_ccm_histinfo_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_histinfo_free"].apply(null, arguments);
});
var _hs_voip_ccm_histlist_add_localinfo = Module["_hs_voip_ccm_histlist_add_localinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_histlist_add_localinfo"].apply(null, arguments);
});
var _hs_voip_ccm_histlist_copyfrm_sipmsg = Module["_hs_voip_ccm_histlist_copyfrm_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_histlist_copyfrm_sipmsg"].apply(null, arguments);
});
var _hs_voip_ccm_histlist_create = Module["_hs_voip_ccm_histlist_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_histlist_create"].apply(null, arguments);
});
var _hs_voip_ccm_histlist_fill_sipmsg = Module["_hs_voip_ccm_histlist_fill_sipmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_histlist_fill_sipmsg"].apply(null, arguments);
});
var _hs_voip_ccm_ic_proceeding_c002 = Module["_hs_voip_ccm_ic_proceeding_c002"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ic_proceeding_c002"].apply(null, arguments);
});
var _hs_voip_ccm_ic_proceeding_dim_app = Module["_hs_voip_ccm_ic_proceeding_dim_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ic_proceeding_dim_app"].apply(null, arguments);
});
var _hs_voip_ccm_ic_proceeding_timer = Module["_hs_voip_ccm_ic_proceeding_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ic_proceeding_timer"].apply(null, arguments);
});
var _hs_voip_ccm_if_url = Module["_hs_voip_ccm_if_url"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_if_url"].apply(null, arguments);
});
var _hs_voip_ccm_incoming_timer = Module["_hs_voip_ccm_incoming_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_incoming_timer"].apply(null, arguments);
});
var _hs_voip_ccm_incomingcall_actions = Module["_hs_voip_ccm_incomingcall_actions"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_incomingcall_actions"].apply(null, arguments);
});
var _hs_voip_ccm_init = Module["_hs_voip_ccm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_init"].apply(null, arguments);
});
var _hs_voip_ccm_init_neg_sdp = Module["_hs_voip_ccm_init_neg_sdp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_init_neg_sdp"].apply(null, arguments);
});
var _hs_voip_ccm_initiate_disconnect_x = Module["_hs_voip_ccm_initiate_disconnect_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_initiate_disconnect_x"].apply(null, arguments);
});
var _hs_voip_ccm_initiate_new_call = Module["_hs_voip_ccm_initiate_new_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_initiate_new_call"].apply(null, arguments);
});
var _hs_voip_ccm_initiate_new_forward_call = Module["_hs_voip_ccm_initiate_new_forward_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_initiate_new_forward_call"].apply(null, arguments);
});
var _hs_voip_ccm_initiate_transfer = Module["_hs_voip_ccm_initiate_transfer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_initiate_transfer"].apply(null, arguments);
});
var _hs_voip_ccm_initiated_timer = Module["_hs_voip_ccm_initiated_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_initiated_timer"].apply(null, arguments);
});
var _hs_voip_ccm_ins_forkctx = Module["_hs_voip_ccm_ins_forkctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_ins_forkctx"].apply(null, arguments);
});
var _hs_voip_ccm_invreplaces_actions = Module["_hs_voip_ccm_invreplaces_actions"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_invreplaces_actions"].apply(null, arguments);
});
var _hs_voip_ccm_is_barred = Module["_hs_voip_ccm_is_barred"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_is_barred"].apply(null, arguments);
});
var _hs_voip_ccm_is_msging_barred = Module["_hs_voip_ccm_is_msging_barred"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_is_msging_barred"].apply(null, arguments);
});
var _hs_voip_ccm_is_valid_digitmap = Module["_hs_voip_ccm_is_valid_digitmap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_is_valid_digitmap"].apply(null, arguments);
});
var _hs_voip_ccm_match_digits = Module["_hs_voip_ccm_match_digits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_match_digits"].apply(null, arguments);
});
var _hs_voip_ccm_match_uri_pattern = Module["_hs_voip_ccm_match_uri_pattern"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_match_uri_pattern"].apply(null, arguments);
});
var _hs_voip_ccm_mc_connected = Module["_hs_voip_ccm_mc_connected"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_connected"].apply(null, arguments);
});
var _hs_voip_ccm_mc_conntd_rsrcwait = Module["_hs_voip_ccm_mc_conntd_rsrcwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_conntd_rsrcwait"].apply(null, arguments);
});
var _hs_voip_ccm_mc_held_wait = Module["_hs_voip_ccm_mc_held_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_held_wait"].apply(null, arguments);
});
var _hs_voip_ccm_mc_incoming = Module["_hs_voip_ccm_mc_incoming"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_incoming"].apply(null, arguments);
});
var _hs_voip_ccm_mc_rsrcinit = Module["_hs_voip_ccm_mc_rsrcinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_rsrcinit"].apply(null, arguments);
});
var _hs_voip_ccm_mc_send_sipinfo = Module["_hs_voip_ccm_mc_send_sipinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_send_sipinfo"].apply(null, arguments);
});
var _hs_voip_ccm_mc_set_rmtcaps = Module["_hs_voip_ccm_mc_set_rmtcaps"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_set_rmtcaps"].apply(null, arguments);
});
var _hs_voip_ccm_mc_update_rcvd = Module["_hs_voip_ccm_mc_update_rcvd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mc_update_rcvd"].apply(null, arguments);
});
var _hs_voip_ccm_mwi_get_epid_by_subid = Module["_hs_voip_ccm_mwi_get_epid_by_subid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mwi_get_epid_by_subid"].apply(null, arguments);
});
var _hs_voip_ccm_mwi_process_subscpt_ind = Module["_hs_voip_ccm_mwi_process_subscpt_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mwi_process_subscpt_ind"].apply(null, arguments);
});
var _hs_voip_ccm_mwi_process_timermsg = Module["_hs_voip_ccm_mwi_process_timermsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mwi_process_timermsg"].apply(null, arguments);
});
var _hs_voip_ccm_mwi_subscb = Module["_hs_voip_ccm_mwi_subscb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_mwi_subscb"].apply(null, arguments);
});
var _hs_voip_ccm_notifications_from_mc = Module["_hs_voip_ccm_notifications_from_mc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_notifications_from_mc"].apply(null, arguments);
});
var _hs_voip_ccm_nwk_request_allowed = Module["_hs_voip_ccm_nwk_request_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_nwk_request_allowed"].apply(null, arguments);
});
var _hs_voip_ccm_oc_proceeding_c002 = Module["_hs_voip_ccm_oc_proceeding_c002"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_oc_proceeding_c002"].apply(null, arguments);
});
var _hs_voip_ccm_oc_proceeding_dim_app = Module["_hs_voip_ccm_oc_proceeding_dim_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_oc_proceeding_dim_app"].apply(null, arguments);
});
var _hs_voip_ccm_oc_proceeding_timer = Module["_hs_voip_ccm_oc_proceeding_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_oc_proceeding_timer"].apply(null, arguments);
});
var _hs_voip_ccm_offhook_timer = Module["_hs_voip_ccm_offhook_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_offhook_timer"].apply(null, arguments);
});
var _hs_voip_ccm_parse_alertinfo = Module["_hs_voip_ccm_parse_alertinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_parse_alertinfo"].apply(null, arguments);
});
var _hs_voip_ccm_parse_notify_data = Module["_hs_voip_ccm_parse_notify_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_parse_notify_data"].apply(null, arguments);
});
var _hs_voip_ccm_parse_refer_notify = Module["_hs_voip_ccm_parse_refer_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_parse_refer_notify"].apply(null, arguments);
});
var _hs_voip_ccm_parse_rmtsdp_x = Module["_hs_voip_ccm_parse_rmtsdp_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_parse_rmtsdp_x"].apply(null, arguments);
});
var _hs_voip_ccm_parse_sip_frag = Module["_hs_voip_ccm_parse_sip_frag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_parse_sip_frag"].apply(null, arguments);
});
var _hs_voip_ccm_post_to_app = Module["_hs_voip_ccm_post_to_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_post_to_app"].apply(null, arguments);
});
var _hs_voip_ccm_process_alert = Module["_hs_voip_ccm_process_alert"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_alert"].apply(null, arguments);
});
var _hs_voip_ccm_process_app_call_parking = Module["_hs_voip_ccm_process_app_call_parking"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_app_call_parking"].apply(null, arguments);
});
var _hs_voip_ccm_process_app_call_pickup = Module["_hs_voip_ccm_process_app_call_pickup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_app_call_pickup"].apply(null, arguments);
});
var _hs_voip_ccm_process_app_info_req_msg = Module["_hs_voip_ccm_process_app_info_req_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_app_info_req_msg"].apply(null, arguments);
});
var _hs_voip_ccm_process_app_service_request = Module["_hs_voip_ccm_process_app_service_request"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_app_service_request"].apply(null, arguments);
});
var _hs_voip_ccm_process_app_service_response = Module["_hs_voip_ccm_process_app_service_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_app_service_response"].apply(null, arguments);
});
var _hs_voip_ccm_process_appmsg = Module["_hs_voip_ccm_process_appmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_appmsg"].apply(null, arguments);
});
var _hs_voip_ccm_process_c002_outsess = Module["_hs_voip_ccm_process_c002_outsess"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_c002_outsess"].apply(null, arguments);
});
var _hs_voip_ccm_process_c002msg = Module["_hs_voip_ccm_process_c002msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_c002msg"].apply(null, arguments);
});
var _hs_voip_ccm_process_codec_update_resp = Module["_hs_voip_ccm_process_codec_update_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_codec_update_resp"].apply(null, arguments);
});
var _hs_voip_ccm_process_connect = Module["_hs_voip_ccm_process_connect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_connect"].apply(null, arguments);
});
var _hs_voip_ccm_process_digit = Module["_hs_voip_ccm_process_digit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_digit"].apply(null, arguments);
});
var _hs_voip_ccm_process_disconnect = Module["_hs_voip_ccm_process_disconnect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_disconnect"].apply(null, arguments);
});
var _hs_voip_ccm_process_disconnect_callwaiting = Module["_hs_voip_ccm_process_disconnect_callwaiting"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_disconnect_callwaiting"].apply(null, arguments);
});
var _hs_voip_ccm_process_get_cap = Module["_hs_voip_ccm_process_get_cap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_get_cap"].apply(null, arguments);
});
var _hs_voip_ccm_process_im_message = Module["_hs_voip_ccm_process_im_message"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_im_message"].apply(null, arguments);
});
var _hs_voip_ccm_process_im_msg_resp = Module["_hs_voip_ccm_process_im_msg_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_im_msg_resp"].apply(null, arguments);
});
var _hs_voip_ccm_process_info_req_msg = Module["_hs_voip_ccm_process_info_req_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_info_req_msg"].apply(null, arguments);
});
var _hs_voip_ccm_process_info_resp_msg = Module["_hs_voip_ccm_process_info_resp_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_info_resp_msg"].apply(null, arguments);
});
var _hs_voip_ccm_process_invite_with_replaces = Module["_hs_voip_ccm_process_invite_with_replaces"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_invite_with_replaces"].apply(null, arguments);
});
var _hs_voip_ccm_process_logout_response = Module["_hs_voip_ccm_process_logout_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_logout_response"].apply(null, arguments);
});
var _hs_voip_ccm_process_mcmsg = Module["_hs_voip_ccm_process_mcmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_mcmsg"].apply(null, arguments);
});
var _hs_voip_ccm_process_nwkmsg = Module["_hs_voip_ccm_process_nwkmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_nwkmsg"].apply(null, arguments);
});
var _hs_voip_ccm_process_oammsg = Module["_hs_voip_ccm_process_oammsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_oammsg"].apply(null, arguments);
});
var _hs_voip_ccm_process_out_sess_refer = Module["_hs_voip_ccm_process_out_sess_refer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_out_sess_refer"].apply(null, arguments);
});
var _hs_voip_ccm_process_redirect = Module["_hs_voip_ccm_process_redirect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_redirect"].apply(null, arguments);
});
var _hs_voip_ccm_process_refer_notify = Module["_hs_voip_ccm_process_refer_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_refer_notify"].apply(null, arguments);
});
var _hs_voip_ccm_process_refer_resp = Module["_hs_voip_ccm_process_refer_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_refer_resp"].apply(null, arguments);
});
var _hs_voip_ccm_process_retry = Module["_hs_voip_ccm_process_retry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_retry"].apply(null, arguments);
});
var _hs_voip_ccm_process_service_request = Module["_hs_voip_ccm_process_service_request"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_service_request"].apply(null, arguments);
});
var _hs_voip_ccm_process_service_response = Module["_hs_voip_ccm_process_service_response"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_service_response"].apply(null, arguments);
});
var _hs_voip_ccm_process_setup = Module["_hs_voip_ccm_process_setup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_setup"].apply(null, arguments);
});
var _hs_voip_ccm_process_sip_notify_reqst = Module["_hs_voip_ccm_process_sip_notify_reqst"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_sip_notify_reqst"].apply(null, arguments);
});
var _hs_voip_ccm_process_subscpt_ind = Module["_hs_voip_ccm_process_subscpt_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_subscpt_ind"].apply(null, arguments);
});
var _hs_voip_ccm_process_subscptmsg = Module["_hs_voip_ccm_process_subscptmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_subscptmsg"].apply(null, arguments);
});
var _hs_voip_ccm_process_subscription = Module["_hs_voip_ccm_process_subscription"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_subscription"].apply(null, arguments);
});
var _hs_voip_ccm_process_timermsg = Module["_hs_voip_ccm_process_timermsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_timermsg"].apply(null, arguments);
});
var _hs_voip_ccm_process_transfer = Module["_hs_voip_ccm_process_transfer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_transfer"].apply(null, arguments);
});
var _hs_voip_ccm_process_update = Module["_hs_voip_ccm_process_update"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_update"].apply(null, arguments);
});
var _hs_voip_ccm_process_update_session_resp = Module["_hs_voip_ccm_process_update_session_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_process_update_session_resp"].apply(null, arguments);
});
var _hs_voip_ccm_provision_build_callee = Module["_hs_voip_ccm_provision_build_callee"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_build_callee"].apply(null, arguments);
});
var _hs_voip_ccm_provision_compare_digits = Module["_hs_voip_ccm_provision_compare_digits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_compare_digits"].apply(null, arguments);
});
var _hs_voip_ccm_provision_end = Module["_hs_voip_ccm_provision_end"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_end"].apply(null, arguments);
});
var _hs_voip_ccm_provision_fill_feature_codes = Module["_hs_voip_ccm_provision_fill_feature_codes"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_fill_feature_codes"].apply(null, arguments);
});
var _hs_voip_ccm_provision_get_feature_code = Module["_hs_voip_ccm_provision_get_feature_code"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_get_feature_code"].apply(null, arguments);
});
var _hs_voip_ccm_provision_parse_param = Module["_hs_voip_ccm_provision_parse_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_parse_param"].apply(null, arguments);
});
var _hs_voip_ccm_provision_remote_feature_match = Module["_hs_voip_ccm_provision_remote_feature_match"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_remote_feature_match"].apply(null, arguments);
});
var _hs_voip_ccm_provision_set_local_features = Module["_hs_voip_ccm_provision_set_local_features"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provision_set_local_features"].apply(null, arguments);
});
var _hs_voip_ccm_provsion_parse_dailed_digits = Module["_hs_voip_ccm_provsion_parse_dailed_digits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provsion_parse_dailed_digits"].apply(null, arguments);
});
var _hs_voip_ccm_provsion_validate_dailed_digits = Module["_hs_voip_ccm_provsion_validate_dailed_digits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_provsion_validate_dailed_digits"].apply(null, arguments);
});
var _hs_voip_ccm_redirect_node_free = Module["_hs_voip_ccm_redirect_node_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_redirect_node_free"].apply(null, arguments);
});
var _hs_voip_ccm_reject_call_x = Module["_hs_voip_ccm_reject_call_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_reject_call_x"].apply(null, arguments);
});
var _hs_voip_ccm_release_call = Module["_hs_voip_ccm_release_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_release_call"].apply(null, arguments);
});
var _hs_voip_ccm_release_callobj = Module["_hs_voip_ccm_release_callobj"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_release_callobj"].apply(null, arguments);
});
var _hs_voip_ccm_release_fxo_call = Module["_hs_voip_ccm_release_fxo_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_release_fxo_call"].apply(null, arguments);
});
var _hs_voip_ccm_release_oninvalid_prack = Module["_hs_voip_ccm_release_oninvalid_prack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_release_oninvalid_prack"].apply(null, arguments);
});
var _hs_voip_ccm_reset_ep_fhook_action = Module["_hs_voip_ccm_reset_ep_fhook_action"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_reset_ep_fhook_action"].apply(null, arguments);
});
var _hs_voip_ccm_reset_hoff_struct = Module["_hs_voip_ccm_reset_hoff_struct"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_reset_hoff_struct"].apply(null, arguments);
});
var _hs_voip_ccm_respond_to_redirect = Module["_hs_voip_ccm_respond_to_redirect"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_respond_to_redirect"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_derivemedia_mode = Module["_hs_voip_ccm_sdp_derivemedia_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_derivemedia_mode"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_get_ptinfo_byname = Module["_hs_voip_ccm_sdp_get_ptinfo_byname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_get_ptinfo_byname"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_insert_pt_info = Module["_hs_voip_ccm_sdp_insert_pt_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_insert_pt_info"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_is_wb_codec = Module["_hs_voip_ccm_sdp_is_wb_codec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_is_wb_codec"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_ports_per_media_type = Module["_hs_voip_ccm_sdp_ports_per_media_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_ports_per_media_type"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_preconchk_desstren = Module["_hs_voip_ccm_sdp_preconchk_desstren"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_preconchk_desstren"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_replicate_pt_info = Module["_hs_voip_ccm_sdp_replicate_pt_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_replicate_pt_info"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_amr_params = Module["_hs_voip_ccm_sdp_set_amr_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_amr_params"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_evrc_params = Module["_hs_voip_ccm_sdp_set_evrc_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_evrc_params"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_media_ports = Module["_hs_voip_ccm_sdp_set_media_ports"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_media_ports"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_opus_params = Module["_hs_voip_ccm_sdp_set_opus_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_opus_params"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_pt_info = Module["_hs_voip_ccm_sdp_set_pt_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_pt_info"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_redcodec_fmtp_x = Module["_hs_voip_ccm_sdp_set_redcodec_fmtp_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_redcodec_fmtp_x"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_speex_params = Module["_hs_voip_ccm_sdp_set_speex_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_speex_params"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_set_xport_type = Module["_hs_voip_ccm_sdp_set_xport_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_set_xport_type"].apply(null, arguments);
});
var _hs_voip_ccm_sdp_update_rtcpbw = Module["_hs_voip_ccm_sdp_update_rtcpbw"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sdp_update_rtcpbw"].apply(null, arguments);
});
var _hs_voip_ccm_security_settings = Module["_hs_voip_ccm_security_settings"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_security_settings"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_call_parking_ind = Module["_hs_voip_ccm_send_app_call_parking_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_call_parking_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_call_pickup_ind = Module["_hs_voip_ccm_send_app_call_pickup_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_call_pickup_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_call_replaced_ind = Module["_hs_voip_ccm_send_app_call_replaced_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_call_replaced_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_call_status_ind = Module["_hs_voip_ccm_send_app_call_status_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_call_status_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_general_ind = Module["_hs_voip_ccm_send_app_general_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_general_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_im_msg_recvd_ind = Module["_hs_voip_ccm_send_app_im_msg_recvd_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_im_msg_recvd_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_im_msg_resp = Module["_hs_voip_ccm_send_app_im_msg_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_im_msg_resp"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_incoming_call_ind = Module["_hs_voip_ccm_send_app_incoming_call_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_incoming_call_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_indication = Module["_hs_voip_ccm_send_app_indication"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_indication"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_info_sent = Module["_hs_voip_ccm_send_app_info_sent"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_info_sent"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_invalid_request_ind_x = Module["_hs_voip_ccm_send_app_invalid_request_ind_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_invalid_request_ind_x"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_mime_fail_ind = Module["_hs_voip_ccm_send_app_mime_fail_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_mime_fail_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_prov_ind = Module["_hs_voip_ccm_send_app_prov_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_prov_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_refer_notify_ind = Module["_hs_voip_ccm_send_app_refer_notify_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_refer_notify_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_refer_resp_ind = Module["_hs_voip_ccm_send_app_refer_resp_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_refer_resp_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_refer_sent_ind = Module["_hs_voip_ccm_send_app_refer_sent_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_refer_sent_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_rejected_ind = Module["_hs_voip_ccm_send_app_rejected_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_rejected_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_release_ind = Module["_hs_voip_ccm_send_app_release_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_release_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_reqfail_ind_x = Module["_hs_voip_ccm_send_app_reqfail_ind_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_reqfail_ind_x"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_service_info_sent_ind = Module["_hs_voip_ccm_send_app_service_info_sent_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_service_info_sent_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_subscpt_ind = Module["_hs_voip_ccm_send_app_subscpt_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_subscpt_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_switch_call_ind = Module["_hs_voip_ccm_send_app_switch_call_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_switch_call_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_app_transfer_call_ind = Module["_hs_voip_ccm_send_app_transfer_call_ind"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_app_transfer_call_ind"].apply(null, arguments);
});
var _hs_voip_ccm_send_apply_tone_x = Module["_hs_voip_ccm_send_apply_tone_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_apply_tone_x"].apply(null, arguments);
});
var _hs_voip_ccm_send_create_channel = Module["_hs_voip_ccm_send_create_channel"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_create_channel"].apply(null, arguments);
});
var _hs_voip_ccm_send_dtmf_to_mc = Module["_hs_voip_ccm_send_dtmf_to_mc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_dtmf_to_mc"].apply(null, arguments);
});
var _hs_voip_ccm_send_hold_call = Module["_hs_voip_ccm_send_hold_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_hold_call"].apply(null, arguments);
});
var _hs_voip_ccm_send_infomsg = Module["_hs_voip_ccm_send_infomsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_infomsg"].apply(null, arguments);
});
var _hs_voip_ccm_send_mang_media = Module["_hs_voip_ccm_send_mang_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_mang_media"].apply(null, arguments);
});
var _hs_voip_ccm_send_msg_to_mc = Module["_hs_voip_ccm_send_msg_to_mc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_msg_to_mc"].apply(null, arguments);
});
var _hs_voip_ccm_send_neg_refer_notify = Module["_hs_voip_ccm_send_neg_refer_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_neg_refer_notify"].apply(null, arguments);
});
var _hs_voip_ccm_send_neg_update_resp_x = Module["_hs_voip_ccm_send_neg_update_resp_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_neg_update_resp_x"].apply(null, arguments);
});
var _hs_voip_ccm_send_notifier_status = Module["_hs_voip_ccm_send_notifier_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_notifier_status"].apply(null, arguments);
});
var _hs_voip_ccm_send_refer_notify = Module["_hs_voip_ccm_send_refer_notify"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_refer_notify"].apply(null, arguments);
});
var _hs_voip_ccm_send_refer_resp = Module["_hs_voip_ccm_send_refer_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_refer_resp"].apply(null, arguments);
});
var _hs_voip_ccm_send_refer_to_sip = Module["_hs_voip_ccm_send_refer_to_sip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_refer_to_sip"].apply(null, arguments);
});
var _hs_voip_ccm_send_release_channel = Module["_hs_voip_ccm_send_release_channel"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_release_channel"].apply(null, arguments);
});
var _hs_voip_ccm_send_reset_im_info = Module["_hs_voip_ccm_send_reset_im_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_reset_im_info"].apply(null, arguments);
});
var _hs_voip_ccm_send_service_response_to_sip = Module["_hs_voip_ccm_send_service_response_to_sip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_service_response_to_sip"].apply(null, arguments);
});
var _hs_voip_ccm_send_session_refresh = Module["_hs_voip_ccm_send_session_refresh"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_session_refresh"].apply(null, arguments);
});
var _hs_voip_ccm_send_setupmsg = Module["_hs_voip_ccm_send_setupmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_setupmsg"].apply(null, arguments);
});
var _hs_voip_ccm_send_sip_im_msg_resp = Module["_hs_voip_ccm_send_sip_im_msg_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_sip_im_msg_resp"].apply(null, arguments);
});
var _hs_voip_ccm_send_sip_info_resp_msg = Module["_hs_voip_ccm_send_sip_info_resp_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_sip_info_resp_msg"].apply(null, arguments);
});
var _hs_voip_ccm_send_sip_notify_resp = Module["_hs_voip_ccm_send_sip_notify_resp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_sip_notify_resp"].apply(null, arguments);
});
var _hs_voip_ccm_send_sip_release_x = Module["_hs_voip_ccm_send_sip_release_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_sip_release_x"].apply(null, arguments);
});
var _hs_voip_ccm_send_start_conference = Module["_hs_voip_ccm_send_start_conference"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_start_conference"].apply(null, arguments);
});
var _hs_voip_ccm_send_start_transcode = Module["_hs_voip_ccm_send_start_transcode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_start_transcode"].apply(null, arguments);
});
var _hs_voip_ccm_send_stop_conference = Module["_hs_voip_ccm_send_stop_conference"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_stop_conference"].apply(null, arguments);
});
var _hs_voip_ccm_send_stop_media = Module["_hs_voip_ccm_send_stop_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_stop_media"].apply(null, arguments);
});
var _hs_voip_ccm_send_stop_tone = Module["_hs_voip_ccm_send_stop_tone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_stop_tone"].apply(null, arguments);
});
var _hs_voip_ccm_send_stop_transcode = Module["_hs_voip_ccm_send_stop_transcode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_stop_transcode"].apply(null, arguments);
});
var _hs_voip_ccm_send_subscript_for_callpickup = Module["_hs_voip_ccm_send_subscript_for_callpickup"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_subscript_for_callpickup"].apply(null, arguments);
});
var _hs_voip_ccm_send_unhold_call = Module["_hs_voip_ccm_send_unhold_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_unhold_call"].apply(null, arguments);
});
var _hs_voip_ccm_send_vmwi_data_to_mc = Module["_hs_voip_ccm_send_vmwi_data_to_mc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_send_vmwi_data_to_mc"].apply(null, arguments);
});
var _hs_voip_ccm_sendto_app = Module["_hs_voip_ccm_sendto_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sendto_app"].apply(null, arguments);
});
var _hs_voip_ccm_sendto_c002 = Module["_hs_voip_ccm_sendto_c002"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sendto_c002"].apply(null, arguments);
});
var _hs_voip_ccm_set_cfmap = Module["_hs_voip_ccm_set_cfmap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_set_cfmap"].apply(null, arguments);
});
var _hs_voip_ccm_set_codec_info = Module["_hs_voip_ccm_set_codec_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_set_codec_info"].apply(null, arguments);
});
var _hs_voip_ccm_set_ep_fhook_action = Module["_hs_voip_ccm_set_ep_fhook_action"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_set_ep_fhook_action"].apply(null, arguments);
});
var _hs_voip_ccm_set_local_sdp_version = Module["_hs_voip_ccm_set_local_sdp_version"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_set_local_sdp_version"].apply(null, arguments);
});
var _hs_voip_ccm_set_sdp_params = Module["_hs_voip_ccm_set_sdp_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_set_sdp_params"].apply(null, arguments);
});
var _hs_voip_ccm_set_state = Module["_hs_voip_ccm_set_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_set_state"].apply(null, arguments);
});
var _hs_voip_ccm_shutdown = Module["_hs_voip_ccm_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_shutdown"].apply(null, arguments);
});
var _hs_voip_ccm_sip_addto_content = Module["_hs_voip_ccm_sip_addto_content"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sip_addto_content"].apply(null, arguments);
});
var _hs_voip_ccm_sip_cb = Module["_hs_voip_ccm_sip_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sip_cb"].apply(null, arguments);
});
var _hs_voip_ccm_sip_send_alert_x = Module["_hs_voip_ccm_sip_send_alert_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sip_send_alert_x"].apply(null, arguments);
});
var _hs_voip_ccm_sip_send_update_x = Module["_hs_voip_ccm_sip_send_update_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sip_send_update_x"].apply(null, arguments);
});
var _hs_voip_ccm_sip_send_updateresp = Module["_hs_voip_ccm_sip_send_updateresp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_sip_send_updateresp"].apply(null, arguments);
});
var _hs_voip_ccm_start = Module["_hs_voip_ccm_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_start"].apply(null, arguments);
});
var _hs_voip_ccm_start_ep_timer = Module["_hs_voip_ccm_start_ep_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_start_ep_timer"].apply(null, arguments);
});
var _hs_voip_ccm_start_service_timer = Module["_hs_voip_ccm_start_service_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_start_service_timer"].apply(null, arguments);
});
var _hs_voip_ccm_start_timer_x = Module["_hs_voip_ccm_start_timer_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_start_timer_x"].apply(null, arguments);
});
var _hs_voip_ccm_stop = Module["_hs_voip_ccm_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_stop"].apply(null, arguments);
});
var _hs_voip_ccm_stop_callwaiting = Module["_hs_voip_ccm_stop_callwaiting"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_stop_callwaiting"].apply(null, arguments);
});
var _hs_voip_ccm_stop_ep_timer = Module["_hs_voip_ccm_stop_ep_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_stop_ep_timer"].apply(null, arguments);
});
var _hs_voip_ccm_stop_timer_x = Module["_hs_voip_ccm_stop_timer_x"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_stop_timer_x"].apply(null, arguments);
});
var _hs_voip_ccm_store_cur_req = Module["_hs_voip_ccm_store_cur_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_store_cur_req"].apply(null, arguments);
});
var _hs_voip_ccm_subscpt_callbk = Module["_hs_voip_ccm_subscpt_callbk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_subscpt_callbk"].apply(null, arguments);
});
var _hs_voip_ccm_switch_call = Module["_hs_voip_ccm_switch_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_switch_call"].apply(null, arguments);
});
var _hs_voip_ccm_update_answer_sdp = Module["_hs_voip_ccm_update_answer_sdp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_update_answer_sdp"].apply(null, arguments);
});
var _hs_voip_ccm_update_call_type = Module["_hs_voip_ccm_update_call_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_update_call_type"].apply(null, arguments);
});
var _hs_voip_ccm_update_local_sdp_version = Module["_hs_voip_ccm_update_local_sdp_version"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_update_local_sdp_version"].apply(null, arguments);
});
var _hs_voip_ccm_update_rmt_early_media_mode = Module["_hs_voip_ccm_update_rmt_early_media_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_update_rmt_early_media_mode"].apply(null, arguments);
});
var _hs_voip_ccm_update_sdp_codec_modes = Module["_hs_voip_ccm_update_sdp_codec_modes"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_update_sdp_codec_modes"].apply(null, arguments);
});
var _hs_voip_ccm_update_sdp_for_hold = Module["_hs_voip_ccm_update_sdp_for_hold"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_update_sdp_for_hold"].apply(null, arguments);
});
var _hs_voip_ccm_update_sess_conn_addr = Module["_hs_voip_ccm_update_sess_conn_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_update_sess_conn_addr"].apply(null, arguments);
});
var _hs_voip_ccm_validate_callee_from_app = Module["_hs_voip_ccm_validate_callee_from_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_validate_callee_from_app"].apply(null, arguments);
});
var _hs_voip_ccm_validate_caller_from_app = Module["_hs_voip_ccm_validate_caller_from_app"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_validate_caller_from_app"].apply(null, arguments);
});
var _hs_voip_ccm_validate_content = Module["_hs_voip_ccm_validate_content"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_validate_content"].apply(null, arguments);
});
var _hs_voip_ccm_validate_incoming_msg = Module["_hs_voip_ccm_validate_incoming_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_validate_incoming_msg"].apply(null, arguments);
});
var _hs_voip_ccm_validate_language = Module["_hs_voip_ccm_validate_language"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_validate_language"].apply(null, arguments);
});
var _hs_voip_ccm_validate_make_call = Module["_hs_voip_ccm_validate_make_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_validate_make_call"].apply(null, arguments);
});
var _hs_voip_ccm_verify_hoff_state = Module["_hs_voip_ccm_verify_hoff_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_verify_hoff_state"].apply(null, arguments);
});
var _hs_voip_ccm_vmwi_hndle_offhook = Module["_hs_voip_ccm_vmwi_hndle_offhook"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_vmwi_hndle_offhook"].apply(null, arguments);
});
var _hs_voip_ccm_vmwi_hndle_onhook = Module["_hs_voip_ccm_vmwi_hndle_onhook"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_vmwi_hndle_onhook"].apply(null, arguments);
});
var _hs_voip_ccm_warn_othercall = Module["_hs_voip_ccm_warn_othercall"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccm_warn_othercall"].apply(null, arguments);
});
var _hs_voip_ccn_conntd_hndle_hold_reqst = Module["_hs_voip_ccn_conntd_hndle_hold_reqst"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_ccn_conntd_hndle_hold_reqst"].apply(null, arguments);
});
var _hs_voip_clean_profile = Module["_hs_voip_clean_profile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_clean_profile"].apply(null, arguments);
});
var _hs_voip_cm_add_digit_map = Module["_hs_voip_cm_add_digit_map"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_add_digit_map"].apply(null, arguments);
});
var _hs_voip_cm_add_emergency_num = Module["_hs_voip_cm_add_emergency_num"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_add_emergency_num"].apply(null, arguments);
});
var _hs_voip_cm_amrnb_set_crc = Module["_hs_voip_cm_amrnb_set_crc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_amrnb_set_crc"].apply(null, arguments);
});
var _hs_voip_cm_build_ip_addr = Module["_hs_voip_cm_build_ip_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_build_ip_addr"].apply(null, arguments);
});
var _hs_voip_cm_cget_nw_mprofile = Module["_hs_voip_cm_cget_nw_mprofile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_cget_nw_mprofile"].apply(null, arguments);
});
var _hs_voip_cm_cget_sipext_hdrs = Module["_hs_voip_cm_cget_sipext_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_cget_sipext_hdrs"].apply(null, arguments);
});
var _hs_voip_cm_cget_strlist = Module["_hs_voip_cm_cget_strlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_cget_strlist"].apply(null, arguments);
});
var _hs_voip_cm_cget_strparam = Module["_hs_voip_cm_cget_strparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_cget_strparam"].apply(null, arguments);
});
var _hs_voip_cm_check_unsolicited_notify_event = Module["_hs_voip_cm_check_unsolicited_notify_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_check_unsolicited_notify_event"].apply(null, arguments);
});
var _hs_voip_cm_clean = Module["_hs_voip_cm_clean"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_clean"].apply(null, arguments);
});
var _hs_voip_cm_create_instanceid = Module["_hs_voip_cm_create_instanceid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_create_instanceid"].apply(null, arguments);
});
var _hs_voip_cm_del_all_emergency_nums = Module["_hs_voip_cm_del_all_emergency_nums"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_del_all_emergency_nums"].apply(null, arguments);
});
var _hs_voip_cm_del_digit_map = Module["_hs_voip_cm_del_digit_map"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_del_digit_map"].apply(null, arguments);
});
var _hs_voip_cm_del_emergency_num = Module["_hs_voip_cm_del_emergency_num"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_del_emergency_num"].apply(null, arguments);
});
var _hs_voip_cm_del_nw_adaptor_list = Module["_hs_voip_cm_del_nw_adaptor_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_del_nw_adaptor_list"].apply(null, arguments);
});
var _hs_voip_cm_del_nw_adaptor_list_elmt = Module["_hs_voip_cm_del_nw_adaptor_list_elmt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_del_nw_adaptor_list_elmt"].apply(null, arguments);
});
var _hs_voip_cm_ep_alias_add_entry = Module["_hs_voip_cm_ep_alias_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_alias_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_alias = Module["_hs_voip_cm_ep_get_alias"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_alias"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_alias_len = Module["_hs_voip_cm_ep_get_alias_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_alias_len"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_curr_adpt = Module["_hs_voip_cm_ep_get_curr_adpt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_curr_adpt"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_incoming_rejectlist = Module["_hs_voip_cm_ep_get_incoming_rejectlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_incoming_rejectlist"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_outgoing_rejectlist = Module["_hs_voip_cm_ep_get_outgoing_rejectlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_outgoing_rejectlist"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_privacy_levels = Module["_hs_voip_cm_ep_get_privacy_levels"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_privacy_levels"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_privacylevels_len = Module["_hs_voip_cm_ep_get_privacylevels_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_privacylevels_len"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_reject_list_len = Module["_hs_voip_cm_ep_get_reject_list_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_reject_list_len"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_remote_features = Module["_hs_voip_cm_ep_get_remote_features"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_remote_features"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_remotefeatures_len = Module["_hs_voip_cm_ep_get_remotefeatures_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_remotefeatures_len"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_ringback_list = Module["_hs_voip_cm_ep_get_ringback_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_ringback_list"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_ringing_list = Module["_hs_voip_cm_ep_get_ringing_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_ringing_list"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_sms_gateway_uri = Module["_hs_voip_cm_ep_get_sms_gateway_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_sms_gateway_uri"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_speed_dial_uri = Module["_hs_voip_cm_ep_get_speed_dial_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_speed_dial_uri"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_speed_dials = Module["_hs_voip_cm_ep_get_speed_dials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_speed_dials"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_speed_dials_len = Module["_hs_voip_cm_ep_get_speed_dials_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_speed_dials_len"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_suppserv_addr = Module["_hs_voip_cm_ep_get_suppserv_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_suppserv_addr"].apply(null, arguments);
});
var _hs_voip_cm_ep_get_tonefiles_len = Module["_hs_voip_cm_ep_get_tonefiles_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_get_tonefiles_len"].apply(null, arguments);
});
var _hs_voip_cm_ep_privacylevels_add_entry = Module["_hs_voip_cm_ep_privacylevels_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_privacylevels_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_privacylevels_del_entry = Module["_hs_voip_cm_ep_privacylevels_del_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_privacylevels_del_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_rejlist_add_entry = Module["_hs_voip_cm_ep_rejlist_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_rejlist_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_rejlist_del_entry = Module["_hs_voip_cm_ep_rejlist_del_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_rejlist_del_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_remotefeatures_add_entry = Module["_hs_voip_cm_ep_remotefeatures_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_remotefeatures_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_alias = Module["_hs_voip_cm_ep_set_alias"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_alias"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_rejlist = Module["_hs_voip_cm_ep_set_rejlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_rejlist"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_remote_features = Module["_hs_voip_cm_ep_set_remote_features"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_remote_features"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_sms_encoding_type = Module["_hs_voip_cm_ep_set_sms_encoding_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_sms_encoding_type"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_sms_fail_maxnumretrnsms = Module["_hs_voip_cm_ep_set_sms_fail_maxnumretrnsms"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_sms_fail_maxnumretrnsms"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_sms_gateway_number = Module["_hs_voip_cm_ep_set_sms_gateway_number"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_sms_gateway_number"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_sms_gateway_uri = Module["_hs_voip_cm_ep_set_sms_gateway_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_sms_gateway_uri"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_sms_report_options = Module["_hs_voip_cm_ep_set_sms_report_options"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_sms_report_options"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_sms_request_reply_path = Module["_hs_voip_cm_ep_set_sms_request_reply_path"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_sms_request_reply_path"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_speed_dial_numbers = Module["_hs_voip_cm_ep_set_speed_dial_numbers"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_speed_dial_numbers"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_suppserv_addr = Module["_hs_voip_cm_ep_set_suppserv_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_suppserv_addr"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_tonefiles = Module["_hs_voip_cm_ep_set_tonefiles"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_tonefiles"].apply(null, arguments);
});
var _hs_voip_cm_ep_set_use_sipurl_is637 = Module["_hs_voip_cm_ep_set_use_sipurl_is637"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_set_use_sipurl_is637"].apply(null, arguments);
});
var _hs_voip_cm_ep_speed_dials_add_entry = Module["_hs_voip_cm_ep_speed_dials_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_speed_dials_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_tonefiles_add_entry = Module["_hs_voip_cm_ep_tonefiles_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_tonefiles_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_ep_tonefiles_del_entry = Module["_hs_voip_cm_ep_tonefiles_del_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ep_tonefiles_del_entry"].apply(null, arguments);
});
var _hs_voip_cm_free_otherparam = Module["_hs_voip_cm_free_otherparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_free_otherparam"].apply(null, arguments);
});
var _hs_voip_cm_generate_digitmap_sm = Module["_hs_voip_cm_generate_digitmap_sm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_generate_digitmap_sm"].apply(null, arguments);
});
var _hs_voip_cm_get_accept_contact = Module["_hs_voip_cm_get_accept_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_accept_contact"].apply(null, arguments);
});
var _hs_voip_cm_get_always_use_outbound_proxy_flag = Module["_hs_voip_cm_get_always_use_outbound_proxy_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_always_use_outbound_proxy_flag"].apply(null, arguments);
});
var _hs_voip_cm_get_amr_modeset_values = Module["_hs_voip_cm_get_amr_modeset_values"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_amr_modeset_values"].apply(null, arguments);
});
var _hs_voip_cm_get_aor_by_associated_id = Module["_hs_voip_cm_get_aor_by_associated_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_aor_by_associated_id"].apply(null, arguments);
});
var _hs_voip_cm_get_aorlist_byifname = Module["_hs_voip_cm_get_aorlist_byifname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_aorlist_byifname"].apply(null, arguments);
});
var _hs_voip_cm_get_call_park_uri = Module["_hs_voip_cm_get_call_park_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_call_park_uri"].apply(null, arguments);
});
var _hs_voip_cm_get_codec_match = Module["_hs_voip_cm_get_codec_match"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_codec_match"].apply(null, arguments);
});
var _hs_voip_cm_get_codec_media_type = Module["_hs_voip_cm_get_codec_media_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_codec_media_type"].apply(null, arguments);
});
var _hs_voip_cm_get_codec_mode = Module["_hs_voip_cm_get_codec_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_codec_mode"].apply(null, arguments);
});
var _hs_voip_cm_get_codec_mode_by_codec = Module["_hs_voip_cm_get_codec_mode_by_codec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_codec_mode_by_codec"].apply(null, arguments);
});
var _hs_voip_cm_get_codec_name = Module["_hs_voip_cm_get_codec_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_codec_name"].apply(null, arguments);
});
var _hs_voip_cm_get_codec_power = Module["_hs_voip_cm_get_codec_power"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_codec_power"].apply(null, arguments);
});
var _hs_voip_cm_get_codec_type = Module["_hs_voip_cm_get_codec_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_codec_type"].apply(null, arguments);
});
var _hs_voip_cm_get_conference_uri = Module["_hs_voip_cm_get_conference_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_conference_uri"].apply(null, arguments);
});
var _hs_voip_cm_get_default_domain_param = Module["_hs_voip_cm_get_default_domain_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_default_domain_param"].apply(null, arguments);
});
var _hs_voip_cm_get_dns_data = Module["_hs_voip_cm_get_dns_data"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_dns_data"].apply(null, arguments);
});
var _hs_voip_cm_get_domain_name = Module["_hs_voip_cm_get_domain_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_domain_name"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_asserted_identity = Module["_hs_voip_cm_get_ep_asserted_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_asserted_identity"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_device_name = Module["_hs_voip_cm_get_ep_device_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_device_name"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_fax_params = Module["_hs_voip_cm_get_ep_fax_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_fax_params"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_id = Module["_hs_voip_cm_get_ep_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_id"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_ifaddr = Module["_hs_voip_cm_get_ep_ifaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_ifaddr"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_secure_outbound_list = Module["_hs_voip_cm_get_ep_secure_outbound_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_secure_outbound_list"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_secure_outbound_proxy = Module["_hs_voip_cm_get_ep_secure_outbound_proxy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_secure_outbound_proxy"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_sip_password = Module["_hs_voip_cm_get_ep_sip_password"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_sip_password"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_sip_proxy = Module["_hs_voip_cm_get_ep_sip_proxy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_sip_proxy"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_sip_proxy_list = Module["_hs_voip_cm_get_ep_sip_proxy_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_sip_proxy_list"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_sip_registrar = Module["_hs_voip_cm_get_ep_sip_registrar"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_sip_registrar"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_t38_fax_encoding_methods = Module["_hs_voip_cm_get_ep_t38_fax_encoding_methods"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_t38_fax_encoding_methods"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_user_name = Module["_hs_voip_cm_get_ep_user_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_user_name"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_xcap_password = Module["_hs_voip_cm_get_ep_xcap_password"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_xcap_password"].apply(null, arguments);
});
var _hs_voip_cm_get_ep_xcap_user_name = Module["_hs_voip_cm_get_ep_xcap_user_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ep_xcap_user_name"].apply(null, arguments);
});
var _hs_voip_cm_get_epid_by_ifname = Module["_hs_voip_cm_get_epid_by_ifname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_epid_by_ifname"].apply(null, arguments);
});
var _hs_voip_cm_get_fec_schemes = Module["_hs_voip_cm_get_fec_schemes"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_fec_schemes"].apply(null, arguments);
});
var _hs_voip_cm_get_filter_feature_key = Module["_hs_voip_cm_get_filter_feature_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_filter_feature_key"].apply(null, arguments);
});
var _hs_voip_cm_get_instanceid = Module["_hs_voip_cm_get_instanceid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_instanceid"].apply(null, arguments);
});
var _hs_voip_cm_get_intparam = Module["_hs_voip_cm_get_intparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_intparam"].apply(null, arguments);
});
var _hs_voip_cm_get_ip_address = Module["_hs_voip_cm_get_ip_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ip_address"].apply(null, arguments);
});
var _hs_voip_cm_get_ipaddr_byaor = Module["_hs_voip_cm_get_ipaddr_byaor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ipaddr_byaor"].apply(null, arguments);
});
var _hs_voip_cm_get_ipv4_address = Module["_hs_voip_cm_get_ipv4_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ipv4_address"].apply(null, arguments);
});
var _hs_voip_cm_get_mandatory_security_flag = Module["_hs_voip_cm_get_mandatory_security_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_mandatory_security_flag"].apply(null, arguments);
});
var _hs_voip_cm_get_mwi_server = Module["_hs_voip_cm_get_mwi_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_mwi_server"].apply(null, arguments);
});
var _hs_voip_cm_get_nat_ip = Module["_hs_voip_cm_get_nat_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_nat_ip"].apply(null, arguments);
});
var _hs_voip_cm_get_nattype_by_adptname = Module["_hs_voip_cm_get_nattype_by_adptname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_nattype_by_adptname"].apply(null, arguments);
});
var _hs_voip_cm_get_nelmts = Module["_hs_voip_cm_get_nelmts"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_nelmts"].apply(null, arguments);
});
var _hs_voip_cm_get_ntp_server_ip = Module["_hs_voip_cm_get_ntp_server_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ntp_server_ip"].apply(null, arguments);
});
var _hs_voip_cm_get_nwk_serv_cap = Module["_hs_voip_cm_get_nwk_serv_cap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_nwk_serv_cap"].apply(null, arguments);
});
var _hs_voip_cm_get_nwprofiles_len = Module["_hs_voip_cm_get_nwprofiles_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_nwprofiles_len"].apply(null, arguments);
});
var _hs_voip_cm_get_otherparam_type = Module["_hs_voip_cm_get_otherparam_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_otherparam_type"].apply(null, arguments);
});
var _hs_voip_cm_get_pacc_nwkinfo = Module["_hs_voip_cm_get_pacc_nwkinfo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_pacc_nwkinfo"].apply(null, arguments);
});
var _hs_voip_cm_get_payload_type = Module["_hs_voip_cm_get_payload_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_payload_type"].apply(null, arguments);
});
var _hs_voip_cm_get_phone_context = Module["_hs_voip_cm_get_phone_context"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_phone_context"].apply(null, arguments);
});
var _hs_voip_cm_get_prebuilt_route_len = Module["_hs_voip_cm_get_prebuilt_route_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_prebuilt_route_len"].apply(null, arguments);
});
var _hs_voip_cm_get_prebuilt_route_set = Module["_hs_voip_cm_get_prebuilt_route_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_prebuilt_route_set"].apply(null, arguments);
});
var _hs_voip_cm_get_preferred_codecs = Module["_hs_voip_cm_get_preferred_codecs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_preferred_codecs"].apply(null, arguments);
});
var _hs_voip_cm_get_primary_dns_server = Module["_hs_voip_cm_get_primary_dns_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_primary_dns_server"].apply(null, arguments);
});
var _hs_voip_cm_get_prov_serv_cap = Module["_hs_voip_cm_get_prov_serv_cap"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_prov_serv_cap"].apply(null, arguments);
});
var _hs_voip_cm_get_proxy_outbound_flag = Module["_hs_voip_cm_get_proxy_outbound_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_proxy_outbound_flag"].apply(null, arguments);
});
var _hs_voip_cm_get_prtyscan_info = Module["_hs_voip_cm_get_prtyscan_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_prtyscan_info"].apply(null, arguments);
});
var _hs_voip_cm_get_push_capabilities = Module["_hs_voip_cm_get_push_capabilities"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_push_capabilities"].apply(null, arguments);
});
var _hs_voip_cm_get_push_params = Module["_hs_voip_cm_get_push_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_push_params"].apply(null, arguments);
});
var _hs_voip_cm_get_realm_credentials = Module["_hs_voip_cm_get_realm_credentials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_realm_credentials"].apply(null, arguments);
});
var _hs_voip_cm_get_reject_contact = Module["_hs_voip_cm_get_reject_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_reject_contact"].apply(null, arguments);
});
var _hs_voip_cm_get_req_disposition = Module["_hs_voip_cm_get_req_disposition"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_req_disposition"].apply(null, arguments);
});
var _hs_voip_cm_get_secondary_dns_server = Module["_hs_voip_cm_get_secondary_dns_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_secondary_dns_server"].apply(null, arguments);
});
var _hs_voip_cm_get_secure_outbound_proxy = Module["_hs_voip_cm_get_secure_outbound_proxy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_secure_outbound_proxy"].apply(null, arguments);
});
var _hs_voip_cm_get_servcap_tag = Module["_hs_voip_cm_get_servcap_tag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_servcap_tag"].apply(null, arguments);
});
var _hs_voip_cm_get_servcap_type = Module["_hs_voip_cm_get_servcap_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_servcap_type"].apply(null, arguments);
});
var _hs_voip_cm_get_sip_algdetect_server = Module["_hs_voip_cm_get_sip_algdetect_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_sip_algdetect_server"].apply(null, arguments);
});
var _hs_voip_cm_get_sip_password = Module["_hs_voip_cm_get_sip_password"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_sip_password"].apply(null, arguments);
});
var _hs_voip_cm_get_sip_privacy_levels = Module["_hs_voip_cm_get_sip_privacy_levels"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_sip_privacy_levels"].apply(null, arguments);
});
var _hs_voip_cm_get_sip_proxy = Module["_hs_voip_cm_get_sip_proxy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_sip_proxy"].apply(null, arguments);
});
var _hs_voip_cm_get_sip_proxy_list = Module["_hs_voip_cm_get_sip_proxy_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_sip_proxy_list"].apply(null, arguments);
});
var _hs_voip_cm_get_sip_registrar = Module["_hs_voip_cm_get_sip_registrar"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_sip_registrar"].apply(null, arguments);
});
var _hs_voip_cm_get_smime_encrypt_algrthms = Module["_hs_voip_cm_get_smime_encrypt_algrthms"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_smime_encrypt_algrthms"].apply(null, arguments);
});
var _hs_voip_cm_get_smime_hdrs = Module["_hs_voip_cm_get_smime_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_smime_hdrs"].apply(null, arguments);
});
var _hs_voip_cm_get_smime_hdrs_len = Module["_hs_voip_cm_get_smime_hdrs_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_smime_hdrs_len"].apply(null, arguments);
});
var _hs_voip_cm_get_smime_mac = Module["_hs_voip_cm_get_smime_mac"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_smime_mac"].apply(null, arguments);
});
var _hs_voip_cm_get_speex_modeset_values = Module["_hs_voip_cm_get_speex_modeset_values"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_speex_modeset_values"].apply(null, arguments);
});
var _hs_voip_cm_get_speex_vbr_value = Module["_hs_voip_cm_get_speex_vbr_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_speex_vbr_value"].apply(null, arguments);
});
var _hs_voip_cm_get_stun_server = Module["_hs_voip_cm_get_stun_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_stun_server"].apply(null, arguments);
});
var _hs_voip_cm_get_tls_cipher = Module["_hs_voip_cm_get_tls_cipher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_tls_cipher"].apply(null, arguments);
});
var _hs_voip_cm_get_tls_kx = Module["_hs_voip_cm_get_tls_kx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_tls_kx"].apply(null, arguments);
});
var _hs_voip_cm_get_tls_mac = Module["_hs_voip_cm_get_tls_mac"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_tls_mac"].apply(null, arguments);
});
var _hs_voip_cm_get_tls_secure_protocol = Module["_hs_voip_cm_get_tls_secure_protocol"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_tls_secure_protocol"].apply(null, arguments);
});
var _hs_voip_cm_get_turn_server = Module["_hs_voip_cm_get_turn_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_turn_server"].apply(null, arguments);
});
var _hs_voip_cm_get_ua_capabilities = Module["_hs_voip_cm_get_ua_capabilities"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_ua_capabilities"].apply(null, arguments);
});
var _hs_voip_cm_get_unsolicited_events_len = Module["_hs_voip_cm_get_unsolicited_events_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_unsolicited_events_len"].apply(null, arguments);
});
var _hs_voip_cm_get_unsolicited_notify_event = Module["_hs_voip_cm_get_unsolicited_notify_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_unsolicited_notify_event"].apply(null, arguments);
});
var _hs_voip_cm_get_usable_codec_media_type = Module["_hs_voip_cm_get_usable_codec_media_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_usable_codec_media_type"].apply(null, arguments);
});
var _hs_voip_cm_get_usable_codecs = Module["_hs_voip_cm_get_usable_codecs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_usable_codecs"].apply(null, arguments);
});
var _hs_voip_cm_get_user_agent_name = Module["_hs_voip_cm_get_user_agent_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_user_agent_name"].apply(null, arguments);
});
var _hs_voip_cm_get_user_name = Module["_hs_voip_cm_get_user_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_user_name"].apply(null, arguments);
});
var _hs_voip_cm_get_values_list = Module["_hs_voip_cm_get_values_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_values_list"].apply(null, arguments);
});
var _hs_voip_cm_get_viability_server = Module["_hs_voip_cm_get_viability_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_get_viability_server"].apply(null, arguments);
});
var _hs_voip_cm_handling_for_telno = Module["_hs_voip_cm_handling_for_telno"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_handling_for_telno"].apply(null, arguments);
});
var _hs_voip_cm_init = Module["_hs_voip_cm_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_init"].apply(null, arguments);
});
var _hs_voip_cm_ins_otherparam = Module["_hs_voip_cm_ins_otherparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_ins_otherparam"].apply(null, arguments);
});
var _hs_voip_cm_is_config_changed = Module["_hs_voip_cm_is_config_changed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_is_config_changed"].apply(null, arguments);
});
var _hs_voip_cm_is_valid_ep = Module["_hs_voip_cm_is_valid_ep"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_is_valid_ep"].apply(null, arguments);
});
var _hs_voip_cm_moderate_transports = Module["_hs_voip_cm_moderate_transports"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_moderate_transports"].apply(null, arguments);
});
var _hs_voip_cm_nwprofs_add_entry = Module["_hs_voip_cm_nwprofs_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_nwprofs_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_other_get_param = Module["_hs_voip_cm_other_get_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_other_get_param"].apply(null, arguments);
});
var _hs_voip_cm_parse_number_method = Module["_hs_voip_cm_parse_number_method"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_parse_number_method"].apply(null, arguments);
});
var _hs_voip_cm_prebuilt_route_add_entry = Module["_hs_voip_cm_prebuilt_route_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_prebuilt_route_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_read_config = Module["_hs_voip_cm_read_config"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_read_config"].apply(null, arguments);
});
var _hs_voip_cm_read_digitmap_list = Module["_hs_voip_cm_read_digitmap_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_read_digitmap_list"].apply(null, arguments);
});
var _hs_voip_cm_reset_hot_line = Module["_hs_voip_cm_reset_hot_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_reset_hot_line"].apply(null, arguments);
});
var _hs_voip_cm_reset_warm_line = Module["_hs_voip_cm_reset_warm_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_reset_warm_line"].apply(null, arguments);
});
var _hs_voip_cm_save_config = Module["_hs_voip_cm_save_config"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_save_config"].apply(null, arguments);
});
var _hs_voip_cm_save_reject_list = Module["_hs_voip_cm_save_reject_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_save_reject_list"].apply(null, arguments);
});
var _hs_voip_cm_set_accept_contact = Module["_hs_voip_cm_set_accept_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_accept_contact"].apply(null, arguments);
});
var _hs_voip_cm_set_adapters_list = Module["_hs_voip_cm_set_adapters_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_adapters_list"].apply(null, arguments);
});
var _hs_voip_cm_set_alert_timeout = Module["_hs_voip_cm_set_alert_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_alert_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_algdetect_server = Module["_hs_voip_cm_set_algdetect_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_algdetect_server"].apply(null, arguments);
});
var _hs_voip_cm_set_always_do_session_refresh_flag = Module["_hs_voip_cm_set_always_do_session_refresh_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_always_do_session_refresh_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ambe_modeset = Module["_hs_voip_cm_set_ambe_modeset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ambe_modeset"].apply(null, arguments);
});
var _hs_voip_cm_set_amr_modeset = Module["_hs_voip_cm_set_amr_modeset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_amr_modeset"].apply(null, arguments);
});
var _hs_voip_cm_set_amrnb_channels = Module["_hs_voip_cm_set_amrnb_channels"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_amrnb_channels"].apply(null, arguments);
});
var _hs_voip_cm_set_amrnb_interleaving = Module["_hs_voip_cm_set_amrnb_interleaving"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_amrnb_interleaving"].apply(null, arguments);
});
var _hs_voip_cm_set_amrnb_mode_change_neighbor = Module["_hs_voip_cm_set_amrnb_mode_change_neighbor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_amrnb_mode_change_neighbor"].apply(null, arguments);
});
var _hs_voip_cm_set_amrnb_octet_align = Module["_hs_voip_cm_set_amrnb_octet_align"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_amrnb_octet_align"].apply(null, arguments);
});
var _hs_voip_cm_set_amrnb_robust_sorting = Module["_hs_voip_cm_set_amrnb_robust_sorting"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_amrnb_robust_sorting"].apply(null, arguments);
});
var _hs_voip_cm_set_ans_timeout = Module["_hs_voip_cm_set_ans_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ans_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_app_dns_resp_timeout = Module["_hs_voip_cm_set_app_dns_resp_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_app_dns_resp_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_apparam = Module["_hs_voip_cm_set_apparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_apparam"].apply(null, arguments);
});
var _hs_voip_cm_set_attended_xfer_keys = Module["_hs_voip_cm_set_attended_xfer_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_attended_xfer_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_attended_xfer_timeout = Module["_hs_voip_cm_set_attended_xfer_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_attended_xfer_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_auto_ans_disable_keys = Module["_hs_voip_cm_set_auto_ans_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_auto_ans_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_auto_ans_enable_keys = Module["_hs_voip_cm_set_auto_ans_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_auto_ans_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_auto_sip_registration_flag = Module["_hs_voip_cm_set_auto_sip_registration_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_auto_sip_registration_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_autocallback_disable_keys = Module["_hs_voip_cm_set_autocallback_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_autocallback_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_autocallback_enable_keys = Module["_hs_voip_cm_set_autocallback_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_autocallback_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_autodetect_dnsip = Module["_hs_voip_cm_set_autodetect_dnsip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_autodetect_dnsip"].apply(null, arguments);
});
var _hs_voip_cm_set_autohoff_intvl = Module["_hs_voip_cm_set_autohoff_intvl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_autohoff_intvl"].apply(null, arguments);
});
var _hs_voip_cm_set_badmedia_adpt_blocktime = Module["_hs_voip_cm_set_badmedia_adpt_blocktime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_badmedia_adpt_blocktime"].apply(null, arguments);
});
var _hs_voip_cm_set_call_park_server = Module["_hs_voip_cm_set_call_park_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_park_server"].apply(null, arguments);
});
var _hs_voip_cm_set_call_return_keys = Module["_hs_voip_cm_set_call_return_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_return_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_call_trace_keys = Module["_hs_voip_cm_set_call_trace_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_trace_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_call_transfer_disable_keys = Module["_hs_voip_cm_set_call_transfer_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_transfer_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_call_transfer_enable_keys = Module["_hs_voip_cm_set_call_transfer_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_transfer_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_call_wait_disable_keys = Module["_hs_voip_cm_set_call_wait_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_wait_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_call_wait_enable_keys = Module["_hs_voip_cm_set_call_wait_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_wait_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_call_waiting_timeout = Module["_hs_voip_cm_set_call_waiting_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_call_waiting_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_callpark_keys = Module["_hs_voip_cm_set_callpark_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_callpark_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_callpickup_keys = Module["_hs_voip_cm_set_callpickup_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_callpickup_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_capb_discovery_mechanism = Module["_hs_voip_cm_set_capb_discovery_mechanism"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_capb_discovery_mechanism"].apply(null, arguments);
});
var _hs_voip_cm_set_capb_discovery_via_common_stack = Module["_hs_voip_cm_set_capb_discovery_via_common_stack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_capb_discovery_via_common_stack"].apply(null, arguments);
});
var _hs_voip_cm_set_capb_info_expiry = Module["_hs_voip_cm_set_capb_info_expiry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_capb_info_expiry"].apply(null, arguments);
});
var _hs_voip_cm_set_capb_polling_flag = Module["_hs_voip_cm_set_capb_polling_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_capb_polling_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_capb_polling_period = Module["_hs_voip_cm_set_capb_polling_period"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_capb_polling_period"].apply(null, arguments);
});
var _hs_voip_cm_set_capb_polling_rate = Module["_hs_voip_cm_set_capb_polling_rate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_capb_polling_rate"].apply(null, arguments);
});
var _hs_voip_cm_set_capb_polling_rate_period = Module["_hs_voip_cm_set_capb_polling_rate_period"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_capb_polling_rate_period"].apply(null, arguments);
});
var _hs_voip_cm_set_cfwd_always_disable_keys = Module["_hs_voip_cm_set_cfwd_always_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cfwd_always_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_cfwd_always_enable_keys = Module["_hs_voip_cm_set_cfwd_always_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cfwd_always_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_cfwd_busy_disable_keys = Module["_hs_voip_cm_set_cfwd_busy_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cfwd_busy_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_cfwd_busy_enable_keys = Module["_hs_voip_cm_set_cfwd_busy_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cfwd_busy_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_cfwd_noans_disable_keys = Module["_hs_voip_cm_set_cfwd_noans_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cfwd_noans_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_cfwd_noans_enable_keys = Module["_hs_voip_cm_set_cfwd_noans_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cfwd_noans_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_cid_before_after_ring = Module["_hs_voip_cm_set_cid_before_after_ring"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cid_before_after_ring"].apply(null, arguments);
});
var _hs_voip_cm_set_cid_detection_type = Module["_hs_voip_cm_set_cid_detection_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cid_detection_type"].apply(null, arguments);
});
var _hs_voip_cm_set_cid_power_level = Module["_hs_voip_cm_set_cid_power_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cid_power_level"].apply(null, arguments);
});
var _hs_voip_cm_set_cid_type1_alert_signal = Module["_hs_voip_cm_set_cid_type1_alert_signal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cid_type1_alert_signal"].apply(null, arguments);
});
var _hs_voip_cm_set_cid_type2_alert_signal = Module["_hs_voip_cm_set_cid_type2_alert_signal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_cid_type2_alert_signal"].apply(null, arguments);
});
var _hs_voip_cm_set_client_auth_flag = Module["_hs_voip_cm_set_client_auth_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_client_auth_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_client_private_key_file_name = Module["_hs_voip_cm_set_client_private_key_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_client_private_key_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_client_public_key_file_name = Module["_hs_voip_cm_set_client_public_key_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_client_public_key_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_clir_disable_keys = Module["_hs_voip_cm_set_clir_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_clir_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_clir_enable_keys = Module["_hs_voip_cm_set_clir_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_clir_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_codec = Module["_hs_voip_cm_set_codec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_codec"].apply(null, arguments);
});
var _hs_voip_cm_set_codec_change_limit = Module["_hs_voip_cm_set_codec_change_limit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_codec_change_limit"].apply(null, arguments);
});
var _hs_voip_cm_set_codec_mode = Module["_hs_voip_cm_set_codec_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_codec_mode"].apply(null, arguments);
});
var _hs_voip_cm_set_codec_priority = Module["_hs_voip_cm_set_codec_priority"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_codec_priority"].apply(null, arguments);
});
var _hs_voip_cm_set_codec_rate = Module["_hs_voip_cm_set_codec_rate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_codec_rate"].apply(null, arguments);
});
var _hs_voip_cm_set_conference_keys = Module["_hs_voip_cm_set_conference_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_conference_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_conference_uri = Module["_hs_voip_cm_set_conference_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_conference_uri"].apply(null, arguments);
});
var _hs_voip_cm_set_conseq_hoff_thrsld = Module["_hs_voip_cm_set_conseq_hoff_thrsld"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_conseq_hoff_thrsld"].apply(null, arguments);
});
var _hs_voip_cm_set_crl_file_name = Module["_hs_voip_cm_set_crl_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_crl_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_default_codec_pts = Module["_hs_voip_cm_set_default_codec_pts"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_default_codec_pts"].apply(null, arguments);
});
var _hs_voip_cm_set_default_config = Module["_hs_voip_cm_set_default_config"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_default_config"].apply(null, arguments);
});
var _hs_voip_cm_set_dev_play_buf_len = Module["_hs_voip_cm_set_dev_play_buf_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dev_play_buf_len"].apply(null, arguments);
});
var _hs_voip_cm_set_dev_play_sam_rate = Module["_hs_voip_cm_set_dev_play_sam_rate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dev_play_sam_rate"].apply(null, arguments);
});
var _hs_voip_cm_set_dev_rec_buf_len = Module["_hs_voip_cm_set_dev_rec_buf_len"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dev_rec_buf_len"].apply(null, arguments);
});
var _hs_voip_cm_set_dev_rec_sam_rate = Module["_hs_voip_cm_set_dev_rec_sam_rate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dev_rec_sam_rate"].apply(null, arguments);
});
var _hs_voip_cm_set_dhcp_lease_timeout = Module["_hs_voip_cm_set_dhcp_lease_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dhcp_lease_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_dial_string_flag = Module["_hs_voip_cm_set_dial_string_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dial_string_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_dialtone_timeout = Module["_hs_voip_cm_set_dialtone_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dialtone_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_distinctive_ring_disable_key = Module["_hs_voip_cm_set_distinctive_ring_disable_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_distinctive_ring_disable_key"].apply(null, arguments);
});
var _hs_voip_cm_set_distinctive_ring_enable_key = Module["_hs_voip_cm_set_distinctive_ring_enable_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_distinctive_ring_enable_key"].apply(null, arguments);
});
var _hs_voip_cm_set_distinctive_ringback_disable_key = Module["_hs_voip_cm_set_distinctive_ringback_disable_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_distinctive_ringback_disable_key"].apply(null, arguments);
});
var _hs_voip_cm_set_distinctive_ringback_enable_key = Module["_hs_voip_cm_set_distinctive_ringback_enable_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_distinctive_ringback_enable_key"].apply(null, arguments);
});
var _hs_voip_cm_set_dnd_disable_keys = Module["_hs_voip_cm_set_dnd_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dnd_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_dnd_enable_keys = Module["_hs_voip_cm_set_dnd_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dnd_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_dns_cache_size = Module["_hs_voip_cm_set_dns_cache_size"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dns_cache_size"].apply(null, arguments);
});
var _hs_voip_cm_set_dns_client_opt = Module["_hs_voip_cm_set_dns_client_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dns_client_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_dns_info_filename = Module["_hs_voip_cm_set_dns_info_filename"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dns_info_filename"].apply(null, arguments);
});
var _hs_voip_cm_set_dns_no_of_retrans = Module["_hs_voip_cm_set_dns_no_of_retrans"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dns_no_of_retrans"].apply(null, arguments);
});
var _hs_voip_cm_set_dns_retrans_timeout = Module["_hs_voip_cm_set_dns_retrans_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dns_retrans_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_dns_src_port = Module["_hs_voip_cm_set_dns_src_port"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dns_src_port"].apply(null, arguments);
});
var _hs_voip_cm_set_downgrade_to_no_security_flag = Module["_hs_voip_cm_set_downgrade_to_no_security_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_downgrade_to_no_security_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_dtmf_type = Module["_hs_voip_cm_set_dtmf_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_dtmf_type"].apply(null, arguments);
});
var _hs_voip_cm_set_early_only_flag = Module["_hs_voip_cm_set_early_only_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_early_only_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_emergency_call_hoff_opt = Module["_hs_voip_cm_set_emergency_call_hoff_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_emergency_call_hoff_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_emergency_call_nwk_opt = Module["_hs_voip_cm_set_emergency_call_nwk_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_emergency_call_nwk_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_enable_sipoutbound = Module["_hs_voip_cm_set_enable_sipoutbound"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_enable_sipoutbound"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_adptlist = Module["_hs_voip_cm_set_ep_adptlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_adptlist"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_aec_mode = Module["_hs_voip_cm_set_ep_aec_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_aec_mode"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_always_use_outbound_proxy_flag = Module["_hs_voip_cm_set_ep_always_use_outbound_proxy_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_always_use_outbound_proxy_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_anonymous_callrej_flag = Module["_hs_voip_cm_set_ep_anonymous_callrej_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_anonymous_callrej_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_asserted_identity = Module["_hs_voip_cm_set_ep_asserted_identity"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_asserted_identity"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_auto_ans_flag = Module["_hs_voip_cm_set_ep_auto_ans_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_auto_ans_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_auto_ans_timeout = Module["_hs_voip_cm_set_ep_auto_ans_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_auto_ans_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_auto_cwaiting_flag = Module["_hs_voip_cm_set_ep_auto_cwaiting_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_auto_cwaiting_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_cfwd_always = Module["_hs_voip_cm_set_ep_cfwd_always"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_cfwd_always"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_cfwd_no_ans_timeout = Module["_hs_voip_cm_set_ep_cfwd_no_ans_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_cfwd_no_ans_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_cfwd_on_busy = Module["_hs_voip_cm_set_ep_cfwd_on_busy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_cfwd_on_busy"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_cfwd_on_no_ans = Module["_hs_voip_cm_set_ep_cfwd_on_no_ans"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_cfwd_on_no_ans"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_cfwd_opt = Module["_hs_voip_cm_set_ep_cfwd_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_cfwd_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_cni_opt = Module["_hs_voip_cm_set_ep_cni_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_cni_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_conf_type = Module["_hs_voip_cm_set_ep_conf_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_conf_type"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_data_type = Module["_hs_voip_cm_set_ep_data_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_data_type"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_device_name = Module["_hs_voip_cm_set_ep_device_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_device_name"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_disable_cfwd_always = Module["_hs_voip_cm_set_ep_disable_cfwd_always"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_disable_cfwd_always"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_disable_cfwd_on_busy = Module["_hs_voip_cm_set_ep_disable_cfwd_on_busy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_disable_cfwd_on_busy"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_disable_cfwd_on_no_ans = Module["_hs_voip_cm_set_ep_disable_cfwd_on_no_ans"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_disable_cfwd_on_no_ans"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_display_name = Module["_hs_voip_cm_set_ep_display_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_display_name"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_dnd_flag = Module["_hs_voip_cm_set_ep_dnd_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_dnd_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_ec_opt = Module["_hs_voip_cm_set_ep_ec_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_ec_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_ec_tail_length = Module["_hs_voip_cm_set_ep_ec_tail_length"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_ec_tail_length"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_email_id = Module["_hs_voip_cm_set_ep_email_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_email_id"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_far_echo = Module["_hs_voip_cm_set_ep_far_echo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_far_echo"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_freeze_opt = Module["_hs_voip_cm_set_ep_freeze_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_freeze_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_from_change_support_flag = Module["_hs_voip_cm_set_ep_from_change_support_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_from_change_support_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_fxo_answering_supervision = Module["_hs_voip_cm_set_ep_fxo_answering_supervision"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_fxo_answering_supervision"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_fxo_disconnecting_supervision = Module["_hs_voip_cm_set_ep_fxo_disconnecting_supervision"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_fxo_disconnecting_supervision"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_g722_time = Module["_hs_voip_cm_set_ep_g722_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_g722_time"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_g726_bit_pack = Module["_hs_voip_cm_set_ep_g726_bit_pack"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_g726_bit_pack"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_howlrx = Module["_hs_voip_cm_set_ep_howlrx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_howlrx"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_howltx = Module["_hs_voip_cm_set_ep_howltx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_howltx"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_jb_bufsz = Module["_hs_voip_cm_set_ep_jb_bufsz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_jb_bufsz"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_jbadapt_speed = Module["_hs_voip_cm_set_ep_jbadapt_speed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_jbadapt_speed"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_lgcrx = Module["_hs_voip_cm_set_ep_lgcrx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_lgcrx"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_lgctx = Module["_hs_voip_cm_set_ep_lgctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_lgctx"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_ncrx = Module["_hs_voip_cm_set_ep_ncrx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_ncrx"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_nctx = Module["_hs_voip_cm_set_ep_nctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_nctx"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_nlp_opt = Module["_hs_voip_cm_set_ep_nlp_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_nlp_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_nonneg_cn = Module["_hs_voip_cm_set_ep_nonneg_cn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_nonneg_cn"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_phone_context = Module["_hs_voip_cm_set_ep_phone_context"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_phone_context"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_privacy_levels = Module["_hs_voip_cm_set_ep_privacy_levels"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_privacy_levels"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_profile_id = Module["_hs_voip_cm_set_ep_profile_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_profile_id"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_proxy_outbound_flag = Module["_hs_voip_cm_set_ep_proxy_outbound_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_proxy_outbound_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_replace_call_flag = Module["_hs_voip_cm_set_ep_replace_call_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_replace_call_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_ringing_delay = Module["_hs_voip_cm_set_ep_ringing_delay"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_ringing_delay"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_rtp_timeout = Module["_hs_voip_cm_set_ep_rtp_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_rtp_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_rx_level = Module["_hs_voip_cm_set_ep_rx_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_rx_level"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_secure_outbound_list = Module["_hs_voip_cm_set_ep_secure_outbound_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_secure_outbound_list"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_services = Module["_hs_voip_cm_set_ep_services"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_services"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_sip_password = Module["_hs_voip_cm_set_ep_sip_password"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_sip_password"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_sip_proxy_list = Module["_hs_voip_cm_set_ep_sip_proxy_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_sip_proxy_list"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_sip_registrar = Module["_hs_voip_cm_set_ep_sip_registrar"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_sip_registrar"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_srtp_flag = Module["_hs_voip_cm_set_ep_srtp_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_srtp_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_srtp_option = Module["_hs_voip_cm_set_ep_srtp_option"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_srtp_option"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_encoding_methods = Module["_hs_voip_cm_set_ep_t38_fax_encoding_methods"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_encoding_methods"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_fillbit_removal = Module["_hs_voip_cm_set_ep_t38_fax_fillbit_removal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_fillbit_removal"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_max_bitrate = Module["_hs_voip_cm_set_ep_t38_fax_max_bitrate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_max_bitrate"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_max_buffer = Module["_hs_voip_cm_set_ep_t38_fax_max_buffer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_max_buffer"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_max_datagram = Module["_hs_voip_cm_set_ep_t38_fax_max_datagram"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_max_datagram"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_max_udp_ec = Module["_hs_voip_cm_set_ep_t38_fax_max_udp_ec"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_max_udp_ec"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_opt = Module["_hs_voip_cm_set_ep_t38_fax_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_rate_mgmt = Module["_hs_voip_cm_set_ep_t38_fax_rate_mgmt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_rate_mgmt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_redundancy_depth = Module["_hs_voip_cm_set_ep_t38_fax_redundancy_depth"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_redundancy_depth"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_transcoding_jbig = Module["_hs_voip_cm_set_ep_t38_fax_transcoding_jbig"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_transcoding_jbig"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_transcoding_mmr = Module["_hs_voip_cm_set_ep_t38_fax_transcoding_mmr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_transcoding_mmr"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_t38_fax_transport_protocol = Module["_hs_voip_cm_set_ep_t38_fax_transport_protocol"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_t38_fax_transport_protocol"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_telno_handling = Module["_hs_voip_cm_set_ep_telno_handling"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_telno_handling"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_tx_jb_opt = Module["_hs_voip_cm_set_ep_tx_jb_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_tx_jb_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_tx_level = Module["_hs_voip_cm_set_ep_tx_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_tx_level"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_txrx_delay = Module["_hs_voip_cm_set_ep_txrx_delay"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_txrx_delay"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_use_p_assert_id = Module["_hs_voip_cm_set_ep_use_p_assert_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_use_p_assert_id"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_user_map = Module["_hs_voip_cm_set_ep_user_map"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_user_map"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_user_name = Module["_hs_voip_cm_set_ep_user_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_user_name"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_user_resp_timeout = Module["_hs_voip_cm_set_ep_user_resp_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_user_resp_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_vad_type = Module["_hs_voip_cm_set_ep_vad_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_vad_type"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_video_flag = Module["_hs_voip_cm_set_ep_video_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_video_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_vmail_flag = Module["_hs_voip_cm_set_ep_vmail_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_vmail_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_voice_mail_uri = Module["_hs_voip_cm_set_ep_voice_mail_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_voice_mail_uri"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_vs_allow_record = Module["_hs_voip_cm_set_ep_vs_allow_record"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_vs_allow_record"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_vs_max_duration = Module["_hs_voip_cm_set_ep_vs_max_duration"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_vs_max_duration"].apply(null, arguments);
});
var _hs_voip_cm_set_ep_xcap_password = Module["_hs_voip_cm_set_ep_xcap_password"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ep_xcap_password"].apply(null, arguments);
});
var _hs_voip_cm_set_error_tone_timeout = Module["_hs_voip_cm_set_error_tone_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_error_tone_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_evrc0_recvmode = Module["_hs_voip_cm_set_evrc0_recvmode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_evrc0_recvmode"].apply(null, arguments);
});
var _hs_voip_cm_set_evrc0_sndmode = Module["_hs_voip_cm_set_evrc0_sndmode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_evrc0_sndmode"].apply(null, arguments);
});
var _hs_voip_cm_set_evrc1_fixedrate = Module["_hs_voip_cm_set_evrc1_fixedrate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_evrc1_fixedrate"].apply(null, arguments);
});
var _hs_voip_cm_set_evrc1_recvmode = Module["_hs_voip_cm_set_evrc1_recvmode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_evrc1_recvmode"].apply(null, arguments);
});
var _hs_voip_cm_set_evrc1_sndmode = Module["_hs_voip_cm_set_evrc1_sndmode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_evrc1_sndmode"].apply(null, arguments);
});
var _hs_voip_cm_set_feature_invocation_keys = Module["_hs_voip_cm_set_feature_invocation_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_feature_invocation_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_first_msg_in_invite = Module["_hs_voip_cm_set_first_msg_in_invite"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_first_msg_in_invite"].apply(null, arguments);
});
var _hs_voip_cm_set_gc_conf_factory_uri = Module["_hs_voip_cm_set_gc_conf_factory_uri"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_gc_conf_factory_uri"].apply(null, arguments);
});
var _hs_voip_cm_set_gruu_support_flag = Module["_hs_voip_cm_set_gruu_support_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_gruu_support_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_hardhoff_waittime = Module["_hs_voip_cm_set_hardhoff_waittime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hardhoff_waittime"].apply(null, arguments);
});
var _hs_voip_cm_set_histinfo_flag = Module["_hs_voip_cm_set_histinfo_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_histinfo_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_hoff_intvl = Module["_hs_voip_cm_set_hoff_intvl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hoff_intvl"].apply(null, arguments);
});
var _hs_voip_cm_set_hoff_mode = Module["_hs_voip_cm_set_hoff_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hoff_mode"].apply(null, arguments);
});
var _hs_voip_cm_set_hoff_msg_content_type = Module["_hs_voip_cm_set_hoff_msg_content_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hoff_msg_content_type"].apply(null, arguments);
});
var _hs_voip_cm_set_hoff_playtones_flag = Module["_hs_voip_cm_set_hoff_playtones_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hoff_playtones_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_hoff_poll_intvl = Module["_hs_voip_cm_set_hoff_poll_intvl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hoff_poll_intvl"].apply(null, arguments);
});
var _hs_voip_cm_set_hoff_reg_policy = Module["_hs_voip_cm_set_hoff_reg_policy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hoff_reg_policy"].apply(null, arguments);
});
var _hs_voip_cm_set_hold_call_keys = Module["_hs_voip_cm_set_hold_call_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hold_call_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_holdip = Module["_hs_voip_cm_set_holdip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_holdip"].apply(null, arguments);
});
var _hs_voip_cm_set_holdmode = Module["_hs_voip_cm_set_holdmode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_holdmode"].apply(null, arguments);
});
var _hs_voip_cm_set_hot_line = Module["_hs_voip_cm_set_hot_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hot_line"].apply(null, arguments);
});
var _hs_voip_cm_set_hotline_disab_key = Module["_hs_voip_cm_set_hotline_disab_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hotline_disab_key"].apply(null, arguments);
});
var _hs_voip_cm_set_hotline_enab_key = Module["_hs_voip_cm_set_hotline_enab_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_hotline_enab_key"].apply(null, arguments);
});
var _hs_voip_cm_set_howler_tone_timeout = Module["_hs_voip_cm_set_howler_tone_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_howler_tone_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_ilbc_mode = Module["_hs_voip_cm_set_ilbc_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ilbc_mode"].apply(null, arguments);
});
var _hs_voip_cm_set_im_delrep_enable = Module["_hs_voip_cm_set_im_delrep_enable"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_im_delrep_enable"].apply(null, arguments);
});
var _hs_voip_cm_set_in_call_accept_list_key = Module["_hs_voip_cm_set_in_call_accept_list_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_in_call_accept_list_key"].apply(null, arguments);
});
var _hs_voip_cm_set_in_call_reject_list_key = Module["_hs_voip_cm_set_in_call_reject_list_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_in_call_reject_list_key"].apply(null, arguments);
});
var _hs_voip_cm_set_instanceid = Module["_hs_voip_cm_set_instanceid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_instanceid"].apply(null, arguments);
});
var _hs_voip_cm_set_instanceid_support_flag = Module["_hs_voip_cm_set_instanceid_support_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_instanceid_support_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_inter_digit_dial_time = Module["_hs_voip_cm_set_inter_digit_dial_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_inter_digit_dial_time"].apply(null, arguments);
});
var _hs_voip_cm_set_interdigit_timeout = Module["_hs_voip_cm_set_interdigit_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_interdigit_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_intlist = Module["_hs_voip_cm_set_intlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_intlist"].apply(null, arguments);
});
var _hs_voip_cm_set_intparam = Module["_hs_voip_cm_set_intparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_intparam"].apply(null, arguments);
});
var _hs_voip_cm_set_ip_network_mode = Module["_hs_voip_cm_set_ip_network_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ip_network_mode"].apply(null, arguments);
});
var _hs_voip_cm_set_ipparam = Module["_hs_voip_cm_set_ipparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ipparam"].apply(null, arguments);
});
var _hs_voip_cm_set_is_focus_flag = Module["_hs_voip_cm_set_is_focus_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_is_focus_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_itnl_add_prefix_flag = Module["_hs_voip_cm_set_itnl_add_prefix_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_itnl_add_prefix_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_itnl_dial_prefix = Module["_hs_voip_cm_set_itnl_dial_prefix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_itnl_dial_prefix"].apply(null, arguments);
});
var _hs_voip_cm_set_keepalive_intrvl = Module["_hs_voip_cm_set_keepalive_intrvl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_keepalive_intrvl"].apply(null, arguments);
});
var _hs_voip_cm_set_local_ip_address = Module["_hs_voip_cm_set_local_ip_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_local_ip_address"].apply(null, arguments);
});
var _hs_voip_cm_set_local_ipv4_address = Module["_hs_voip_cm_set_local_ipv4_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_local_ipv4_address"].apply(null, arguments);
});
var _hs_voip_cm_set_local_provision_allowed = Module["_hs_voip_cm_set_local_provision_allowed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_local_provision_allowed"].apply(null, arguments);
});
var _hs_voip_cm_set_log_dir_limits = Module["_hs_voip_cm_set_log_dir_limits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_log_dir_limits"].apply(null, arguments);
});
var _hs_voip_cm_set_log_level = Module["_hs_voip_cm_set_log_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_log_level"].apply(null, arguments);
});
var _hs_voip_cm_set_log_path = Module["_hs_voip_cm_set_log_path"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_log_path"].apply(null, arguments);
});
var _hs_voip_cm_set_log_sip_msg_opt = Module["_hs_voip_cm_set_log_sip_msg_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_log_sip_msg_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_mandatory_profile_security_flag = Module["_hs_voip_cm_set_mandatory_profile_security_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_mandatory_profile_security_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_mandatory_security_flag = Module["_hs_voip_cm_set_mandatory_security_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_mandatory_security_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_max_adpt_blocktime = Module["_hs_voip_cm_set_max_adpt_blocktime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_max_adpt_blocktime"].apply(null, arguments);
});
var _hs_voip_cm_set_max_hoff_per_call = Module["_hs_voip_cm_set_max_hoff_per_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_max_hoff_per_call"].apply(null, arguments);
});
var _hs_voip_cm_set_max_ptime = Module["_hs_voip_cm_set_max_ptime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_max_ptime"].apply(null, arguments);
});
var _hs_voip_cm_set_max_reg_retransmissions = Module["_hs_voip_cm_set_max_reg_retransmissions"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_max_reg_retransmissions"].apply(null, arguments);
});
var _hs_voip_cm_set_mcparam = Module["_hs_voip_cm_set_mcparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_mcparam"].apply(null, arguments);
});
var _hs_voip_cm_set_messagestore_url = Module["_hs_voip_cm_set_messagestore_url"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_messagestore_url"].apply(null, arguments);
});
var _hs_voip_cm_set_min_adpt_blocktime = Module["_hs_voip_cm_set_min_adpt_blocktime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_min_adpt_blocktime"].apply(null, arguments);
});
var _hs_voip_cm_set_min_cs_ontime = Module["_hs_voip_cm_set_min_cs_ontime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_min_cs_ontime"].apply(null, arguments);
});
var _hs_voip_cm_set_min_time_next_reg_request = Module["_hs_voip_cm_set_min_time_next_reg_request"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_min_time_next_reg_request"].apply(null, arguments);
});
var _hs_voip_cm_set_msrp_ft_max_sz = Module["_hs_voip_cm_set_msrp_ft_max_sz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_msrp_ft_max_sz"].apply(null, arguments);
});
var _hs_voip_cm_set_msrp_imgsh_max_sz = Module["_hs_voip_cm_set_msrp_imgsh_max_sz"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_msrp_imgsh_max_sz"].apply(null, arguments);
});
var _hs_voip_cm_set_multimedia_in_chat = Module["_hs_voip_cm_set_multimedia_in_chat"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_multimedia_in_chat"].apply(null, arguments);
});
var _hs_voip_cm_set_mwi_auth = Module["_hs_voip_cm_set_mwi_auth"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_mwi_auth"].apply(null, arguments);
});
var _hs_voip_cm_set_mwi_refresh_timeout = Module["_hs_voip_cm_set_mwi_refresh_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_mwi_refresh_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_mwi_server = Module["_hs_voip_cm_set_mwi_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_mwi_server"].apply(null, arguments);
});
var _hs_voip_cm_set_nat_traversalflag = Module["_hs_voip_cm_set_nat_traversalflag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_nat_traversalflag"].apply(null, arguments);
});
var _hs_voip_cm_set_nat_type = Module["_hs_voip_cm_set_nat_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_nat_type"].apply(null, arguments);
});
var _hs_voip_cm_set_nated_ip_address = Module["_hs_voip_cm_set_nated_ip_address"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_nated_ip_address"].apply(null, arguments);
});
var _hs_voip_cm_set_new_call_keys = Module["_hs_voip_cm_set_new_call_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_new_call_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_nit_fix_flag = Module["_hs_voip_cm_set_nit_fix_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_nit_fix_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ntnl_add_prefix_flag = Module["_hs_voip_cm_set_ntnl_add_prefix_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ntnl_add_prefix_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_ntnl_dial_prefix = Module["_hs_voip_cm_set_ntnl_dial_prefix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ntnl_dial_prefix"].apply(null, arguments);
});
var _hs_voip_cm_set_ntp_server_ip = Module["_hs_voip_cm_set_ntp_server_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ntp_server_ip"].apply(null, arguments);
});
var _hs_voip_cm_set_nw_info = Module["_hs_voip_cm_set_nw_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_nw_info"].apply(null, arguments);
});
var _hs_voip_cm_set_nwkup_timeout = Module["_hs_voip_cm_set_nwkup_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_nwkup_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_ob_reg_basetime_all_flows_failed = Module["_hs_voip_cm_set_ob_reg_basetime_all_flows_failed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ob_reg_basetime_all_flows_failed"].apply(null, arguments);
});
var _hs_voip_cm_set_ob_reg_basetime_few_flows_failed = Module["_hs_voip_cm_set_ob_reg_basetime_few_flows_failed"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ob_reg_basetime_few_flows_failed"].apply(null, arguments);
});
var _hs_voip_cm_set_ob_reg_max_wait_time = Module["_hs_voip_cm_set_ob_reg_max_wait_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ob_reg_max_wait_time"].apply(null, arguments);
});
var _hs_voip_cm_set_out_call_accept_list_key = Module["_hs_voip_cm_set_out_call_accept_list_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_out_call_accept_list_key"].apply(null, arguments);
});
var _hs_voip_cm_set_out_call_reject_list_key = Module["_hs_voip_cm_set_out_call_reject_list_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_out_call_reject_list_key"].apply(null, arguments);
});
var _hs_voip_cm_set_outsession_keepalive_opt = Module["_hs_voip_cm_set_outsession_keepalive_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_outsession_keepalive_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_plus_expansion = Module["_hs_voip_cm_set_plus_expansion"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_plus_expansion"].apply(null, arguments);
});
var _hs_voip_cm_set_prack_enable_flag = Module["_hs_voip_cm_set_prack_enable_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_prack_enable_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_prebuilt_route = Module["_hs_voip_cm_set_prebuilt_route"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_prebuilt_route"].apply(null, arguments);
});
var _hs_voip_cm_set_primary_dns_server = Module["_hs_voip_cm_set_primary_dns_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_primary_dns_server"].apply(null, arguments);
});
var _hs_voip_cm_set_private_key_file_name = Module["_hs_voip_cm_set_private_key_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_private_key_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_prtyscan_info = Module["_hs_voip_cm_set_prtyscan_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_prtyscan_info"].apply(null, arguments);
});
var _hs_voip_cm_set_pt = Module["_hs_voip_cm_set_pt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_pt"].apply(null, arguments);
});
var _hs_voip_cm_set_public_key_file_name = Module["_hs_voip_cm_set_public_key_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_public_key_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_push_capabilities = Module["_hs_voip_cm_set_push_capabilities"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_push_capabilities"].apply(null, arguments);
});
var _hs_voip_cm_set_push_params = Module["_hs_voip_cm_set_push_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_push_params"].apply(null, arguments);
});
var _hs_voip_cm_set_realm_challenge_opt = Module["_hs_voip_cm_set_realm_challenge_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_realm_challenge_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_realm_credentials = Module["_hs_voip_cm_set_realm_credentials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_realm_credentials"].apply(null, arguments);
});
var _hs_voip_cm_set_redial_keys = Module["_hs_voip_cm_set_redial_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_redial_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_redundancy_level = Module["_hs_voip_cm_set_redundancy_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_redundancy_level"].apply(null, arguments);
});
var _hs_voip_cm_set_redundancy_type = Module["_hs_voip_cm_set_redundancy_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_redundancy_type"].apply(null, arguments);
});
var _hs_voip_cm_set_reg_event_package = Module["_hs_voip_cm_set_reg_event_package"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_reg_event_package"].apply(null, arguments);
});
var _hs_voip_cm_set_reg_retransmissions_timeout = Module["_hs_voip_cm_set_reg_retransmissions_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_reg_retransmissions_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_registration_timeout = Module["_hs_voip_cm_set_registration_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_registration_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_reject_contact = Module["_hs_voip_cm_set_reject_contact"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_reject_contact"].apply(null, arguments);
});
var _hs_voip_cm_set_release_timeout = Module["_hs_voip_cm_set_release_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_release_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_remote_end_certif_flag = Module["_hs_voip_cm_set_remote_end_certif_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_remote_end_certif_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_remote_feature_flag = Module["_hs_voip_cm_set_remote_feature_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_remote_feature_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_req_disposition = Module["_hs_voip_cm_set_req_disposition"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_req_disposition"].apply(null, arguments);
});
var _hs_voip_cm_set_retryfail_cnt = Module["_hs_voip_cm_set_retryfail_cnt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_retryfail_cnt"].apply(null, arguments);
});
var _hs_voip_cm_set_retryfail_time = Module["_hs_voip_cm_set_retryfail_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_retryfail_time"].apply(null, arguments);
});
var _hs_voip_cm_set_reuse_sipcredentials = Module["_hs_voip_cm_set_reuse_sipcredentials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_reuse_sipcredentials"].apply(null, arguments);
});
var _hs_voip_cm_set_reuse_tcp_connection_flag = Module["_hs_voip_cm_set_reuse_tcp_connection_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_reuse_tcp_connection_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_root_certif_file_name = Module["_hs_voip_cm_set_root_certif_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_root_certif_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_rtp_error_limit = Module["_hs_voip_cm_set_rtp_error_limit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtp_error_limit"].apply(null, arguments);
});
var _hs_voip_cm_set_rtp_packet_loss_limit = Module["_hs_voip_cm_set_rtp_packet_loss_limit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtp_packet_loss_limit"].apply(null, arguments);
});
var _hs_voip_cm_set_rtp_port_limits = Module["_hs_voip_cm_set_rtp_port_limits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtp_port_limits"].apply(null, arguments);
});
var _hs_voip_cm_set_rtp_tos = Module["_hs_voip_cm_set_rtp_tos"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtp_tos"].apply(null, arguments);
});
var _hs_voip_cm_set_rtt_cps = Module["_hs_voip_cm_set_rtt_cps"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtt_cps"].apply(null, arguments);
});
var _hs_voip_cm_set_rtt_redundancy_levels = Module["_hs_voip_cm_set_rtt_redundancy_levels"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtt_redundancy_levels"].apply(null, arguments);
});
var _hs_voip_cm_set_rtt_rmt_idletimeout = Module["_hs_voip_cm_set_rtt_rmt_idletimeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtt_rmt_idletimeout"].apply(null, arguments);
});
var _hs_voip_cm_set_rtt_rxbuf_time = Module["_hs_voip_cm_set_rtt_rxbuf_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtt_rxbuf_time"].apply(null, arguments);
});
var _hs_voip_cm_set_rtt_txbuf_time = Module["_hs_voip_cm_set_rtt_txbuf_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_rtt_txbuf_time"].apply(null, arguments);
});
var _hs_voip_cm_set_secondary_dns_server = Module["_hs_voip_cm_set_secondary_dns_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_secondary_dns_server"].apply(null, arguments);
});
var _hs_voip_cm_set_session_refresh_timeout = Module["_hs_voip_cm_set_session_refresh_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_session_refresh_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_sessionim_acpt_opt = Module["_hs_voip_cm_set_sessionim_acpt_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sessionim_acpt_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_sessionim_enable = Module["_hs_voip_cm_set_sessionim_enable"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sessionim_enable"].apply(null, arguments);
});
var _hs_voip_cm_set_sessionim_max_count = Module["_hs_voip_cm_set_sessionim_max_count"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sessionim_max_count"].apply(null, arguments);
});
var _hs_voip_cm_set_sessionim_max_msgsize = Module["_hs_voip_cm_set_sessionim_max_msgsize"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sessionim_max_msgsize"].apply(null, arguments);
});
var _hs_voip_cm_set_sessionim_techtype = Module["_hs_voip_cm_set_sessionim_techtype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sessionim_techtype"].apply(null, arguments);
});
var _hs_voip_cm_set_sesssionim_idle_timer = Module["_hs_voip_cm_set_sesssionim_idle_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sesssionim_idle_timer"].apply(null, arguments);
});
var _hs_voip_cm_set_sim_cap_alwayson = Module["_hs_voip_cm_set_sim_cap_alwayson"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sim_cap_alwayson"].apply(null, arguments);
});
var _hs_voip_cm_set_sim_cap_fornonrcs = Module["_hs_voip_cm_set_sim_cap_fornonrcs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sim_cap_fornonrcs"].apply(null, arguments);
});
var _hs_voip_cm_set_sim_fbtoSMS = Module["_hs_voip_cm_set_sim_fbtoSMS"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sim_fbtoSMS"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_algdetect_opt = Module["_hs_voip_cm_set_sip_algdetect_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_algdetect_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_compr_algorithm = Module["_hs_voip_cm_set_sip_compr_algorithm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_compr_algorithm"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_compr_flag = Module["_hs_voip_cm_set_sip_compr_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_compr_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_failover_timeout = Module["_hs_voip_cm_set_sip_failover_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_failover_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_local_port = Module["_hs_voip_cm_set_sip_local_port"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_local_port"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_nat_opt = Module["_hs_voip_cm_set_sip_nat_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_nat_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_opt_3gpp = Module["_hs_voip_cm_set_sip_opt_3gpp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_opt_3gpp"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_out_bound_proxy_sig_comp_id = Module["_hs_voip_cm_set_sip_out_bound_proxy_sig_comp_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_out_bound_proxy_sig_comp_id"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_referred_by_flag = Module["_hs_voip_cm_set_sip_referred_by_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_referred_by_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_short_headers_flag = Module["_hs_voip_cm_set_sip_short_headers_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_short_headers_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_sig_comp_id = Module["_hs_voip_cm_set_sip_sig_comp_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_sig_comp_id"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_signaling_port = Module["_hs_voip_cm_set_sip_signaling_port"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_signaling_port"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_subscription_id = Module["_hs_voip_cm_set_sip_subscription_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_subscription_id"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_t2_timer = Module["_hs_voip_cm_set_sip_t2_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_t2_timer"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_time_interval = Module["_hs_voip_cm_set_sip_time_interval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_time_interval"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_timer_B = Module["_hs_voip_cm_set_sip_timer_B"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_timer_B"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_timer_D = Module["_hs_voip_cm_set_sip_timer_D"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_timer_D"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_timer_F = Module["_hs_voip_cm_set_sip_timer_F"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_timer_F"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_timer_H = Module["_hs_voip_cm_set_sip_timer_H"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_timer_H"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_timer_I = Module["_hs_voip_cm_set_sip_timer_I"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_timer_I"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_timer_J = Module["_hs_voip_cm_set_sip_timer_J"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_timer_J"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_timer_K = Module["_hs_voip_cm_set_sip_timer_K"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_timer_K"].apply(null, arguments);
});
var _hs_voip_cm_set_sip_tos = Module["_hs_voip_cm_set_sip_tos"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sip_tos"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_certifcte_file_name = Module["_hs_voip_cm_set_smime_certifcte_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_certifcte_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_encrypt_flag = Module["_hs_voip_cm_set_smime_encrypt_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_encrypt_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_encryption = Module["_hs_voip_cm_set_smime_encryption"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_encryption"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_hdrs_list = Module["_hs_voip_cm_set_smime_hdrs_list"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_hdrs_list"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_key_ring_file_name = Module["_hs_voip_cm_set_smime_key_ring_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_key_ring_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_mac = Module["_hs_voip_cm_set_smime_mac"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_mac"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_prvte_key_file_name = Module["_hs_voip_cm_set_smime_prvte_key_file_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_prvte_key_file_name"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_sign_flag = Module["_hs_voip_cm_set_smime_sign_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_sign_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_smime_sip_hdrs_flag = Module["_hs_voip_cm_set_smime_sip_hdrs_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_smime_sip_hdrs_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_sms_transport_opt = Module["_hs_voip_cm_set_sms_transport_opt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_sms_transport_opt"].apply(null, arguments);
});
var _hs_voip_cm_set_speed_dial_dial_key = Module["_hs_voip_cm_set_speed_dial_dial_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_speed_dial_dial_key"].apply(null, arguments);
});
var _hs_voip_cm_set_speed_dial_set_key = Module["_hs_voip_cm_set_speed_dial_set_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_speed_dial_set_key"].apply(null, arguments);
});
var _hs_voip_cm_set_speex_modeset = Module["_hs_voip_cm_set_speex_modeset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_speex_modeset"].apply(null, arguments);
});
var _hs_voip_cm_set_static_nat_ip = Module["_hs_voip_cm_set_static_nat_ip"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_static_nat_ip"].apply(null, arguments);
});
var _hs_voip_cm_set_stepdial_delay = Module["_hs_voip_cm_set_stepdial_delay"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_stepdial_delay"].apply(null, arguments);
});
var _hs_voip_cm_set_stepdial_num = Module["_hs_voip_cm_set_stepdial_num"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_stepdial_num"].apply(null, arguments);
});
var _hs_voip_cm_set_stepdial_plus_replace = Module["_hs_voip_cm_set_stepdial_plus_replace"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_stepdial_plus_replace"].apply(null, arguments);
});
var _hs_voip_cm_set_stepdial_prefix = Module["_hs_voip_cm_set_stepdial_prefix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_stepdial_prefix"].apply(null, arguments);
});
var _hs_voip_cm_set_stepdial_suffix = Module["_hs_voip_cm_set_stepdial_suffix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_stepdial_suffix"].apply(null, arguments);
});
var _hs_voip_cm_set_stepdial_type = Module["_hs_voip_cm_set_stepdial_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_stepdial_type"].apply(null, arguments);
});
var _hs_voip_cm_set_strict_conformance = Module["_hs_voip_cm_set_strict_conformance"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_strict_conformance"].apply(null, arguments);
});
var _hs_voip_cm_set_strlist = Module["_hs_voip_cm_set_strlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_strlist"].apply(null, arguments);
});
var _hs_voip_cm_set_strparam = Module["_hs_voip_cm_set_strparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_strparam"].apply(null, arguments);
});
var _hs_voip_cm_set_stun_server = Module["_hs_voip_cm_set_stun_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_stun_server"].apply(null, arguments);
});
var _hs_voip_cm_set_tcp_conn_keepalive = Module["_hs_voip_cm_set_tcp_conn_keepalive"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tcp_conn_keepalive"].apply(null, arguments);
});
var _hs_voip_cm_set_tcp_max_idle_duration = Module["_hs_voip_cm_set_tcp_max_idle_duration"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tcp_max_idle_duration"].apply(null, arguments);
});
var _hs_voip_cm_set_tcritical_timeout = Module["_hs_voip_cm_set_tcritical_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tcritical_timeout"].apply(null, arguments);
});
var _hs_voip_cm_set_threshold_ttl = Module["_hs_voip_cm_set_threshold_ttl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_threshold_ttl"].apply(null, arguments);
});
var _hs_voip_cm_set_tls_cipher = Module["_hs_voip_cm_set_tls_cipher"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tls_cipher"].apply(null, arguments);
});
var _hs_voip_cm_set_tls_client_certif_flag = Module["_hs_voip_cm_set_tls_client_certif_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tls_client_certif_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_tls_keyx = Module["_hs_voip_cm_set_tls_keyx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tls_keyx"].apply(null, arguments);
});
var _hs_voip_cm_set_tls_mac = Module["_hs_voip_cm_set_tls_mac"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tls_mac"].apply(null, arguments);
});
var _hs_voip_cm_set_tls_max_idle_duration = Module["_hs_voip_cm_set_tls_max_idle_duration"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tls_max_idle_duration"].apply(null, arguments);
});
var _hs_voip_cm_set_tls_secure_protocol = Module["_hs_voip_cm_set_tls_secure_protocol"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tls_secure_protocol"].apply(null, arguments);
});
var _hs_voip_cm_set_transfer_fback_key_sequence = Module["_hs_voip_cm_set_transfer_fback_key_sequence"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_transfer_fback_key_sequence"].apply(null, arguments);
});
var _hs_voip_cm_set_transfer_key_sequence = Module["_hs_voip_cm_set_transfer_key_sequence"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_transfer_key_sequence"].apply(null, arguments);
});
var _hs_voip_cm_set_transfer_option = Module["_hs_voip_cm_set_transfer_option"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_transfer_option"].apply(null, arguments);
});
var _hs_voip_cm_set_transport_protocol = Module["_hs_voip_cm_set_transport_protocol"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_transport_protocol"].apply(null, arguments);
});
var _hs_voip_cm_set_turn_credentials = Module["_hs_voip_cm_set_turn_credentials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_turn_credentials"].apply(null, arguments);
});
var _hs_voip_cm_set_turn_operation_mode = Module["_hs_voip_cm_set_turn_operation_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_turn_operation_mode"].apply(null, arguments);
});
var _hs_voip_cm_set_turn_protocol_mode = Module["_hs_voip_cm_set_turn_protocol_mode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_turn_protocol_mode"].apply(null, arguments);
});
var _hs_voip_cm_set_turn_server = Module["_hs_voip_cm_set_turn_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_turn_server"].apply(null, arguments);
});
var _hs_voip_cm_set_tx_packet_size = Module["_hs_voip_cm_set_tx_packet_size"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_tx_packet_size"].apply(null, arguments);
});
var _hs_voip_cm_set_ua_capabilities = Module["_hs_voip_cm_set_ua_capabilities"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_ua_capabilities"].apply(null, arguments);
});
var _hs_voip_cm_set_unsolicited_notify_event = Module["_hs_voip_cm_set_unsolicited_notify_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_unsolicited_notify_event"].apply(null, arguments);
});
var _hs_voip_cm_set_update_response_timer = Module["_hs_voip_cm_set_update_response_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_update_response_timer"].apply(null, arguments);
});
var _hs_voip_cm_set_user_agent_name = Module["_hs_voip_cm_set_user_agent_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_user_agent_name"].apply(null, arguments);
});
var _hs_voip_cm_set_vcc_call_disc_wait = Module["_hs_voip_cm_set_vcc_call_disc_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vcc_call_disc_wait"].apply(null, arguments);
});
var _hs_voip_cm_set_vdi = Module["_hs_voip_cm_set_vdi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vdi"].apply(null, arguments);
});
var _hs_voip_cm_set_vdn = Module["_hs_voip_cm_set_vdn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vdn"].apply(null, arguments);
});
var _hs_voip_cm_set_viability_flag = Module["_hs_voip_cm_set_viability_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_viability_flag"].apply(null, arguments);
});
var _hs_voip_cm_set_viability_server = Module["_hs_voip_cm_set_viability_server"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_viability_server"].apply(null, arguments);
});
var _hs_voip_cm_set_vmail_disable_keys = Module["_hs_voip_cm_set_vmail_disable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmail_disable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_vmail_enable_keys = Module["_hs_voip_cm_set_vmail_enable_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmail_enable_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_vmwi_alerting_signal = Module["_hs_voip_cm_set_vmwi_alerting_signal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmwi_alerting_signal"].apply(null, arguments);
});
var _hs_voip_cm_set_vmwi_interval_timer = Module["_hs_voip_cm_set_vmwi_interval_timer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmwi_interval_timer"].apply(null, arguments);
});
var _hs_voip_cm_set_vmwi_msg_display_waiting_time = Module["_hs_voip_cm_set_vmwi_msg_display_waiting_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmwi_msg_display_waiting_time"].apply(null, arguments);
});
var _hs_voip_cm_set_vmwi_msg_refresh_time = Module["_hs_voip_cm_set_vmwi_msg_refresh_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmwi_msg_refresh_time"].apply(null, arguments);
});
var _hs_voip_cm_set_vmwi_power_level = Module["_hs_voip_cm_set_vmwi_power_level"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmwi_power_level"].apply(null, arguments);
});
var _hs_voip_cm_set_vmwi_type = Module["_hs_voip_cm_set_vmwi_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_vmwi_type"].apply(null, arguments);
});
var _hs_voip_cm_set_voice_message_keys = Module["_hs_voip_cm_set_voice_message_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_voice_message_keys"].apply(null, arguments);
});
var _hs_voip_cm_set_voice_opmode = Module["_hs_voip_cm_set_voice_opmode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_voice_opmode"].apply(null, arguments);
});
var _hs_voip_cm_set_warm_line = Module["_hs_voip_cm_set_warm_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_warm_line"].apply(null, arguments);
});
var _hs_voip_cm_set_warmline_disab_key = Module["_hs_voip_cm_set_warmline_disab_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_warmline_disab_key"].apply(null, arguments);
});
var _hs_voip_cm_set_warmline_enab_key = Module["_hs_voip_cm_set_warmline_enab_key"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_set_warmline_enab_key"].apply(null, arguments);
});
var _hs_voip_cm_shutdown = Module["_hs_voip_cm_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_shutdown"].apply(null, arguments);
});
var _hs_voip_cm_sipext_add_hdr = Module["_hs_voip_cm_sipext_add_hdr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_sipext_add_hdr"].apply(null, arguments);
});
var _hs_voip_cm_sipext_add_hdrparam = Module["_hs_voip_cm_sipext_add_hdrparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_sipext_add_hdrparam"].apply(null, arguments);
});
var _hs_voip_cm_smime_hdrs_add_entry = Module["_hs_voip_cm_smime_hdrs_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_smime_hdrs_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_unsolicited_event_add_entry = Module["_hs_voip_cm_unsolicited_event_add_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_unsolicited_event_add_entry"].apply(null, arguments);
});
var _hs_voip_cm_validate_and_set_param = Module["_hs_voip_cm_validate_and_set_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_validate_and_set_param"].apply(null, arguments);
});
var _hs_voip_cm_validate_config_file = Module["_hs_voip_cm_validate_config_file"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_validate_config_file"].apply(null, arguments);
});
var _hs_voip_cm_validate_feature_keys = Module["_hs_voip_cm_validate_feature_keys"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_validate_feature_keys"].apply(null, arguments);
});
var _hs_voip_cm_validate_profile_config_file = Module["_hs_voip_cm_validate_profile_config_file"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_validate_profile_config_file"].apply(null, arguments);
});
var _hs_voip_cm_validate_tls_options = Module["_hs_voip_cm_validate_tls_options"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_validate_tls_options"].apply(null, arguments);
});
var _hs_voip_cm_verify_dialable_cell_num = Module["_hs_voip_cm_verify_dialable_cell_num"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_dialable_cell_num"].apply(null, arguments);
});
var _hs_voip_cm_verify_digit_map = Module["_hs_voip_cm_verify_digit_map"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_digit_map"].apply(null, arguments);
});
var _hs_voip_cm_verify_dtmf_string = Module["_hs_voip_cm_verify_dtmf_string"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_dtmf_string"].apply(null, arguments);
});
var _hs_voip_cm_verify_dtmfkey = Module["_hs_voip_cm_verify_dtmfkey"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_dtmfkey"].apply(null, arguments);
});
var _hs_voip_cm_verify_email = Module["_hs_voip_cm_verify_email"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_email"].apply(null, arguments);
});
var _hs_voip_cm_verify_instanceid_flag = Module["_hs_voip_cm_verify_instanceid_flag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_instanceid_flag"].apply(null, arguments);
});
var _hs_voip_cm_verify_ipaddress = Module["_hs_voip_cm_verify_ipaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_ipaddress"].apply(null, arguments);
});
var _hs_voip_cm_verify_is_digit = Module["_hs_voip_cm_verify_is_digit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_is_digit"].apply(null, arguments);
});
var _hs_voip_cm_verify_is_valid_ipaddress = Module["_hs_voip_cm_verify_is_valid_ipaddress"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_is_valid_ipaddress"].apply(null, arguments);
});
var _hs_voip_cm_verify_out_bound_proxy_sig_comp_id = Module["_hs_voip_cm_verify_out_bound_proxy_sig_comp_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_out_bound_proxy_sig_comp_id"].apply(null, arguments);
});
var _hs_voip_cm_verify_portno = Module["_hs_voip_cm_verify_portno"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_portno"].apply(null, arguments);
});
var _hs_voip_cm_verify_pt_value = Module["_hs_voip_cm_verify_pt_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_pt_value"].apply(null, arguments);
});
var _hs_voip_cm_verify_push_param = Module["_hs_voip_cm_verify_push_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_push_param"].apply(null, arguments);
});
var _hs_voip_cm_verify_rtppacketloss = Module["_hs_voip_cm_verify_rtppacketloss"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_rtppacketloss"].apply(null, arguments);
});
var _hs_voip_cm_verify_rtpportlimits = Module["_hs_voip_cm_verify_rtpportlimits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_rtpportlimits"].apply(null, arguments);
});
var _hs_voip_cm_verify_sig_comp_id = Module["_hs_voip_cm_verify_sig_comp_id"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_sig_comp_id"].apply(null, arguments);
});
var _hs_voip_cm_verify_signaling_timeout = Module["_hs_voip_cm_verify_signaling_timeout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_signaling_timeout"].apply(null, arguments);
});
var _hs_voip_cm_verify_uri_phone_num = Module["_hs_voip_cm_verify_uri_phone_num"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_uri_phone_num"].apply(null, arguments);
});
var _hs_voip_cm_verify_valid_cardtype = Module["_hs_voip_cm_verify_valid_cardtype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_cm_verify_valid_cardtype"].apply(null, arguments);
});
var _hs_voip_copy_call_param = Module["_hs_voip_copy_call_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_copy_call_param"].apply(null, arguments);
});
var _hs_voip_core_get_aor = Module["_hs_voip_core_get_aor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_core_get_aor"].apply(null, arguments);
});
var _hs_voip_create_call_param = Module["_hs_voip_create_call_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_create_call_param"].apply(null, arguments);
});
var _hs_voip_destroy_call_param = Module["_hs_voip_destroy_call_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_destroy_call_param"].apply(null, arguments);
});
var _hs_voip_dmap_match = Module["_hs_voip_dmap_match"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_dmap_match"].apply(null, arguments);
});
var _hs_voip_eam_clear_stats = Module["_hs_voip_eam_clear_stats"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_clear_stats"].apply(null, arguments);
});
var _hs_voip_eam_fill_stats = Module["_hs_voip_eam_fill_stats"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_fill_stats"].apply(null, arguments);
});
var _hs_voip_eam_get_stats = Module["_hs_voip_eam_get_stats"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_get_stats"].apply(null, arguments);
});
var _hs_voip_eam_get_sys_status = Module["_hs_voip_eam_get_sys_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_get_sys_status"].apply(null, arguments);
});
var _hs_voip_eam_handle_nwk_event = Module["_hs_voip_eam_handle_nwk_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_handle_nwk_event"].apply(null, arguments);
});
var _hs_voip_eam_init = Module["_hs_voip_eam_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_init"].apply(null, arguments);
});
var _hs_voip_eam_notify_config_change = Module["_hs_voip_eam_notify_config_change"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_notify_config_change"].apply(null, arguments);
});
var _hs_voip_eam_notify_error = Module["_hs_voip_eam_notify_error"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_notify_error"].apply(null, arguments);
});
var _hs_voip_eam_notify_event = Module["_hs_voip_eam_notify_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_notify_event"].apply(null, arguments);
});
var _hs_voip_eam_notify_handoff_complete = Module["_hs_voip_eam_notify_handoff_complete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_notify_handoff_complete"].apply(null, arguments);
});
var _hs_voip_eam_notify_nat_bind_reset = Module["_hs_voip_eam_notify_nat_bind_reset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_notify_nat_bind_reset"].apply(null, arguments);
});
var _hs_voip_eam_notify_unrecoverable_error = Module["_hs_voip_eam_notify_unrecoverable_error"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_notify_unrecoverable_error"].apply(null, arguments);
});
var _hs_voip_eam_post_stats = Module["_hs_voip_eam_post_stats"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_post_stats"].apply(null, arguments);
});
var _hs_voip_eam_reglog = Module["_hs_voip_eam_reglog"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_reglog"].apply(null, arguments);
});
var _hs_voip_eam_regnode_add = Module["_hs_voip_eam_regnode_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_regnode_add"].apply(null, arguments);
});
var _hs_voip_eam_set_internal_sys_status = Module["_hs_voip_eam_set_internal_sys_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_set_internal_sys_status"].apply(null, arguments);
});
var _hs_voip_eam_set_sys_status = Module["_hs_voip_eam_set_sys_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_set_sys_status"].apply(null, arguments);
});
var _hs_voip_eam_shutdown = Module["_hs_voip_eam_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_shutdown"].apply(null, arguments);
});
var _hs_voip_eam_stats_init = Module["_hs_voip_eam_stats_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_stats_init"].apply(null, arguments);
});
var _hs_voip_eam_stats_shutdown = Module["_hs_voip_eam_stats_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_eam_stats_shutdown"].apply(null, arguments);
});
var _hs_voip_fill_dns_init_info = Module["_hs_voip_fill_dns_init_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_fill_dns_init_info"].apply(null, arguments);
});
var _hs_voip_free_app_event_msg = Module["_hs_voip_free_app_event_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_free_app_event_msg"].apply(null, arguments);
});
var _hs_voip_free_call_info = Module["_hs_voip_free_call_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_free_call_info"].apply(null, arguments);
});
var _hs_voip_free_dlgid = Module["_hs_voip_free_dlgid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_free_dlgid"].apply(null, arguments);
});
var _hs_voip_get_call_info = Module["_hs_voip_get_call_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_get_call_info"].apply(null, arguments);
});
var _hs_voip_get_intparam = Module["_hs_voip_get_intparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_get_intparam"].apply(null, arguments);
});
var _hs_voip_get_param = Module["_hs_voip_get_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_get_param"].apply(null, arguments);
});
var _hs_voip_get_strlist_param = Module["_hs_voip_get_strlist_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_get_strlist_param"].apply(null, arguments);
});
var _hs_voip_get_strparam = Module["_hs_voip_get_strparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_get_strparam"].apply(null, arguments);
});
var _hs_voip_handle_nwk_event = Module["_hs_voip_handle_nwk_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_handle_nwk_event"].apply(null, arguments);
});
var _hs_voip_hold_call = Module["_hs_voip_hold_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_hold_call"].apply(null, arguments);
});
var _hs_voip_identity_array_copy = Module["_hs_voip_identity_array_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_identity_array_copy"].apply(null, arguments);
});
var _hs_voip_identity_copy = Module["_hs_voip_identity_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_identity_copy"].apply(null, arguments);
});
var _hs_voip_identity_params_init = Module["_hs_voip_identity_params_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_identity_params_init"].apply(null, arguments);
});
var _hs_voip_init_profile = Module["_hs_voip_init_profile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_init_profile"].apply(null, arguments);
});
var _hs_voip_login = Module["_hs_voip_login"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_login"].apply(null, arguments);
});
var _hs_voip_logout = Module["_hs_voip_logout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_logout"].apply(null, arguments);
});
var _hs_voip_logout_complete = Module["_hs_voip_logout_complete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_logout_complete"].apply(null, arguments);
});
var _hs_voip_make_call = Module["_hs_voip_make_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_make_call"].apply(null, arguments);
});
var _hs_voip_mc_create_channel = Module["_hs_voip_mc_create_channel"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_create_channel"].apply(null, arguments);
});
var _hs_voip_mc_free_appevt = Module["_hs_voip_mc_free_appevt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_free_appevt"].apply(null, arguments);
});
var _hs_voip_mc_free_msg = Module["_hs_voip_mc_free_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_free_msg"].apply(null, arguments);
});
var _hs_voip_mc_modify_media = Module["_hs_voip_mc_modify_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_modify_media"].apply(null, arguments);
});
var _hs_voip_mc_mute_media = Module["_hs_voip_mc_mute_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_mute_media"].apply(null, arguments);
});
var _hs_voip_mc_release_channel = Module["_hs_voip_mc_release_channel"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_release_channel"].apply(null, arguments);
});
var _hs_voip_mc_send_evt = Module["_hs_voip_mc_send_evt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_send_evt"].apply(null, arguments);
});
var _hs_voip_mc_send_failure_evt = Module["_hs_voip_mc_send_failure_evt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_send_failure_evt"].apply(null, arguments);
});
var _hs_voip_mc_set_rmt_caps = Module["_hs_voip_mc_set_rmt_caps"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_set_rmt_caps"].apply(null, arguments);
});
var _hs_voip_mc_sipinfo_msg = Module["_hs_voip_mc_sipinfo_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_sipinfo_msg"].apply(null, arguments);
});
var _hs_voip_mc_subsystem_init = Module["_hs_voip_mc_subsystem_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_subsystem_init"].apply(null, arguments);
});
var _hs_voip_mc_subsystem_shutdown = Module["_hs_voip_mc_subsystem_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_subsystem_shutdown"].apply(null, arguments);
});
var _hs_voip_mc_subsystem_start = Module["_hs_voip_mc_subsystem_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_subsystem_start"].apply(null, arguments);
});
var _hs_voip_mc_subsystem_stop = Module["_hs_voip_mc_subsystem_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_subsystem_stop"].apply(null, arguments);
});
var _hs_voip_mc_unmute_media = Module["_hs_voip_mc_unmute_media"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_unmute_media"].apply(null, arguments);
});
var _hs_voip_mc_voip_login = Module["_hs_voip_mc_voip_login"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_voip_login"].apply(null, arguments);
});
var _hs_voip_mc_voip_logout = Module["_hs_voip_mc_voip_logout"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_voip_logout"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_cb = Module["_hs_voip_mc_webrtc_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_cb"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_close_peerconn = Module["_hs_voip_mc_webrtc_close_peerconn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_close_peerconn"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_create_peerconn = Module["_hs_voip_mc_webrtc_create_peerconn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_create_peerconn"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_ctx_clear = Module["_hs_voip_mc_webrtc_ctx_clear"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_ctx_clear"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_ctx_free = Module["_hs_voip_mc_webrtc_ctx_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_ctx_free"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_ctx_get_sdpstate = Module["_hs_voip_mc_webrtc_ctx_get_sdpstate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_ctx_get_sdpstate"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_ctx_get_state = Module["_hs_voip_mc_webrtc_ctx_get_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_ctx_get_state"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_ctx_init = Module["_hs_voip_mc_webrtc_ctx_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_ctx_init"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_ctx_set_sdpstate = Module["_hs_voip_mc_webrtc_ctx_set_sdpstate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_ctx_set_sdpstate"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_ctx_set_state = Module["_hs_voip_mc_webrtc_ctx_set_state"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_ctx_set_state"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_disp = Module["_hs_voip_mc_webrtc_disp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_disp"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_free_msg = Module["_hs_voip_mc_webrtc_free_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_free_msg"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_get_ctx = Module["_hs_voip_mc_webrtc_get_ctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_get_ctx"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_get_new_ctx = Module["_hs_voip_mc_webrtc_get_new_ctx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_get_new_ctx"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_hndle_appmsg = Module["_hs_voip_mc_webrtc_hndle_appmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_hndle_appmsg"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_hndle_timermsg = Module["_hs_voip_mc_webrtc_hndle_timermsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_hndle_timermsg"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_hndle_webrtcmsg = Module["_hs_voip_mc_webrtc_hndle_webrtcmsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_hndle_webrtcmsg"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_if_destroy = Module["_hs_voip_mc_webrtc_if_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_if_destroy"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_if_init = Module["_hs_voip_mc_webrtc_if_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_if_init"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_modify_stream = Module["_hs_voip_mc_webrtc_modify_stream"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_modify_stream"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_mute_call = Module["_hs_voip_mc_webrtc_mute_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_mute_call"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_other_msg = Module["_hs_voip_mc_webrtc_other_msg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_other_msg"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_peerconn_get_local_desc = Module["_hs_voip_mc_webrtc_peerconn_get_local_desc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_peerconn_get_local_desc"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_set_remote_desc = Module["_hs_voip_mc_webrtc_set_remote_desc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_set_remote_desc"].apply(null, arguments);
});
var _hs_voip_mc_webrtc_unmute_call = Module["_hs_voip_mc_webrtc_unmute_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_mc_webrtc_unmute_call"].apply(null, arguments);
});
var _hs_voip_modify_param_value = Module["_hs_voip_modify_param_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_modify_param_value"].apply(null, arguments);
});
var _hs_voip_oam_config_parse_line = Module["_hs_voip_oam_config_parse_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_config_parse_line"].apply(null, arguments);
});
var _hs_voip_oam_create_domain = Module["_hs_voip_oam_create_domain"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_create_domain"].apply(null, arguments);
});
var _hs_voip_oam_create_profile = Module["_hs_voip_oam_create_profile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_create_profile"].apply(null, arguments);
});
var _hs_voip_oam_del_domain = Module["_hs_voip_oam_del_domain"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_del_domain"].apply(null, arguments);
});
var _hs_voip_oam_del_profile = Module["_hs_voip_oam_del_profile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_del_profile"].apply(null, arguments);
});
var _hs_voip_oam_dmap_build_sm = Module["_hs_voip_oam_dmap_build_sm"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_dmap_build_sm"].apply(null, arguments);
});
var _hs_voip_oam_free_phonenum_alias = Module["_hs_voip_oam_free_phonenum_alias"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_phonenum_alias"].apply(null, arguments);
});
var _hs_voip_oam_free_prebuilt_route_set = Module["_hs_voip_oam_free_prebuilt_route_set"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_prebuilt_route_set"].apply(null, arguments);
});
var _hs_voip_oam_free_privacy_levels = Module["_hs_voip_oam_free_privacy_levels"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_privacy_levels"].apply(null, arguments);
});
var _hs_voip_oam_free_rejlist = Module["_hs_voip_oam_free_rejlist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_rejlist"].apply(null, arguments);
});
var _hs_voip_oam_free_remote_features = Module["_hs_voip_oam_free_remote_features"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_remote_features"].apply(null, arguments);
});
var _hs_voip_oam_free_smime_hdrs = Module["_hs_voip_oam_free_smime_hdrs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_smime_hdrs"].apply(null, arguments);
});
var _hs_voip_oam_free_speed_dials = Module["_hs_voip_oam_free_speed_dials"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_speed_dials"].apply(null, arguments);
});
var _hs_voip_oam_free_tonelist = Module["_hs_voip_oam_free_tonelist"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_tonelist"].apply(null, arguments);
});
var _hs_voip_oam_free_unsolicited_event = Module["_hs_voip_oam_free_unsolicited_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_free_unsolicited_event"].apply(null, arguments);
});
var _hs_voip_oam_get_config_symbol_index = Module["_hs_voip_oam_get_config_symbol_index"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_get_config_symbol_index"].apply(null, arguments);
});
var _hs_voip_oam_get_configsymbol_bysymid = Module["_hs_voip_oam_get_configsymbol_bysymid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_get_configsymbol_bysymid"].apply(null, arguments);
});
var _hs_voip_oam_get_value = Module["_hs_voip_oam_get_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_get_value"].apply(null, arguments);
});
var _hs_voip_oam_init = Module["_hs_voip_oam_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_init"].apply(null, arguments);
});
var _hs_voip_oam_is_domain_exists = Module["_hs_voip_oam_is_domain_exists"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_is_domain_exists"].apply(null, arguments);
});
var _hs_voip_oam_iscmnt = Module["_hs_voip_oam_iscmnt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_iscmnt"].apply(null, arguments);
});
var _hs_voip_oam_parse_line = Module["_hs_voip_oam_parse_line"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_parse_line"].apply(null, arguments);
});
var _hs_voip_oam_parse_set_conttype = Module["_hs_voip_oam_parse_set_conttype"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_parse_set_conttype"].apply(null, arguments);
});
var _hs_voip_oam_parse_set_xport_addr = Module["_hs_voip_oam_parse_set_xport_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_parse_set_xport_addr"].apply(null, arguments);
});
var _hs_voip_oam_process_comments = Module["_hs_voip_oam_process_comments"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_process_comments"].apply(null, arguments);
});
var _hs_voip_oam_read_profile = Module["_hs_voip_oam_read_profile"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_read_profile"].apply(null, arguments);
});
var _hs_voip_oam_set_digitmap_bits = Module["_hs_voip_oam_set_digitmap_bits"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_set_digitmap_bits"].apply(null, arguments);
});
var _hs_voip_oam_shutdown = Module["_hs_voip_oam_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_shutdown"].apply(null, arguments);
});
var _hs_voip_oam_start = Module["_hs_voip_oam_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_start"].apply(null, arguments);
});
var _hs_voip_oam_stop = Module["_hs_voip_oam_stop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_stop"].apply(null, arguments);
});
var _hs_voip_oam_symbol_set_int = Module["_hs_voip_oam_symbol_set_int"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_symbol_set_int"].apply(null, arguments);
});
var _hs_voip_oam_symbol_set_uint = Module["_hs_voip_oam_symbol_set_uint"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_symbol_set_uint"].apply(null, arguments);
});
var _hs_voip_oam_validate_addr = Module["_hs_voip_oam_validate_addr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_validate_addr"].apply(null, arguments);
});
var _hs_voip_oam_write_symbol_to_file = Module["_hs_voip_oam_write_symbol_to_file"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_oam_write_symbol_to_file"].apply(null, arguments);
});
var _hs_voip_parse_and_set_servcaps = Module["_hs_voip_parse_and_set_servcaps"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_parse_and_set_servcaps"].apply(null, arguments);
});
var _hs_voip_profile_save_config = Module["_hs_voip_profile_save_config"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_profile_save_config"].apply(null, arguments);
});
var _hs_voip_profile_save_config_internal = Module["_hs_voip_profile_save_config_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_profile_save_config_internal"].apply(null, arguments);
});
var _hs_voip_register_notification = Module["_hs_voip_register_notification"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_register_notification"].apply(null, arguments);
});
var _hs_voip_release_call = Module["_hs_voip_release_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_release_call"].apply(null, arguments);
});
var _hs_voip_release_complete = Module["_hs_voip_release_complete"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_release_complete"].apply(null, arguments);
});
var _hs_voip_saveconfig = Module["_hs_voip_saveconfig"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_saveconfig"].apply(null, arguments);
});
var _hs_voip_sdp__create_buffer = Module["_hs_voip_sdp__create_buffer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp__create_buffer"].apply(null, arguments);
});
var _hs_voip_sdp_builder = Module["_hs_voip_sdp_builder"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_builder"].apply(null, arguments);
});
var _hs_voip_sdp_builder_ins_connect_info = Module["_hs_voip_sdp_builder_ins_connect_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_builder_ins_connect_info"].apply(null, arguments);
});
var _hs_voip_sdp_builder_ins_content_type = Module["_hs_voip_sdp_builder_ins_content_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_builder_ins_content_type"].apply(null, arguments);
});
var _hs_voip_sdp_builder_ins_rtcpfb_params = Module["_hs_voip_sdp_builder_ins_rtcpfb_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_builder_ins_rtcpfb_params"].apply(null, arguments);
});
var _hs_voip_sdp_clear_media_info = Module["_hs_voip_sdp_clear_media_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_clear_media_info"].apply(null, arguments);
});
var _hs_voip_sdp_clear_media_pt_info = Module["_hs_voip_sdp_clear_media_pt_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_clear_media_pt_info"].apply(null, arguments);
});
var _hs_voip_sdp_clear_pt_struct = Module["_hs_voip_sdp_clear_pt_struct"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_clear_pt_struct"].apply(null, arguments);
});
var _hs_voip_sdp_copy_media_info = Module["_hs_voip_sdp_copy_media_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_copy_media_info"].apply(null, arguments);
});
var _hs_voip_sdp_copy_pt_info = Module["_hs_voip_sdp_copy_pt_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_copy_pt_info"].apply(null, arguments);
});
var _hs_voip_sdp_fill_sess_params = Module["_hs_voip_sdp_fill_sess_params"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_fill_sess_params"].apply(null, arguments);
});
var _hs_voip_sdp_get_extra = Module["_hs_voip_sdp_get_extra"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_get_extra"].apply(null, arguments);
});
var _hs_voip_sdp_get_media_precondes_stren = Module["_hs_voip_sdp_get_media_precondes_stren"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_get_media_precondes_stren"].apply(null, arguments);
});
var _hs_voip_sdp_get_pt_codec_fmtp = Module["_hs_voip_sdp_get_pt_codec_fmtp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_get_pt_codec_fmtp"].apply(null, arguments);
});
var _hs_voip_sdp_ice_cand_create_copy = Module["_hs_voip_sdp_ice_cand_create_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_ice_cand_create_copy"].apply(null, arguments);
});
var _hs_voip_sdp_lex = Module["_hs_voip_sdp_lex"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_lex"].apply(null, arguments);
});
var _hs_voip_sdp_lex_destroy = Module["_hs_voip_sdp_lex_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_lex_destroy"].apply(null, arguments);
});
var _hs_voip_sdp_lex_init = Module["_hs_voip_sdp_lex_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_lex_init"].apply(null, arguments);
});
var _hs_voip_sdp_parse = Module["_hs_voip_sdp_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_parse"].apply(null, arguments);
});
var _hs_voip_sdp_parser_rtcpfb_ackparam = Module["_hs_voip_sdp_parser_rtcpfb_ackparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_parser_rtcpfb_ackparam"].apply(null, arguments);
});
var _hs_voip_sdp_parser_rtcpfb_ccmparam = Module["_hs_voip_sdp_parser_rtcpfb_ccmparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_parser_rtcpfb_ccmparam"].apply(null, arguments);
});
var _hs_voip_sdp_parser_rtcpfb_nackparam = Module["_hs_voip_sdp_parser_rtcpfb_nackparam"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_parser_rtcpfb_nackparam"].apply(null, arguments);
});
var _hs_voip_sdp_parser_rtcpfb_tmmbr = Module["_hs_voip_sdp_parser_rtcpfb_tmmbr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_parser_rtcpfb_tmmbr"].apply(null, arguments);
});
var _hs_voip_sdp_restart = Module["_hs_voip_sdp_restart"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_restart"].apply(null, arguments);
});
var _hs_voip_sdp_rtcpfb_check_ifequal = Module["_hs_voip_sdp_rtcpfb_check_ifequal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_rtcpfb_check_ifequal"].apply(null, arguments);
});
var _hs_voip_sdp_set_encoding_name = Module["_hs_voip_sdp_set_encoding_name"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_encoding_name"].apply(null, arguments);
});
var _hs_voip_sdp_set_extra = Module["_hs_voip_sdp_set_extra"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_extra"].apply(null, arguments);
});
var _hs_voip_sdp_set_ice_candidates = Module["_hs_voip_sdp_set_ice_candidates"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_ice_candidates"].apply(null, arguments);
});
var _hs_voip_sdp_set_ice_option_tag = Module["_hs_voip_sdp_set_ice_option_tag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_ice_option_tag"].apply(null, arguments);
});
var _hs_voip_sdp_set_ice_remote_candidates = Module["_hs_voip_sdp_set_ice_remote_candidates"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_ice_remote_candidates"].apply(null, arguments);
});
var _hs_voip_sdp_set_icelite = Module["_hs_voip_sdp_set_icelite"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_icelite"].apply(null, arguments);
});
var _hs_voip_sdp_set_media_preconconf_status = Module["_hs_voip_sdp_set_media_preconconf_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_media_preconconf_status"].apply(null, arguments);
});
var _hs_voip_sdp_set_media_preconcurr_status = Module["_hs_voip_sdp_set_media_preconcurr_status"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_media_preconcurr_status"].apply(null, arguments);
});
var _hs_voip_sdp_set_media_precondes_stren = Module["_hs_voip_sdp_set_media_precondes_stren"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_media_precondes_stren"].apply(null, arguments);
});
var _hs_voip_sdp_set_media_type = Module["_hs_voip_sdp_set_media_type"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_media_type"].apply(null, arguments);
});
var _hs_voip_sdp_set_other_attr = Module["_hs_voip_sdp_set_other_attr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_other_attr"].apply(null, arguments);
});
var _hs_voip_sdp_set_pt_codec_fmtp = Module["_hs_voip_sdp_set_pt_codec_fmtp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_pt_codec_fmtp"].apply(null, arguments);
});
var _hs_voip_sdp_set_pt_telephone_event_fmtp = Module["_hs_voip_sdp_set_pt_telephone_event_fmtp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_pt_telephone_event_fmtp"].apply(null, arguments);
});
var _hs_voip_sdp_set_pt_value = Module["_hs_voip_sdp_set_pt_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_pt_value"].apply(null, arguments);
});
var _hs_voip_sdp_set_sess_email = Module["_hs_voip_sdp_set_sess_email"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_sess_email"].apply(null, arguments);
});
var _hs_voip_sdp_set_sess_ice_pwd = Module["_hs_voip_sdp_set_sess_ice_pwd"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_sess_ice_pwd"].apply(null, arguments);
});
var _hs_voip_sdp_set_sess_ice_ufrag = Module["_hs_voip_sdp_set_sess_ice_ufrag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_sess_ice_ufrag"].apply(null, arguments);
});
var _hs_voip_sdp_set_sess_time = Module["_hs_voip_sdp_set_sess_time"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_sess_time"].apply(null, arguments);
});
var _hs_voip_sdp_set_sess_time_zone = Module["_hs_voip_sdp_set_sess_time_zone"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_set_sess_time_zone"].apply(null, arguments);
});
var _hs_voip_sdp_struct_deep_copy = Module["_hs_voip_sdp_struct_deep_copy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_struct_deep_copy"].apply(null, arguments);
});
var _hs_voip_sdp_struct_destroy = Module["_hs_voip_sdp_struct_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_struct_destroy"].apply(null, arguments);
});
var _hs_voip_sdp_struct_init = Module["_hs_voip_sdp_struct_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_struct_init"].apply(null, arguments);
});
var _hs_voip_sdp_yyparse = Module["_hs_voip_sdp_yyparse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sdp_yyparse"].apply(null, arguments);
});
var _hs_voip_set_param = Module["_hs_voip_set_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_set_param"].apply(null, arguments);
});
var _hs_voip_set_strlist_param = Module["_hs_voip_set_strlist_param"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_set_strlist_param"].apply(null, arguments);
});
var _hs_voip_subscribe_mwi = Module["_hs_voip_subscribe_mwi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_subscribe_mwi"].apply(null, arguments);
});
var _hs_voip_subscribe_req = Module["_hs_voip_subscribe_req"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_subscribe_req"].apply(null, arguments);
});
var _hs_voip_sys_nwkevent_cb = Module["_hs_voip_sys_nwkevent_cb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_nwkevent_cb"].apply(null, arguments);
});
var _hs_voip_sys_post_event = Module["_hs_voip_sys_post_event"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_post_event"].apply(null, arguments);
});
var _hs_voip_sys_post_toapp = Module["_hs_voip_sys_post_toapp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_post_toapp"].apply(null, arguments);
});
var _hs_voip_sys_process_sysevent = Module["_hs_voip_sys_process_sysevent"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_process_sysevent"].apply(null, arguments);
});
var _hs_voip_sys_restart = Module["_hs_voip_sys_restart"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_restart"].apply(null, arguments);
});
var _hs_voip_sys_shutdown = Module["_hs_voip_sys_shutdown"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_shutdown"].apply(null, arguments);
});
var _hs_voip_sys_shutdown_internal = Module["_hs_voip_sys_shutdown_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_shutdown_internal"].apply(null, arguments);
});
var _hs_voip_sys_start = Module["_hs_voip_sys_start"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_sys_start"].apply(null, arguments);
});
var _hs_voip_unhold_call = Module["_hs_voip_unhold_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_unhold_call"].apply(null, arguments);
});
var _hs_voip_webrtc_create_peerconn = Module["_hs_voip_webrtc_create_peerconn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_create_peerconn"].apply(null, arguments);
});
var _hs_voip_webrtc_msg_create_and_post = Module["_hs_voip_webrtc_msg_create_and_post"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_msg_create_and_post"].apply(null, arguments);
});
var _hs_voip_webrtc_peerclient_close = Module["_hs_voip_webrtc_peerclient_close"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_peerclient_close"].apply(null, arguments);
});
var _hs_voip_webrtc_peerclient_create_offer = Module["_hs_voip_webrtc_peerclient_create_offer"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_peerclient_create_offer"].apply(null, arguments);
});
var _hs_voip_webrtc_peerclient_modify_stream = Module["_hs_voip_webrtc_peerclient_modify_stream"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_peerclient_modify_stream"].apply(null, arguments);
});
var _hs_voip_webrtc_peerclient_mute_call = Module["_hs_voip_webrtc_peerclient_mute_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_peerclient_mute_call"].apply(null, arguments);
});
var _hs_voip_webrtc_peerclient_sendMsg = Module["_hs_voip_webrtc_peerclient_sendMsg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_peerclient_sendMsg"].apply(null, arguments);
});
var _hs_voip_webrtc_peerclient_set_remote_desc = Module["_hs_voip_webrtc_peerclient_set_remote_desc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_peerclient_set_remote_desc"].apply(null, arguments);
});
var _hs_voip_webrtc_peerclient_unmute_call = Module["_hs_voip_webrtc_peerclient_unmute_call"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_voip_webrtc_peerclient_unmute_call"].apply(null, arguments);
});
var _hs_xml_construct = Module["_hs_xml_construct"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_construct"].apply(null, arguments);
});
var _hs_xml_create_tree = Module["_hs_xml_create_tree"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_create_tree"].apply(null, arguments);
});
var _hs_xml_data_deescape_ascii = Module["_hs_xml_data_deescape_ascii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_data_deescape_ascii"].apply(null, arguments);
});
var _hs_xml_data_escaping = Module["_hs_xml_data_escaping"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_data_escaping"].apply(null, arguments);
});
var _hs_xml_elmt_addattr = Module["_hs_xml_elmt_addattr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_addattr"].apply(null, arguments);
});
var _hs_xml_elmt_addns = Module["_hs_xml_elmt_addns"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_addns"].apply(null, arguments);
});
var _hs_xml_elmt_attrs_free = Module["_hs_xml_elmt_attrs_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_attrs_free"].apply(null, arguments);
});
var _hs_xml_elmt_create = Module["_hs_xml_elmt_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_create"].apply(null, arguments);
});
var _hs_xml_elmt_create_default = Module["_hs_xml_elmt_create_default"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_create_default"].apply(null, arguments);
});
var _hs_xml_elmt_free = Module["_hs_xml_elmt_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_free"].apply(null, arguments);
});
var _hs_xml_elmt_free_internal = Module["_hs_xml_elmt_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_free_internal"].apply(null, arguments);
});
var _hs_xml_elmt_free_ns = Module["_hs_xml_elmt_free_ns"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_free_ns"].apply(null, arguments);
});
var _hs_xml_elmt_updateattr = Module["_hs_xml_elmt_updateattr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_updateattr"].apply(null, arguments);
});
var _hs_xml_elmt_updatedata = Module["_hs_xml_elmt_updatedata"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_elmt_updatedata"].apply(null, arguments);
});
var _hs_xml_encode_elmtend = Module["_hs_xml_encode_elmtend"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_encode_elmtend"].apply(null, arguments);
});
var _hs_xml_get_attr_value = Module["_hs_xml_get_attr_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_attr_value"].apply(null, arguments);
});
var _hs_xml_get_attrbyindx = Module["_hs_xml_get_attrbyindx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_attrbyindx"].apply(null, arguments);
});
var _hs_xml_get_default_ns = Module["_hs_xml_get_default_ns"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_default_ns"].apply(null, arguments);
});
var _hs_xml_get_ns_value = Module["_hs_xml_get_ns_value"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_ns_value"].apply(null, arguments);
});
var _hs_xml_get_nsbyindx = Module["_hs_xml_get_nsbyindx"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_nsbyindx"].apply(null, arguments);
});
var _hs_xml_get_nsprefix_byval = Module["_hs_xml_get_nsprefix_byval"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_nsprefix_byval"].apply(null, arguments);
});
var _hs_xml_get_nsval_byprefix = Module["_hs_xml_get_nsval_byprefix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_nsval_byprefix"].apply(null, arguments);
});
var _hs_xml_get_paramvalue = Module["_hs_xml_get_paramvalue"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_get_paramvalue"].apply(null, arguments);
});
var _hs_xml_init_parser = Module["_hs_xml_init_parser"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_init_parser"].apply(null, arguments);
});
var _hs_xml_parse = Module["_hs_xml_parse"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_parse"].apply(null, arguments);
});
var _hs_xml_parse_element = Module["_hs_xml_parse_element"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_parse_element"].apply(null, arguments);
});
var _hs_xml_parse_syntax = Module["_hs_xml_parse_syntax"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_parse_syntax"].apply(null, arguments);
});
var _hs_xml_tree_free = Module["_hs_xml_tree_free"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_tree_free"].apply(null, arguments);
});
var _hs_xml_tree_free_internal = Module["_hs_xml_tree_free_internal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_tree_free_internal"].apply(null, arguments);
});
var _hs_xml_tree_init = Module["_hs_xml_tree_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_tree_init"].apply(null, arguments);
});
var _hs_xml_update_elmt = Module["_hs_xml_update_elmt"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_update_elmt"].apply(null, arguments);
});
var _hs_xml_update_paramvalue = Module["_hs_xml_update_paramvalue"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xml_update_paramvalue"].apply(null, arguments);
});
var _hs_xmlfrag_create = Module["_hs_xmlfrag_create"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xmlfrag_create"].apply(null, arguments);
});
var _hs_xmltree_elmt_add = Module["_hs_xmltree_elmt_add"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xmltree_elmt_add"].apply(null, arguments);
});
var _hs_xmltree_elmt_delfrag = Module["_hs_xmltree_elmt_delfrag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xmltree_elmt_delfrag"].apply(null, arguments);
});
var _hs_xmltree_elmt_find = Module["_hs_xmltree_elmt_find"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xmltree_elmt_find"].apply(null, arguments);
});
var _hs_xmltree_insert_frag = Module["_hs_xmltree_insert_frag"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_hs_xmltree_insert_frag"].apply(null, arguments);
});
var _htonl = Module["_htonl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_htonl"].apply(null, arguments);
});
var _htons = Module["_htons"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_htons"].apply(null, arguments);
});
var _if_nametoindex = Module["_if_nametoindex"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_if_nametoindex"].apply(null, arguments);
});
var _inet_ntoa = Module["_inet_ntoa"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_inet_ntoa"].apply(null, arguments);
});
var _inet_ntop = Module["_inet_ntop"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_inet_ntop"].apply(null, arguments);
});
var _inet_pton = Module["_inet_pton"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_inet_pton"].apply(null, arguments);
});
var _internal_memalign = Module["_internal_memalign"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_internal_memalign"].apply(null, arguments);
});
var _ioctl = Module["_ioctl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ioctl"].apply(null, arguments);
});
var _isalpha = Module["_isalpha"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_isalpha"].apply(null, arguments);
});
var _isdigit = Module["_isdigit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_isdigit"].apply(null, arguments);
});
var _isdigit_l = Module["_isdigit_l"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_isdigit_l"].apply(null, arguments);
});
var _islower = Module["_islower"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_islower"].apply(null, arguments);
});
var _isspace = Module["_isspace"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_isspace"].apply(null, arguments);
});
var _isupper = Module["_isupper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_isupper"].apply(null, arguments);
});
var _isxdigit = Module["_isxdigit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_isxdigit"].apply(null, arguments);
});
var _isxdigit_l = Module["_isxdigit_l"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_isxdigit_l"].apply(null, arguments);
});
var _listen = Module["_listen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_listen"].apply(null, arguments);
});
var _llvm_bswap_i16 = Module["_llvm_bswap_i16"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_llvm_bswap_i16"].apply(null, arguments);
});
var _llvm_bswap_i32 = Module["_llvm_bswap_i32"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_llvm_bswap_i32"].apply(null, arguments);
});
var _malloc = Module["_malloc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_malloc"].apply(null, arguments);
});
var _mbrlen = Module["_mbrlen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_mbrlen"].apply(null, arguments);
});
var _mbrtowc = Module["_mbrtowc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_mbrtowc"].apply(null, arguments);
});
var _mbsinit = Module["_mbsinit"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_mbsinit"].apply(null, arguments);
});
var _mbsnrtowcs = Module["_mbsnrtowcs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_mbsnrtowcs"].apply(null, arguments);
});
var _mbsrtowcs = Module["_mbsrtowcs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_mbsrtowcs"].apply(null, arguments);
});
var _mbtowc = Module["_mbtowc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_mbtowc"].apply(null, arguments);
});
var _media_handler = Module["_media_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_media_handler"].apply(null, arguments);
});
var _memalign = Module["_memalign"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_memalign"].apply(null, arguments);
});
var _memchr = Module["_memchr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_memchr"].apply(null, arguments);
});
var _memcmp = Module["_memcmp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_memcmp"].apply(null, arguments);
});
var _memcpy = Module["_memcpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_memcpy"].apply(null, arguments);
});
var _memmove = Module["_memmove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_memmove"].apply(null, arguments);
});
var _memset = Module["_memset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_memset"].apply(null, arguments);
});
var _merge_conf_info = Module["_merge_conf_info"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_merge_conf_info"].apply(null, arguments);
});
var _mkdir = Module["_mkdir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_mkdir"].apply(null, arguments);
});
var _msmCallback = Module["_msmCallback"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_msmCallback"].apply(null, arguments);
});
var _netlink_msg_to_ifaddr = Module["_netlink_msg_to_ifaddr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_netlink_msg_to_ifaddr"].apply(null, arguments);
});
var _nodtor = Module["_nodtor"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_nodtor"].apply(null, arguments);
});
var _ntohl = Module["_ntohl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ntohl"].apply(null, arguments);
});
var _ntohs = Module["_ntohs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ntohs"].apply(null, arguments);
});
var _open = Module["_open"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_open"].apply(null, arguments);
});
var _opendir = Module["_opendir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_opendir"].apply(null, arguments);
});
var _out = Module["_out"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_out"].apply(null, arguments);
});
var _pad = Module["_pad"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pad"].apply(null, arguments);
});
var _parse_actionstart = Module["_parse_actionstart"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_parse_actionstart"].apply(null, arguments);
});
var _parse_attributes = Module["_parse_attributes"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_parse_attributes"].apply(null, arguments);
});
var _parse_datetime = Module["_parse_datetime"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_parse_datetime"].apply(null, arguments);
});
var _pop_arg = Module["_pop_arg"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pop_arg"].apply(null, arguments);
});
var _pop_arg_long_double = Module["_pop_arg_long_double"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pop_arg_long_double"].apply(null, arguments);
});
var _printf = Module["_printf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_printf"].apply(null, arguments);
});
var _printf_core = Module["_printf_core"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_printf_core"].apply(null, arguments);
});
var _proxy_main = Module["_proxy_main"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_proxy_main"].apply(null, arguments);
});
var _pthread_attr_destroy = Module["_pthread_attr_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_attr_destroy"].apply(null, arguments);
});
var _pthread_attr_init = Module["_pthread_attr_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_attr_init"].apply(null, arguments);
});
var _pthread_attr_setdetachstate = Module["_pthread_attr_setdetachstate"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_attr_setdetachstate"].apply(null, arguments);
});
var _pthread_attr_setstacksize = Module["_pthread_attr_setstacksize"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_attr_setstacksize"].apply(null, arguments);
});
var _pthread_cond_broadcast = Module["_pthread_cond_broadcast"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_cond_broadcast"].apply(null, arguments);
});
var _pthread_cond_destroy = Module["_pthread_cond_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_cond_destroy"].apply(null, arguments);
});
var _pthread_cond_init = Module["_pthread_cond_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_cond_init"].apply(null, arguments);
});
var _pthread_cond_signal = Module["_pthread_cond_signal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_cond_signal"].apply(null, arguments);
});
var _pthread_cond_wait = Module["_pthread_cond_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_cond_wait"].apply(null, arguments);
});
var _pthread_condattr_init = Module["_pthread_condattr_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_condattr_init"].apply(null, arguments);
});
var _pthread_condattr_setclock = Module["_pthread_condattr_setclock"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_condattr_setclock"].apply(null, arguments);
});
var _pthread_mutex_destroy = Module["_pthread_mutex_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_mutex_destroy"].apply(null, arguments);
});
var _pthread_mutex_init = Module["_pthread_mutex_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_mutex_init"].apply(null, arguments);
});
var _pthread_mutexattr_destroy = Module["_pthread_mutexattr_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_mutexattr_destroy"].apply(null, arguments);
});
var _pthread_mutexattr_init = Module["_pthread_mutexattr_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_mutexattr_init"].apply(null, arguments);
});
var _pthread_self = Module["_pthread_self"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_self"].apply(null, arguments);
});
var _pthread_setspecific = Module["_pthread_setspecific"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_pthread_setspecific"].apply(null, arguments);
});
var _putchar = Module["_putchar"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_putchar"].apply(null, arguments);
});
var _puts = Module["_puts"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_puts"].apply(null, arguments);
});
var _rand = Module["_rand"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_rand"].apply(null, arguments);
});
var _readdir = Module["_readdir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_readdir"].apply(null, arguments);
});
var _realloc = Module["_realloc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_realloc"].apply(null, arguments);
});
var _recv = Module["_recv"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_recv"].apply(null, arguments);
});
var _recvfrom = Module["_recvfrom"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_recvfrom"].apply(null, arguments);
});
var _remove = Module["_remove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_remove"].apply(null, arguments);
});
var _rename = Module["_rename"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_rename"].apply(null, arguments);
});
var _res_init = Module["_res_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_res_init"].apply(null, arguments);
});
var _rmdir = Module["_rmdir"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_rmdir"].apply(null, arguments);
});
var _rmv_ns_prefix = Module["_rmv_ns_prefix"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_rmv_ns_prefix"].apply(null, arguments);
});
var _sbrk = Module["_sbrk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sbrk"].apply(null, arguments);
});
var _scalbn = Module["_scalbn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_scalbn"].apply(null, arguments);
});
var _scalbnl = Module["_scalbnl"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_scalbnl"].apply(null, arguments);
});
var _scanexp = Module["_scanexp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_scanexp"].apply(null, arguments);
});
var _select = Module["_select"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_select"].apply(null, arguments);
});
var _sem_destroy = Module["_sem_destroy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sem_destroy"].apply(null, arguments);
});
var _sem_init = Module["_sem_init"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sem_init"].apply(null, arguments);
});
var _sem_post = Module["_sem_post"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sem_post"].apply(null, arguments);
});
var _sem_timedwait = Module["_sem_timedwait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sem_timedwait"].apply(null, arguments);
});
var _sem_trywait = Module["_sem_trywait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sem_trywait"].apply(null, arguments);
});
var _sem_wait = Module["_sem_wait"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sem_wait"].apply(null, arguments);
});
var _send = Module["_send"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_send"].apply(null, arguments);
});
var _sendto = Module["_sendto"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sendto"].apply(null, arguments);
});
var _sm_docend = Module["_sm_docend"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sm_docend"].apply(null, arguments);
});
var _sm_docstart = Module["_sm_docstart"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sm_docstart"].apply(null, arguments);
});
var _sm_skipnode = Module["_sm_skipnode"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sm_skipnode"].apply(null, arguments);
});
var _sm_tagdata = Module["_sm_tagdata"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sm_tagdata"].apply(null, arguments);
});
var _sm_tagend = Module["_sm_tagend"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sm_tagend"].apply(null, arguments);
});
var _sm_tagstart = Module["_sm_tagstart"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sm_tagstart"].apply(null, arguments);
});
var _sn_write = Module["_sn_write"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sn_write"].apply(null, arguments);
});
var _snprintf = Module["_snprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_snprintf"].apply(null, arguments);
});
var _socket = Module["_socket"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_socket"].apply(null, arguments);
});
var _sprintf = Module["_sprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sprintf"].apply(null, arguments);
});
var _srand = Module["_srand"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_srand"].apply(null, arguments);
});
var _sscanf = Module["_sscanf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_sscanf"].apply(null, arguments);
});
var _stat = Module["_stat"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_stat"].apply(null, arguments);
});
var _store_int_201 = Module["_store_int_201"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_store_int_201"].apply(null, arguments);
});
var _strcat = Module["_strcat"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strcat"].apply(null, arguments);
});
var _strchr = Module["_strchr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strchr"].apply(null, arguments);
});
var _strcmp = Module["_strcmp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strcmp"].apply(null, arguments);
});
var _strcpy = Module["_strcpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strcpy"].apply(null, arguments);
});
var _strcspn = Module["_strcspn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strcspn"].apply(null, arguments);
});
var _strlen = Module["_strlen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strlen"].apply(null, arguments);
});
var _strncat = Module["_strncat"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strncat"].apply(null, arguments);
});
var _strncmp = Module["_strncmp"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strncmp"].apply(null, arguments);
});
var _strncpy = Module["_strncpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strncpy"].apply(null, arguments);
});
var _strpbrk = Module["_strpbrk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strpbrk"].apply(null, arguments);
});
var _strrchr = Module["_strrchr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strrchr"].apply(null, arguments);
});
var _strsignal = Module["_strsignal"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strsignal"].apply(null, arguments);
});
var _strspn = Module["_strspn"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strspn"].apply(null, arguments);
});
var _strstr = Module["_strstr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strstr"].apply(null, arguments);
});
var _strtod = Module["_strtod"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtod"].apply(null, arguments);
});
var _strtod_l = Module["_strtod_l"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtod_l"].apply(null, arguments);
});
var _strtof = Module["_strtof"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtof"].apply(null, arguments);
});
var _strtof_l = Module["_strtof_l"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtof_l"].apply(null, arguments);
});
var _strtok_r = Module["_strtok_r"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtok_r"].apply(null, arguments);
});
var _strtol = Module["_strtol"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtol"].apply(null, arguments);
});
var _strtold = Module["_strtold"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtold"].apply(null, arguments);
});
var _strtold_l = Module["_strtold_l"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtold_l"].apply(null, arguments);
});
var _strtoll = Module["_strtoll"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtoll"].apply(null, arguments);
});
var _strtoll_l = Module["_strtoll_l"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtoll_l"].apply(null, arguments);
});
var _strtoul = Module["_strtoul"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtoul"].apply(null, arguments);
});
var _strtoull = Module["_strtoull"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtoull"].apply(null, arguments);
});
var _strtoull_l = Module["_strtoull_l"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtoull_l"].apply(null, arguments);
});
var _strtox = Module["_strtox"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtox"].apply(null, arguments);
});
var _strtox_857 = Module["_strtox_857"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_strtox_857"].apply(null, arguments);
});
var _swapc = Module["_swapc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_swapc"].apply(null, arguments);
});
var _th_wrapper_common_entry = Module["_th_wrapper_common_entry"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_th_wrapper_common_entry"].apply(null, arguments);
});
var _threebyte_strstr = Module["_threebyte_strstr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_threebyte_strstr"].apply(null, arguments);
});
var _tolower = Module["_tolower"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_tolower"].apply(null, arguments);
});
var _toupper = Module["_toupper"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_toupper"].apply(null, arguments);
});
var _try_realloc_chunk = Module["_try_realloc_chunk"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_try_realloc_chunk"].apply(null, arguments);
});
var _twobyte_strstr = Module["_twobyte_strstr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_twobyte_strstr"].apply(null, arguments);
});
var _twoway_strstr = Module["_twoway_strstr"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_twoway_strstr"].apply(null, arguments);
});
var _uname = Module["_uname"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_uname"].apply(null, arguments);
});
var _undo = Module["_undo"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_undo"].apply(null, arguments);
});
var _ungetc = Module["_ungetc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_ungetc"].apply(null, arguments);
});
var _user_handler = Module["_user_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_user_handler"].apply(null, arguments);
});
var _users_handler = Module["_users_handler"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_users_handler"].apply(null, arguments);
});
var _usleep = Module["_usleep"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_usleep"].apply(null, arguments);
});
var _vasprintf = Module["_vasprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_vasprintf"].apply(null, arguments);
});
var _vfprintf = Module["_vfprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_vfprintf"].apply(null, arguments);
});
var _vfscanf = Module["_vfscanf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_vfscanf"].apply(null, arguments);
});
var _vsnprintf = Module["_vsnprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_vsnprintf"].apply(null, arguments);
});
var _vsprintf = Module["_vsprintf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_vsprintf"].apply(null, arguments);
});
var _vsscanf = Module["_vsscanf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_vsscanf"].apply(null, arguments);
});
var _wcrtomb = Module["_wcrtomb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wcrtomb"].apply(null, arguments);
});
var _wcslen = Module["_wcslen"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wcslen"].apply(null, arguments);
});
var _wcsnrtombs = Module["_wcsnrtombs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wcsnrtombs"].apply(null, arguments);
});
var _wcsrtombs = Module["_wcsrtombs"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wcsrtombs"].apply(null, arguments);
});
var _wctomb = Module["_wctomb"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wctomb"].apply(null, arguments);
});
var _wmemcpy = Module["_wmemcpy"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wmemcpy"].apply(null, arguments);
});
var _wmemmove = Module["_wmemmove"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wmemmove"].apply(null, arguments);
});
var _wmemset = Module["_wmemset"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_wmemset"].apply(null, arguments);
});
var _yy_fatal_error = Module["_yy_fatal_error"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["_yy_fatal_error"].apply(null, arguments);
});
var establishStackSpace = Module["establishStackSpace"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["establishStackSpace"].apply(null, arguments);
});
var globalCtors = Module["globalCtors"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["globalCtors"].apply(null, arguments);
});
var stackAlloc = Module["stackAlloc"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["stackAlloc"].apply(null, arguments);
});
var stackRestore = Module["stackRestore"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["stackRestore"].apply(null, arguments);
});
var stackSave = Module["stackSave"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["stackSave"].apply(null, arguments);
});
var dynCall_i = Module["dynCall_i"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_i"].apply(null, arguments);
});
var dynCall_ii = Module["dynCall_ii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_ii"].apply(null, arguments);
});
var dynCall_iidiiii = Module["dynCall_iidiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iidiiii"].apply(null, arguments);
});
var dynCall_iii = Module["dynCall_iii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iii"].apply(null, arguments);
});
var dynCall_iiii = Module["dynCall_iiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiii"].apply(null, arguments);
});
var dynCall_iiiii = Module["dynCall_iiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiii"].apply(null, arguments);
});
var dynCall_iiiiid = Module["dynCall_iiiiid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiid"].apply(null, arguments);
});
var dynCall_iiiiii = Module["dynCall_iiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiii"].apply(null, arguments);
});
var dynCall_iiiiiid = Module["dynCall_iiiiiid"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiiid"].apply(null, arguments);
});
var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiiii"].apply(null, arguments);
});
var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiiiii"].apply(null, arguments);
});
var dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiiiiii"].apply(null, arguments);
});
var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiiiiiii"].apply(null, arguments);
});
var dynCall_iiiiij = Module["dynCall_iiiiij"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_iiiiij"].apply(null, arguments);
});
var dynCall_jiji = Module["dynCall_jiji"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_jiji"].apply(null, arguments);
});
var dynCall_v = Module["dynCall_v"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_v"].apply(null, arguments);
});
var dynCall_vf = Module["dynCall_vf"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vf"].apply(null, arguments);
});
var dynCall_vff = Module["dynCall_vff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vff"].apply(null, arguments);
});
var dynCall_vfff = Module["dynCall_vfff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vfff"].apply(null, arguments);
});
var dynCall_vffff = Module["dynCall_vffff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vffff"].apply(null, arguments);
});
var dynCall_vi = Module["dynCall_vi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vi"].apply(null, arguments);
});
var dynCall_vif = Module["dynCall_vif"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vif"].apply(null, arguments);
});
var dynCall_viff = Module["dynCall_viff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viff"].apply(null, arguments);
});
var dynCall_vifff = Module["dynCall_vifff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vifff"].apply(null, arguments);
});
var dynCall_viffff = Module["dynCall_viffff"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viffff"].apply(null, arguments);
});
var dynCall_vii = Module["dynCall_vii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_vii"].apply(null, arguments);
});
var dynCall_viif = Module["dynCall_viif"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viif"].apply(null, arguments);
});
var dynCall_viifi = Module["dynCall_viifi"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viifi"].apply(null, arguments);
});
var dynCall_viii = Module["dynCall_viii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viii"].apply(null, arguments);
});
var dynCall_viiii = Module["dynCall_viiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiii"].apply(null, arguments);
});
var dynCall_viiiii = Module["dynCall_viiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiiii"].apply(null, arguments);
});
var dynCall_viiiiii = Module["dynCall_viiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiiiii"].apply(null, arguments);
});
var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiiiiii"].apply(null, arguments);
});
var dynCall_viiiiiiii = Module["dynCall_viiiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiiiiiii"].apply(null, arguments);
});
var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiiiiiiii"].apply(null, arguments);
});
var dynCall_viiiiiiiiii = Module["dynCall_viiiiiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiiiiiiiii"].apply(null, arguments);
});
var dynCall_viiiiiiiiiii = Module["dynCall_viiiiiiiiiii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viiiiiiiiiii"].apply(null, arguments);
});
var dynCall_viijii = Module["dynCall_viijii"] = (function() {
 assert(runtimeInitialized, "you need to wait for the runtime to be ready (e.g. wait for main() to be called)");
 assert(!runtimeExited, "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");
 return Module["asm"]["dynCall_viijii"].apply(null, arguments);
});
Module["asm"] = asm;
if (!Object.getOwnPropertyDescriptor(Module, "intArrayFromString")) Module["intArrayFromString"] = (function() {
 abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "intArrayToString")) Module["intArrayToString"] = (function() {
 abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["ccall"] = ccall;
Module["cwrap"] = cwrap;
if (!Object.getOwnPropertyDescriptor(Module, "setValue")) Module["setValue"] = (function() {
 abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "getValue")) Module["getValue"] = (function() {
 abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "allocate")) Module["allocate"] = (function() {
 abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["getMemory"] = getMemory;
if (!Object.getOwnPropertyDescriptor(Module, "AsciiToString")) Module["AsciiToString"] = (function() {
 abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "stringToAscii")) Module["stringToAscii"] = (function() {
 abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ArrayToString")) Module["UTF8ArrayToString"] = (function() {
 abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["UTF8ToString"] = UTF8ToString;
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8Array")) Module["stringToUTF8Array"] = (function() {
 abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["stringToUTF8"] = stringToUTF8;
Module["lengthBytesUTF8"] = lengthBytesUTF8;
if (!Object.getOwnPropertyDescriptor(Module, "UTF16ToString")) Module["UTF16ToString"] = (function() {
 abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF16")) Module["stringToUTF16"] = (function() {
 abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF16")) Module["lengthBytesUTF16"] = (function() {
 abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "UTF32ToString")) Module["UTF32ToString"] = (function() {
 abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF32")) Module["stringToUTF32"] = (function() {
 abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF32")) Module["lengthBytesUTF32"] = (function() {
 abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8")) Module["allocateUTF8"] = (function() {
 abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = (function() {
 abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreRun")) Module["addOnPreRun"] = (function() {
 abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "addOnInit")) Module["addOnInit"] = (function() {
 abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreMain")) Module["addOnPreMain"] = (function() {
 abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "addOnExit")) Module["addOnExit"] = (function() {
 abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "addOnPostRun")) Module["addOnPostRun"] = (function() {
 abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "writeStringToMemory")) Module["writeStringToMemory"] = (function() {
 abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "writeArrayToMemory")) Module["writeArrayToMemory"] = (function() {
 abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "writeAsciiToMemory")) Module["writeAsciiToMemory"] = (function() {
 abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["addRunDependency"] = addRunDependency;
Module["removeRunDependency"] = removeRunDependency;
if (!Object.getOwnPropertyDescriptor(Module, "ENV")) Module["ENV"] = (function() {
 abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "FS")) Module["FS"] = (function() {
 abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["FS_createFolder"] = FS.createFolder;
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
Module["FS_createLazyFile"] = FS.createLazyFile;
Module["FS_createLink"] = FS.createLink;
Module["FS_createDevice"] = FS.createDevice;
Module["FS_unlink"] = FS.unlink;
if (!Object.getOwnPropertyDescriptor(Module, "GL")) Module["GL"] = (function() {
 abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "dynamicAlloc")) Module["dynamicAlloc"] = (function() {
 abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "warnOnce")) Module["warnOnce"] = (function() {
 abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "loadDynamicLibrary")) Module["loadDynamicLibrary"] = (function() {
 abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "loadWebAssemblyModule")) Module["loadWebAssemblyModule"] = (function() {
 abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "getLEB")) Module["getLEB"] = (function() {
 abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "getFunctionTables")) Module["getFunctionTables"] = (function() {
 abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "alignFunctionTables")) Module["alignFunctionTables"] = (function() {
 abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "registerFunctions")) Module["registerFunctions"] = (function() {
 abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "addFunction")) Module["addFunction"] = (function() {
 abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "removeFunction")) Module["removeFunction"] = (function() {
 abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "getFuncWrapper")) Module["getFuncWrapper"] = (function() {
 abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "prettyPrint")) Module["prettyPrint"] = (function() {
 abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "makeBigInt")) Module["makeBigInt"] = (function() {
 abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "dynCall")) Module["dynCall"] = (function() {
 abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "getCompilerSetting")) Module["getCompilerSetting"] = (function() {
 abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "stackSave")) Module["stackSave"] = (function() {
 abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "stackRestore")) Module["stackRestore"] = (function() {
 abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "stackAlloc")) Module["stackAlloc"] = (function() {
 abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["establishStackSpace"] = establishStackSpace;
if (!Object.getOwnPropertyDescriptor(Module, "print")) Module["print"] = (function() {
 abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "printErr")) Module["printErr"] = (function() {
 abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "getTempRet0")) Module["getTempRet0"] = (function() {
 abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "setTempRet0")) Module["setTempRet0"] = (function() {
 abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "callMain")) Module["callMain"] = (function() {
 abort("'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
if (!Object.getOwnPropertyDescriptor(Module, "Pointer_stringify")) Module["Pointer_stringify"] = (function() {
 abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
});
Module["dynCall_ii"] = dynCall_ii;
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NORMAL")) Object.defineProperty(Module, "ALLOC_NORMAL", {
 get: (function() {
  abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
 })
});
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_STACK")) Object.defineProperty(Module, "ALLOC_STACK", {
 get: (function() {
  abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
 })
});
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_DYNAMIC")) Object.defineProperty(Module, "ALLOC_DYNAMIC", {
 get: (function() {
  abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
 })
});
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NONE")) Object.defineProperty(Module, "ALLOC_NONE", {
 get: (function() {
  abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");
 })
});
if (memoryInitializer && !ENVIRONMENT_IS_PTHREAD) {
 if (!isDataURI(memoryInitializer)) {
  memoryInitializer = locateFile(memoryInitializer);
 }
 if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
  var data = readBinary(memoryInitializer);
  HEAPU8.set(data, GLOBAL_BASE);
 } else {
  addRunDependency("memory initializer");
  var applyMemoryInitializer = (function(data) {
   if (data.byteLength) data = new Uint8Array(data);
   for (var i = 0; i < data.length; i++) {
    assert(GROWABLE_HEAP_LOAD_U8(GLOBAL_BASE + i | 0) === 0, "area for memory initializer should not have been touched before it's loaded");
   }
   HEAPU8.set(data, GLOBAL_BASE);
   if (Module["memoryInitializerRequest"]) delete Module["memoryInitializerRequest"].response;
   removeRunDependency("memory initializer");
  });
  var doBrowserLoad = (function() {
   readAsync(memoryInitializer, applyMemoryInitializer, (function() {
    throw "could not load memory initializer " + memoryInitializer;
   }));
  });
  if (Module["memoryInitializerRequest"]) {
   var useRequest = (function() {
    var request = Module["memoryInitializerRequest"];
    var response = request.response;
    if (request.status !== 200 && request.status !== 0) {
     console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
     doBrowserLoad();
     return;
    }
    applyMemoryInitializer(response);
   });
   if (Module["memoryInitializerRequest"].response) {
    setTimeout(useRequest, 0);
   } else {
    Module["memoryInitializerRequest"].addEventListener("load", useRequest);
   }
  } else {
   doBrowserLoad();
  }
 }
}
function ExitStatus(status) {
 this.name = "ExitStatus";
 this.message = "Program terminated with exit(" + status + ")";
 this.status = status;
}
var calledMain = false;
dependenciesFulfilled = function runCaller() {
 if (!Module["calledRun"]) run();
 if (!Module["calledRun"]) dependenciesFulfilled = runCaller;
};
function run(args) {
 args = args || arguments_;
 if (runDependencies > 0) {
  return;
 }
 writeStackCookie();
 preRun();
 if (runDependencies > 0) return;
 if (Module["calledRun"]) return;
 function doRun() {
  if (Module["calledRun"]) return;
  Module["calledRun"] = true;
  if (ABORT) return;
  initRuntime();
  preMain();
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  assert(!Module["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout((function() {
   setTimeout((function() {
    Module["setStatus"]("");
   }), 1);
   doRun();
  }), 1);
 } else {
  doRun();
 }
 checkStackCookie();
}
Module["run"] = run;
function checkUnflushedContent() {
 var print = out;
 var printErr = err;
 var has = false;
 out = err = (function(x) {
  has = true;
 });
 try {
  var flush = Module["_fflush"];
  if (flush) flush(0);
  [ "stdout", "stderr" ].forEach((function(name) {
   var info = FS.analyzePath("/dev/" + name);
   if (!info) return;
   var stream = info.object;
   var rdev = stream.rdev;
   var tty = TTY.ttys[rdev];
   if (tty && tty.output && tty.output.length) {
    has = true;
   }
  }));
 } catch (e) {}
 out = print;
 err = printErr;
 if (has) {
  warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.");
 }
}
function exit(status, implicit) {
 checkUnflushedContent();
 if (implicit && Module["noExitRuntime"] && status === 0) {
  return;
 }
 if (Module["noExitRuntime"]) {
  if (!implicit) {
   err("exit(" + status + ") called, but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)");
  }
 } else {
  PThread.terminateAllThreads();
  ABORT = true;
  EXITSTATUS = status;
  exitRuntime();
  if (Module["onExit"]) Module["onExit"](status);
 }
 quit_(status, new ExitStatus(status));
}
var abortDecorators = [];
function abort(what) {
 if (Module["onAbort"]) {
  Module["onAbort"](what);
 }
 if (ENVIRONMENT_IS_PTHREAD) console.error("Pthread aborting at " + (new Error).stack);
 what += "";
 out(what);
 err(what);
 ABORT = true;
 EXITSTATUS = 1;
 var extra = "";
 var output = "abort(" + what + ") at " + stackTrace() + extra;
 if (abortDecorators) {
  abortDecorators.forEach((function(decorator) {
   output = decorator(output, what);
  }));
 }
 throw output;
}
Module["abort"] = abort;
if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}
if (!ENVIRONMENT_IS_PTHREAD) Module["noExitRuntime"] = true;
if (!ENVIRONMENT_IS_PTHREAD) run(); else {
 Module["___embind_register_native_and_builtin_types"]();
}



